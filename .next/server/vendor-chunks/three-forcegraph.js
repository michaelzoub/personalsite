"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-forcegraph";
exports.ids = ["vendor-chunks/three-forcegraph"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-forcegraph/dist/three-forcegraph.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/three-forcegraph/dist/three-forcegraph.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ threeForcegraph)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var ngraph_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ngraph.graph */ \"(ssr)/./node_modules/ngraph.graph/index.js\");\n/* harmony import */ var ngraph_forcelayout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ngraph.forcelayout */ \"(ssr)/./node_modules/ngraph.forcelayout/index.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/max.js\");\n/* harmony import */ var data_bind_mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! data-bind-mapper */ \"(ssr)/./node_modules/data-bind-mapper/dist/data-bind-mapper.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tinycolor2 */ \"(ssr)/./node_modules/tinycolor2/esm/tinycolor.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return p;\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = _superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););\n  return t;\n}\nfunction _superPropGet(t, o, e, r) {\n  var p = _get(_getPrototypeOf(t.prototype ), o, e);\n  return \"function\" == typeof p ? function (t) {\n    return p.apply(e, t);\n  } : p;\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (undefined !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nvar _materialDispose = function materialDispose(material) {\n  if (material instanceof Array) {\n    material.forEach(_materialDispose);\n  } else {\n    if (material.map) {\n      material.map.dispose();\n    }\n    material.dispose();\n  }\n};\nvar _deallocate = function deallocate(obj) {\n  if (obj.geometry) {\n    obj.geometry.dispose();\n  }\n  if (obj.material) {\n    _materialDispose(obj.material);\n  }\n  if (obj.texture) {\n    obj.texture.dispose();\n  }\n  if (obj.children) {\n    obj.children.forEach(_deallocate);\n  }\n};\nvar emptyObject = function emptyObject(obj) {\n  while (obj.children.length) {\n    var childObj = obj.children[0];\n    obj.remove(childObj);\n    _deallocate(childObj);\n  }\n};\n\nvar _dataBindAttr = /*#__PURE__*/new WeakMap();\nvar _objBindAttr = /*#__PURE__*/new WeakMap();\nvar ThreeDigest = /*#__PURE__*/function (_DataBindMapper) {\n  function ThreeDigest(scene) {\n    var _this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$dataBindAttr = _ref.dataBindAttr,\n      dataBindAttr = _ref$dataBindAttr === undefined ? '__data' : _ref$dataBindAttr,\n      _ref$objBindAttr = _ref.objBindAttr,\n      objBindAttr = _ref$objBindAttr === undefined ? '__threeObj' : _ref$objBindAttr;\n    _classCallCheck(this, ThreeDigest);\n    _this = _callSuper(this, ThreeDigest);\n    _defineProperty(_this, \"scene\", undefined);\n    _classPrivateFieldInitSpec(_this, _dataBindAttr, undefined);\n    _classPrivateFieldInitSpec(_this, _objBindAttr, undefined);\n    _this.scene = scene;\n    _classPrivateFieldSet2(_dataBindAttr, _this, dataBindAttr);\n    _classPrivateFieldSet2(_objBindAttr, _this, objBindAttr);\n    _this.onRemoveObj(function () {});\n    return _this;\n  }\n  _inherits(ThreeDigest, _DataBindMapper);\n  return _createClass(ThreeDigest, [{\n    key: \"onCreateObj\",\n    value: function onCreateObj(fn) {\n      var _this2 = this;\n      _superPropGet(ThreeDigest, \"onCreateObj\", this)([function (d) {\n        var obj = fn(d);\n        d[_classPrivateFieldGet2(_objBindAttr, _this2)] = obj;\n        obj[_classPrivateFieldGet2(_dataBindAttr, _this2)] = d;\n        _this2.scene.add(obj);\n        return obj;\n      }]);\n      return this;\n    }\n  }, {\n    key: \"onRemoveObj\",\n    value: function onRemoveObj(fn) {\n      var _this3 = this;\n      _superPropGet(ThreeDigest, \"onRemoveObj\", this)([function (obj, dId) {\n        var d = _superPropGet(ThreeDigest, \"getData\", _this3)([obj]);\n        fn(obj, dId);\n        _this3.scene.remove(obj);\n        emptyObject(obj);\n        delete d[_classPrivateFieldGet2(_objBindAttr, _this3)];\n      }]);\n      return this;\n    }\n  }]);\n}(data_bind_mapper__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\nvar colorStr2Hex = function colorStr2Hex(str) {\n  return isNaN(str) ? parseInt((0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(str).toHex(), 16) : str;\n};\nvar colorAlpha = function colorAlpha(str) {\n  return isNaN(str) ? (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(str).getAlpha() : 1;\n};\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === undefined ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === undefined ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\nvar three$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Group: three__WEBPACK_IMPORTED_MODULE_7__.Group,\n  Mesh: three__WEBPACK_IMPORTED_MODULE_7__.Mesh,\n  MeshLambertMaterial: three__WEBPACK_IMPORTED_MODULE_7__.MeshLambertMaterial,\n  Color: three__WEBPACK_IMPORTED_MODULE_7__.Color,\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_7__.BufferGeometry,\n  BufferAttribute: three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute,\n  Matrix4: three__WEBPACK_IMPORTED_MODULE_7__.Matrix4,\n  Vector3: three__WEBPACK_IMPORTED_MODULE_7__.Vector3,\n  SphereGeometry: three__WEBPACK_IMPORTED_MODULE_7__.SphereGeometry,\n  CylinderGeometry: three__WEBPACK_IMPORTED_MODULE_7__.CylinderGeometry,\n  TubeGeometry: three__WEBPACK_IMPORTED_MODULE_7__.TubeGeometry,\n  ConeGeometry: three__WEBPACK_IMPORTED_MODULE_7__.ConeGeometry,\n  Line: three__WEBPACK_IMPORTED_MODULE_7__.Line,\n  LineBasicMaterial: three__WEBPACK_IMPORTED_MODULE_7__.LineBasicMaterial,\n  QuadraticBezierCurve3: three__WEBPACK_IMPORTED_MODULE_7__.QuadraticBezierCurve3,\n  CubicBezierCurve3: three__WEBPACK_IMPORTED_MODULE_7__.CubicBezierCurve3,\n  Box3: three__WEBPACK_IMPORTED_MODULE_7__.Box3\n};\nvar ngraph = {\n  graph: ngraph_graph__WEBPACK_IMPORTED_MODULE_0__,\n  forcelayout: ngraph_forcelayout__WEBPACK_IMPORTED_MODULE_1__\n};\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// support multiple method names for backwards threejs compatibility\nvar setAttributeFn = new three$1.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar applyMatrix4Fn = new three$1.BufferGeometry().applyMatrix4 ? 'applyMatrix4' : 'applyMatrix';\nvar ForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n  props: {\n    jsonUrl: {\n      onChange: function onChange(jsonUrl, state) {\n        var _this = this;\n        if (jsonUrl && !state.fetchingJson) {\n          // Load data asynchronously\n          state.fetchingJson = true;\n          state.onLoading();\n          fetch(jsonUrl).then(function (r) {\n            return r.json();\n          }).then(function (json) {\n            state.fetchingJson = false;\n            state.onFinishLoading(json);\n            _this.graphData(json);\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(graphData, state) {\n        state.engineRunning = false; // Pause simulation immediately\n      }\n    },\n    numDimensions: {\n      \"default\": 3,\n      onChange: function onChange(numDim, state) {\n        var chargeForce = state.d3ForceLayout.force('charge');\n        // Increase repulsion on 3D mode for improved spatial separation\n        if (chargeForce) {\n          chargeForce.strength(numDim > 2 ? -60 : -30);\n        }\n        if (numDim < 3) {\n          eraseDimension(state.graphData.nodes, 'z');\n        }\n        if (numDim < 2) {\n          eraseDimension(state.graphData.nodes, 'y');\n        }\n        function eraseDimension(nodes, dim) {\n          nodes.forEach(function (d) {\n            delete d[dim]; // position\n            delete d[\"v\".concat(dim)]; // velocity\n          });\n        }\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, zin, zout, radialin, radialout\n        !dagMode && state.forceEngine === 'd3' && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = n.fz = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4\n    },\n    // volume per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val'\n    },\n    nodeResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the sphere's circumference\n    nodeColor: {\n      \"default\": 'color'\n    },\n    nodeAutoColorBy: {},\n    nodeOpacity: {\n      \"default\": 0.75\n    },\n    nodeVisibility: {\n      \"default\": true\n    },\n    nodeThreeObject: {},\n    nodeThreeObjectExtend: {\n      \"default\": false\n    },\n    nodePositionUpdate: {\n      triggerUpdate: false\n    },\n    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true\n    },\n    linkColor: {\n      \"default\": 'color'\n    },\n    linkAutoColorBy: {},\n    linkOpacity: {\n      \"default\": 0.2\n    },\n    linkWidth: {},\n    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.\n    linkResolution: {\n      \"default\": 6\n    },\n    // how many radial segments in each line tube's geometry\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curvature radius (0: straight, 1: semi-circle)\n    linkCurveRotation: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)\n    linkMaterial: {},\n    linkThreeObject: {},\n    linkThreeObjectExtend: {\n      \"default\": false\n    },\n    linkPositionUpdate: {\n      triggerUpdate: false\n    },\n    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.\n    linkDirectionalArrowLength: {\n      \"default\": 0\n    },\n    linkDirectionalArrowColor: {},\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      \"default\": 0\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 0.5\n    },\n    linkDirectionalParticleColor: {},\n    linkDirectionalParticleResolution: {\n      \"default\": 4\n    },\n    // how many slice segments in the particle sphere's circumference\n    forceEngine: {\n      \"default\": 'd3'\n    },\n    // d3 or ngraph\n    d3AlphaMin: {\n      \"default\": 0\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.d3ForceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.d3ForceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.d3ForceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    ngraphPhysics: {\n      \"default\": {\n        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js\n        timeStep: 20,\n        gravity: -1.2,\n        theta: 0.8,\n        springLength: 30,\n        springCoefficient: 0.0008,\n        dragCoefficient: 0.02\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    refresh: function refresh(state) {\n      state._flushObjects = true;\n      state._rerender();\n      return this;\n    },\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.d3ForceLayout.force(forceName); // Force getter\n      }\n      state.d3ForceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.d3ForceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    tickFrame: function tickFrame(state) {\n      var isD3Sim = state.forceEngine !== 'ngraph';\n      if (state.engineRunning) {\n        layoutTick();\n      }\n      updateArrows();\n      updatePhotons();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin) {\n          state.engineRunning = false; // Stop ticking graph\n          state.onEngineStop();\n        } else {\n          state.layout[isD3Sim ? 'tick' : 'step'](); // Tick it\n          state.onEngineTick();\n        }\n        var nodeThreeObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObjectExtend);\n\n        // Update nodes position\n        state.nodeDataMapper.entries().forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            node = _ref2[0],\n            obj = _ref2[1];\n          if (!obj) return;\n          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);\n          var extendedObj = nodeThreeObjectExtendAccessor(node);\n          if (!state.nodePositionUpdate || !state.nodePositionUpdate(extendedObj ? obj.children[0] : obj, {\n            x: pos.x,\n            y: pos.y,\n            z: pos.z\n          }, node) // pass child custom object if extending the default\n          || extendedObj) {\n            obj.position.x = pos.x;\n            obj.position.y = pos.y || 0;\n            obj.position.z = pos.z || 0;\n          }\n        });\n\n        // Update links position\n        var linkWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var linkCurvatureAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var linkCurveRotationAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurveRotation);\n        var linkThreeObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObjectExtend);\n        state.linkDataMapper.entries().forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            link = _ref4[0],\n            lineObj = _ref4[1];\n          if (!lineObj) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          calcLinkCurve(link); // calculate link curve for all links, including custom replaced, so it can be used in directional functionality\n\n          var extendedObj = linkThreeObjectExtendAccessor(link);\n          if (state.linkPositionUpdate && state.linkPositionUpdate(extendedObj ? lineObj.children[1] : lineObj,\n          // pass child custom object if extending the default\n          {\n            start: {\n              x: start.x,\n              y: start.y,\n              z: start.z\n            },\n            end: {\n              x: end.x,\n              y: end.y,\n              z: end.z\n            }\n          }, link) && !extendedObj) {\n            // exit if successfully custom updated position of non-extended obj\n            return;\n          }\n          var curveResolution = 30; // # line segments\n          var curve = link.__curve;\n\n          // select default line obj if it's an extended group\n          var line = lineObj.children.length ? lineObj.children[0] : lineObj;\n          if (line.type === 'Line') {\n            // Update line geometry\n            if (!curve) {\n              // straight line\n              var linePos = line.geometry.getAttribute('position');\n              if (!linePos || !linePos.array || linePos.array.length !== 6) {\n                line.geometry[setAttributeFn]('position', linePos = new three$1.BufferAttribute(new Float32Array(2 * 3), 3));\n              }\n              linePos.array[0] = start.x;\n              linePos.array[1] = start.y || 0;\n              linePos.array[2] = start.z || 0;\n              linePos.array[3] = end.x;\n              linePos.array[4] = end.y || 0;\n              linePos.array[5] = end.z || 0;\n              linePos.needsUpdate = true;\n            } else {\n              // bezier curve line\n              var curvePnts = curve.getPoints(curveResolution);\n              // resize buffer if needed\n              if (line.geometry.getAttribute('position').array.length !== curvePnts.length * 3) {\n                line.geometry[setAttributeFn]('position', new three$1.BufferAttribute(new Float32Array(curvePnts.length * 3), 3));\n              }\n              line.geometry.setFromPoints(curvePnts);\n            }\n            line.geometry.computeBoundingSphere();\n          } else if (line.type === 'Mesh') {\n            // Update cylinder geometry\n\n            if (!curve) {\n              // straight tube\n              if (!line.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {\n                var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n                var r = linkWidth / 2;\n                var geometry = new three$1.CylinderGeometry(r, r, 1, state.linkResolution, 1, false);\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));\n                line.geometry.dispose();\n                line.geometry = geometry;\n              }\n              var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);\n              var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);\n              var distance = vStart.distanceTo(vEnd);\n              line.position.x = vStart.x;\n              line.position.y = vStart.y;\n              line.position.z = vStart.z;\n              line.scale.z = distance;\n              line.parent.localToWorld(vEnd); // lookAt requires world coords\n              line.lookAt(vEnd);\n            } else {\n              // curved tube\n              if (!line.geometry.type.match(/^Tube(Buffer)?Geometry$/)) {\n                // reset object positioning\n                line.position.set(0, 0, 0);\n                line.rotation.set(0, 0, 0);\n                line.scale.set(1, 1, 1);\n              }\n              var _linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n              var _r = _linkWidth / 2;\n              var _geometry = new three$1.TubeGeometry(curve, curveResolution, _r, state.linkResolution, false);\n              line.geometry.dispose();\n              line.geometry = _geometry;\n            }\n          }\n        });\n\n        //\n\n        function calcLinkCurve(link) {\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var curvature = linkCurvatureAccessor(link);\n          if (!curvature) {\n            link.__curve = null; // Straight line\n          } else {\n            // bezier curve line (only for line types)\n            var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);\n            var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);\n            var l = vStart.distanceTo(vEnd); // line length\n\n            var curve;\n            var curveRotation = linkCurveRotationAccessor(link);\n            if (l > 0) {\n              var dx = end.x - start.x;\n              var dy = end.y - start.y || 0;\n              var vLine = new three$1.Vector3().subVectors(vEnd, vStart);\n              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, 0)) // avoid cross-product of parallel vectors (prefer Z, fallback to Y)\n              .applyAxisAngle(vLine.normalize(), curveRotation) // rotate along line axis according to linkCurveRotation\n              .add(new three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));\n              curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);\n            } else {\n              // Same point, draw a loop\n              var d = curvature * 70;\n              var endAngle = -curveRotation; // Rotate clockwise (from Z angle perspective)\n              var startAngle = endAngle + Math.PI / 2;\n              curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three$1.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);\n            }\n            link.__curve = curve;\n          }\n        }\n      }\n      function updateArrows() {\n        // update link arrow position\n        var arrowRelPosAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var arrowLengthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var nodeValAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        state.arrowDataMapper.entries().forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n            link = _ref6[0],\n            arrowObj = _ref6[1];\n          if (!arrowObj) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.cbrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;\n          var endR = Math.cbrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;\n          var arrowLength = arrowLengthAccessor(link);\n          var arrowRelPos = arrowRelPosAccessor(link);\n          var getPosAlongLine = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(['x', 'y', 'z'].map(function (dim) {\n            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);\n          }).reduce(function (acc, v) {\n            return acc + v;\n          }, 0));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getPosAlongLine(posAlongLine / lineLen);\n          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);\n          ['x', 'y', 'z'].forEach(function (dim) {\n            return arrowObj.position[dim] = arrowTail[dim];\n          });\n          var headVec = _construct(three$1.Vector3, _toConsumableArray(['x', 'y', 'z'].map(function (c) {\n            return arrowHead[c];\n          })));\n          arrowObj.parent.localToWorld(headVec); // lookAt requires world coords\n          arrowObj.lookAt(headVec);\n        });\n      }\n      function updatePhotons() {\n        // update link particle positions\n        var particleSpeedAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        state.graphData.links.forEach(function (link) {\n          var photonsObj = state.particlesDataMapper.getObj(link);\n          var cyclePhotons = photonsObj && photonsObj.children;\n          var singleHopPhotons = link.__singleHopPhotonsObj && link.__singleHopPhotonsObj.children;\n          if ((!singleHopPhotons || !singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = particleSpeedAccessor(link);\n          var getPhotonPos = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          var photons = [].concat(_toConsumableArray(cyclePhotons || []), _toConsumableArray(singleHopPhotons || []));\n          photons.forEach(function (photon, idx) {\n            var singleHop = photon.parent.__linkThreeObjType === 'singleHopPhotons';\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : idx / cyclePhotons.length;\n            }\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                // remove particle\n                photon.parent.remove(photon);\n                emptyObject(photon);\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var pos = getPhotonPos(photonPosRatio);\n            ['x', 'y', 'z'].forEach(function (dim) {\n              return photon.position[dim] = pos[dim];\n            });\n          });\n        });\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link && state.graphData.links.includes(link)) {\n        if (!link.__singleHopPhotonsObj) {\n          var obj = new three$1.Group();\n          obj.__linkThreeObjType = 'singleHopPhotons';\n          link.__singleHopPhotonsObj = obj;\n          state.graphScene.add(obj);\n        }\n        var particleWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n        var numSegments = state.linkDirectionalParticleResolution;\n        var particleGeometry = new three$1.SphereGeometry(photonR, numSegments, numSegments);\n        var linkColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var particleColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor);\n        var photonColor = particleColorAccessor(link) || linkColorAccessor(link) || '#f0f0f0';\n        var materialColor = new three$1.Color(colorStr2Hex(photonColor));\n        var opacity = state.linkOpacity * 3;\n        var particleMaterial = new three$1.MeshLambertMaterial({\n          color: materialColor,\n          transparent: true,\n          opacity: opacity\n        });\n\n        // add a single hop particle\n        link.__singleHopPhotonsObj.add(new three$1.Mesh(particleGeometry, particleMaterial));\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      if (!state.initialised) return null;\n\n      // recursively collect all nested geometries bboxes\n      var bboxes = function getBboxes(obj) {\n        var bboxes = [];\n        if (obj.geometry) {\n          obj.geometry.computeBoundingBox();\n          var box = new three$1.Box3();\n          box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);\n          bboxes.push(box);\n        }\n        return bboxes.concat.apply(bboxes, _toConsumableArray((obj.children || []).filter(function (obj) {\n          return !obj.hasOwnProperty('__graphObjType') || obj.__graphObjType === 'node' && nodeFilter(obj.__data);\n        } // exclude filtered out nodes\n        ).map(getBboxes)));\n      }(state.graphScene);\n      if (!bboxes.length) return null;\n\n      // extract global x,y,z min/max\n      return Object.assign.apply(Object, _toConsumableArray(['x', 'y', 'z'].map(function (c) {\n        return _defineProperty({}, c, [(0,d3_array__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(bboxes, function (bb) {\n          return bb.min[c];\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(bboxes, function (bb) {\n          return bb.max[c];\n        })]);\n      })));\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      d3ForceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_14__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(threeObj, state) {\n    // Main three object to manipulate\n    state.graphScene = threeObj;\n    state.nodeDataMapper = new ThreeDigest(threeObj, {\n      objBindAttr: '__threeObj'\n    });\n    state.linkDataMapper = new ThreeDigest(threeObj, {\n      objBindAttr: '__lineObj'\n    });\n    state.arrowDataMapper = new ThreeDigest(threeObj, {\n      objBindAttr: '__arrowObj'\n    });\n    state.particlesDataMapper = new ThreeDigest(threeObj, {\n      objBindAttr: '__photonsObj'\n    });\n  },\n  update: function update(state, changedProps) {\n    var hasAnyPropChanged = function hasAnyPropChanged(propList) {\n      return propList.some(function (p) {\n        return changedProps.hasOwnProperty(p);\n      });\n    };\n    state.engineRunning = false; // pause simulation\n    typeof state.onUpdate === \"function\" && state.onUpdate();\n    if (state.nodeAutoColorBy !== null && hasAnyPropChanged(['nodeAutoColorBy', 'graphData', 'nodeColor'])) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null && hasAnyPropChanged(['linkAutoColorBy', 'graphData', 'linkColor'])) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // Digest nodes WebGL objects\n    if (state._flushObjects || hasAnyPropChanged(['graphData', 'nodeThreeObject', 'nodeThreeObjectExtend', 'nodeVal', 'nodeColor', 'nodeVisibility', 'nodeRelSize', 'nodeResolution', 'nodeOpacity'])) {\n      var customObjectAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObject);\n      var customObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObjectExtend);\n      var valAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var colorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n      var visibilityAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n      var sphereGeometries = {}; // indexed by node value\n      var sphereMaterials = {}; // indexed by color\n\n      if (state._flushObjects || hasAnyPropChanged([\n      // recreate objects if any of these props have changed\n      'nodeThreeObject', 'nodeThreeObjectExtend'])) state.nodeDataMapper.clear();\n      state.nodeDataMapper.onCreateObj(function (node) {\n        var customObj = customObjectAccessor(node);\n        var extendObj = customObjectExtendAccessor(node);\n        if (customObj && state.nodeThreeObject === customObj) {\n          // clone object if it's a shared object among all nodes\n          customObj = customObj.clone();\n        }\n        var obj;\n        if (customObj && !extendObj) {\n          obj = customObj;\n        } else {\n          // Add default object (sphere mesh)\n          obj = new three$1.Mesh();\n          obj.__graphDefaultObj = true;\n          if (customObj && extendObj) {\n            obj.add(customObj); // extend default with custom\n          }\n        }\n        obj.__graphObjType = 'node'; // Add object type\n\n        return obj;\n      }).onUpdateObj(function (obj, node) {\n        if (obj.__graphDefaultObj) {\n          // bypass internal updates for custom node objects\n          var val = valAccessor(node) || 1;\n          var radius = Math.cbrt(val) * state.nodeRelSize;\n          var numSegments = state.nodeResolution;\n          if (!obj.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || obj.geometry.parameters.radius !== radius || obj.geometry.parameters.widthSegments !== numSegments) {\n            if (!sphereGeometries.hasOwnProperty(val)) {\n              sphereGeometries[val] = new three$1.SphereGeometry(radius, numSegments, numSegments);\n            }\n            obj.geometry.dispose();\n            obj.geometry = sphereGeometries[val];\n          }\n          var color = colorAccessor(node);\n          var materialColor = new three$1.Color(colorStr2Hex(color || '#ffffaa'));\n          var opacity = state.nodeOpacity * colorAlpha(color);\n          if (obj.material.type !== 'MeshLambertMaterial' || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {\n            if (!sphereMaterials.hasOwnProperty(color)) {\n              sphereMaterials[color] = new three$1.MeshLambertMaterial({\n                color: materialColor,\n                transparent: true,\n                opacity: opacity\n              });\n            }\n            obj.material.dispose();\n            obj.material = sphereMaterials[color];\n          }\n        }\n      }).digest(state.graphData.nodes.filter(visibilityAccessor));\n    }\n\n    // Digest links WebGL objects\n    if (state._flushObjects || hasAnyPropChanged(['graphData', 'linkThreeObject', 'linkThreeObjectExtend', 'linkMaterial', 'linkColor', 'linkWidth', 'linkVisibility', 'linkResolution', 'linkOpacity', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution'])) {\n      var _customObjectAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObject);\n      var _customObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObjectExtend);\n      var customMaterialAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkMaterial);\n      var _visibilityAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n      var _colorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n      var widthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n      var cylinderGeometries = {}; // indexed by link width\n      var lambertLineMaterials = {}; // for cylinder objects, indexed by link color\n      var basicLineMaterials = {}; // for line objects, indexed by link color\n\n      var visibleLinks = state.graphData.links.filter(_visibilityAccessor);\n\n      // lines digest cycle\n      if (state._flushObjects || hasAnyPropChanged([\n      // recreate objects if any of these props have changed\n      'linkThreeObject', 'linkThreeObjectExtend', 'linkWidth'])) state.linkDataMapper.clear();\n      state.linkDataMapper.onRemoveObj(function (obj) {\n        // remove trailing single photons\n        var singlePhotonsObj = obj.__data && obj.__data.__singleHopPhotonsObj;\n        if (singlePhotonsObj) {\n          singlePhotonsObj.parent.remove(singlePhotonsObj);\n          emptyObject(singlePhotonsObj);\n          delete obj.__data.__singleHopPhotonsObj;\n        }\n      }).onCreateObj(function (link) {\n        var customObj = _customObjectAccessor(link);\n        var extendObj = _customObjectExtendAccessor(link);\n        if (customObj && state.linkThreeObject === customObj) {\n          // clone object if it's a shared object among all links\n          customObj = customObj.clone();\n        }\n        var defaultObj;\n        if (!customObj || extendObj) {\n          // construct default line obj\n          var useCylinder = !!widthAccessor(link);\n          if (useCylinder) {\n            defaultObj = new three$1.Mesh();\n          } else {\n            // Use plain line (constant width)\n            var lineGeometry = new three$1.BufferGeometry();\n            lineGeometry[setAttributeFn]('position', new three$1.BufferAttribute(new Float32Array(2 * 3), 3));\n            defaultObj = new three$1.Line(lineGeometry);\n          }\n        }\n        var obj;\n        if (!customObj) {\n          obj = defaultObj;\n          obj.__graphDefaultObj = true;\n        } else {\n          if (!extendObj) {\n            // use custom object\n            obj = customObj;\n          } else {\n            // extend default with custom in a group\n            obj = new three$1.Group();\n            obj.__graphDefaultObj = true;\n            obj.add(defaultObj);\n            obj.add(customObj);\n          }\n        }\n        obj.renderOrder = 10; // Prevent visual glitches of dark lines on top of nodes by rendering them last\n\n        obj.__graphObjType = 'link'; // Add object type\n\n        return obj;\n      }).onUpdateObj(function (updObj, link) {\n        if (updObj.__graphDefaultObj) {\n          // bypass internal updates for custom link objects\n          // select default object if it's an extended group\n          var obj = updObj.children.length ? updObj.children[0] : updObj;\n          var linkWidth = Math.ceil(widthAccessor(link) * 10) / 10;\n          var useCylinder = !!linkWidth;\n          if (useCylinder) {\n            var r = linkWidth / 2;\n            var numSegments = state.linkResolution;\n            if (!obj.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || obj.geometry.parameters.radiusTop !== r || obj.geometry.parameters.radialSegments !== numSegments) {\n              if (!cylinderGeometries.hasOwnProperty(linkWidth)) {\n                var geometry = new three$1.CylinderGeometry(r, r, 1, numSegments, 1, false);\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));\n                cylinderGeometries[linkWidth] = geometry;\n              }\n              obj.geometry.dispose();\n              obj.geometry = cylinderGeometries[linkWidth];\n            }\n          }\n          var customMaterial = customMaterialAccessor(link);\n          if (customMaterial) {\n            obj.material = customMaterial;\n          } else {\n            var color = _colorAccessor(link);\n            var materialColor = new three$1.Color(colorStr2Hex(color || '#f0f0f0'));\n            var opacity = state.linkOpacity * colorAlpha(color);\n            var materialType = useCylinder ? 'MeshLambertMaterial' : 'LineBasicMaterial';\n            if (obj.material.type !== materialType || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {\n              var lineMaterials = useCylinder ? lambertLineMaterials : basicLineMaterials;\n              if (!lineMaterials.hasOwnProperty(color)) {\n                lineMaterials[color] = new three$1[materialType]({\n                  color: materialColor,\n                  transparent: opacity < 1,\n                  opacity: opacity,\n                  depthWrite: opacity >= 1 // Prevent transparency issues\n                });\n              }\n              obj.material.dispose();\n              obj.material = lineMaterials[color];\n            }\n          }\n        }\n      }).digest(visibleLinks);\n\n      // Arrows digest cycle\n      if (state.linkDirectionalArrowLength || changedProps.hasOwnProperty('linkDirectionalArrowLength')) {\n        var arrowLengthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var arrowColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor);\n        state.arrowDataMapper.onCreateObj(function () {\n          var obj = new three$1.Mesh(undefined, new three$1.MeshLambertMaterial({\n            transparent: true\n          }));\n          obj.__linkThreeObjType = 'arrow'; // Add object type\n\n          return obj;\n        }).onUpdateObj(function (obj, link) {\n          var arrowLength = arrowLengthAccessor(link);\n          var numSegments = state.linkDirectionalArrowResolution;\n          if (!obj.geometry.type.match(/^Cone(Buffer)?Geometry$/) || obj.geometry.parameters.height !== arrowLength || obj.geometry.parameters.radialSegments !== numSegments) {\n            var coneGeometry = new three$1.ConeGeometry(arrowLength * 0.25, arrowLength, numSegments);\n            // Correct orientation\n            coneGeometry.translate(0, arrowLength / 2, 0);\n            coneGeometry.rotateX(Math.PI / 2);\n            obj.geometry.dispose();\n            obj.geometry = coneGeometry;\n          }\n          var arrowColor = arrowColorAccessor(link) || _colorAccessor(link) || '#f0f0f0';\n          obj.material.color = new three$1.Color(colorStr2Hex(arrowColor));\n          obj.material.opacity = state.linkOpacity * 3 * colorAlpha(arrowColor);\n        }).digest(visibleLinks.filter(arrowLengthAccessor));\n      }\n\n      // Photon particles digest cycle\n      if (state.linkDirectionalParticles || changedProps.hasOwnProperty('linkDirectionalParticles')) {\n        var particlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var particleWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var particleColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor);\n        var particleMaterials = {}; // indexed by link color\n        var particleGeometries = {}; // indexed by particle width\n\n        state.particlesDataMapper.onCreateObj(function () {\n          var obj = new three$1.Group();\n          obj.__linkThreeObjType = 'photons'; // Add object type\n\n          obj.__photonDataMapper = new ThreeDigest(obj);\n          return obj;\n        }).onUpdateObj(function (obj, link) {\n          var numPhotons = Math.round(Math.abs(particlesAccessor(link)));\n          var curPhoton = !!obj.children.length && obj.children[0];\n          var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n          var numSegments = state.linkDirectionalParticleResolution;\n          var particleGeometry;\n          if (curPhoton && curPhoton.geometry.parameters.radius === photonR && curPhoton.geometry.parameters.widthSegments === numSegments) {\n            particleGeometry = curPhoton.geometry;\n          } else {\n            if (!particleGeometries.hasOwnProperty(photonR)) {\n              particleGeometries[photonR] = new three$1.SphereGeometry(photonR, numSegments, numSegments);\n            }\n            particleGeometry = particleGeometries[photonR];\n            curPhoton && curPhoton.geometry.dispose();\n          }\n          var photonColor = particleColorAccessor(link) || _colorAccessor(link) || '#f0f0f0';\n          var materialColor = new three$1.Color(colorStr2Hex(photonColor));\n          var opacity = state.linkOpacity * 3;\n          var particleMaterial;\n          if (curPhoton && curPhoton.material.color.equals(materialColor) && curPhoton.material.opacity === opacity) {\n            particleMaterial = curPhoton.material;\n          } else {\n            if (!particleMaterials.hasOwnProperty(photonColor)) {\n              particleMaterials[photonColor] = new three$1.MeshLambertMaterial({\n                color: materialColor,\n                transparent: true,\n                opacity: opacity\n              });\n            }\n            particleMaterial = particleMaterials[photonColor];\n            curPhoton && curPhoton.material.dispose();\n          }\n\n          // digest cycle for each photon\n          obj.__photonDataMapper.id(function (d) {\n            return d.idx;\n          }).onCreateObj(function () {\n            return new three$1.Mesh(particleGeometry, particleMaterial);\n          }).onUpdateObj(function (obj) {\n            obj.geometry = particleGeometry;\n            obj.material = particleMaterial;\n          }).digest(_toConsumableArray(new Array(numPhotons)).map(function (_, idx) {\n            return {\n              idx: idx\n            };\n          }));\n        }).digest(visibleLinks.filter(particlesAccessor));\n      }\n    }\n    state._flushObjects = false; // reset objects refresh flag\n\n    // simulation engine\n    if (hasAnyPropChanged(['graphData', 'nodeId', 'linkSource', 'linkTarget', 'numDimensions', 'forceEngine', 'dagMode', 'dagNodeFilter', 'dagLevelDistance'])) {\n      state.engineRunning = false; // Pause simulation\n\n      // parse links\n      state.graphData.links.forEach(function (link) {\n        link.source = link[state.linkSource];\n        link.target = link[state.linkTarget];\n      });\n\n      // Feed data to force-directed layout\n      var isD3Sim = state.forceEngine !== 'ngraph';\n      var layout;\n      if (isD3Sim) {\n        // D3-force\n        (layout = state.d3ForceLayout).stop().alpha(1) // re-heat the simulation\n        .numDimensions(state.numDimensions).nodes(state.graphData.nodes);\n\n        // add links (if link force is still active)\n        var linkForce = state.d3ForceLayout.force('link');\n        if (linkForce) {\n          linkForce.id(function (d) {\n            return d[state.nodeId];\n          }).links(state.graphData.links);\n        }\n\n        // setup dag force constraints\n        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n          return node[state.nodeId];\n        }, {\n          nodeFilter: state.dagNodeFilter,\n          onLoopError: state.onDagError || undefined\n        });\n        var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n        // Reset relevant f* when swapping dag modes\n        if (['lr', 'rl', 'td', 'bu', 'zin', 'zout'].includes(changedProps.dagMode)) {\n          var resetProp = ['lr', 'rl'].includes(changedProps.dagMode) ? 'fx' : ['td', 'bu'].includes(changedProps.dagMode) ? 'fy' : 'fz';\n          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n            return delete node[resetProp];\n          });\n        }\n\n        // Fix nodes to x,y,z for dag mode\n        if (['lr', 'rl', 'td', 'bu', 'zin', 'zout'].includes(state.dagMode)) {\n          var invert = ['rl', 'td', 'zout'].includes(state.dagMode);\n          var fixFn = function fixFn(node) {\n            return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n          };\n          var _resetProp = ['lr', 'rl'].includes(state.dagMode) ? 'fx' : ['td', 'bu'].includes(state.dagMode) ? 'fy' : 'fz';\n          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n            return node[_resetProp] = fixFn(node);\n          });\n        }\n\n        // Use radial force for radial dags\n        state.d3ForceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(function (node) {\n          var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n          return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n        }).strength(function (node) {\n          return state.dagNodeFilter(node) ? 1 : 0;\n        }) : null);\n      } else {\n        // ngraph\n        var _graph = ngraph.graph();\n        state.graphData.nodes.forEach(function (node) {\n          _graph.addNode(node[state.nodeId]);\n        });\n        state.graphData.links.forEach(function (link) {\n          _graph.addLink(link.source, link.target);\n        });\n        layout = ngraph.forcelayout(_graph, _objectSpread2({\n          dimensions: state.numDimensions\n        }, state.ngraphPhysics));\n        layout.graph = _graph; // Attach graph reference to layout\n      }\n      for (var i = 0; i < state.warmupTicks && !(isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin); i++) {\n        layout[isD3Sim ? \"tick\" : \"step\"]();\n      } // Initial ticks before starting to render\n\n      state.layout = layout;\n      this.resetCountdown();\n    }\n    state.engineRunning = true; // resume simulation\n\n    state.onFinishUpdate();\n  }\n});\n\nfunction fromKapsule (kapsule) {\n  var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;\n  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var ForceGraph = /*#__PURE__*/function (_baseClass) {\n    function ForceGraph() {\n      var _this;\n      _classCallCheck(this, ForceGraph);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, ForceGraph, [].concat(args));\n      _this.__kapsuleInstance = _construct(kapsule, [].concat(_toConsumableArray(initKapsuleWithSelf ? [_this] : []), args));\n      return _this;\n    }\n    _inherits(ForceGraph, _baseClass);\n    return _createClass(ForceGraph);\n  }(baseClass); // attach kapsule props/methods to class prototype\n  Object.keys(kapsule()).forEach(function (m) {\n    return ForceGraph.prototype[m] = function () {\n      var _this$__kapsuleInstan;\n      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);\n      return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj\n      : returnVal;\n    };\n  });\n  return ForceGraph;\n}\n\nvar three = window.THREE ? window.THREE : {\n  Group: three__WEBPACK_IMPORTED_MODULE_7__.Group\n}; // Prefer consumption from global THREE, if exists\nvar threeForcegraph = fromKapsule(ForceGraph, three.Group, true);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtZm9yY2VncmFwaC9kaXN0L3RocmVlLWZvcmNlZ3JhcGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBQO0FBQ3hKO0FBQ2pFO0FBQ1k7QUFDZjtBQUNPO0FBQ0Q7QUFDVTtBQUNOO0FBQ1U7QUFDZjs7QUFFbkM7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWSxrRUFBa0U7QUFDN0gsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLHlHQUF5Ryx3REFBVztBQUNwSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCO0FBQy9CO0FBQ0Esc0JBQXNCLCtHQUErRztBQUNySTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLFNBQVMsd0NBQUs7QUFDZCxHQUFHO0FBQ0g7O0FBRXNDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXHRocmVlLWZvcmNlZ3JhcGhcXGRpc3RcXHRocmVlLWZvcmNlZ3JhcGgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3VwLCBNZXNoLCBNZXNoTGFtYmVydE1hdGVyaWFsLCBDb2xvciwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgTWF0cml4NCwgVmVjdG9yMywgU3BoZXJlR2VvbWV0cnksIEN5bGluZGVyR2VvbWV0cnksIFR1YmVHZW9tZXRyeSwgQ29uZUdlb21ldHJ5LCBMaW5lLCBMaW5lQmFzaWNNYXRlcmlhbCwgUXVhZHJhdGljQmV6aWVyQ3VydmUzLCBDdWJpY0JlemllckN1cnZlMywgQm94MyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VMaW5rLCBmb3JjZU1hbnlCb2R5LCBmb3JjZUNlbnRlciwgZm9yY2VSYWRpYWwgfSBmcm9tICdkMy1mb3JjZS0zZCc7XG5pbXBvcnQgZ3JhcGggZnJvbSAnbmdyYXBoLmdyYXBoJztcbmltcG9ydCBmb3JjZWxheW91dCBmcm9tICduZ3JhcGguZm9yY2VsYXlvdXQnO1xuaW1wb3J0IEthcHN1bGUgZnJvbSAna2Fwc3VsZSc7XG5pbXBvcnQgYWNjZXNzb3JGbiBmcm9tICdhY2Nlc3Nvci1mbic7XG5pbXBvcnQgeyBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCBEYXRhQmluZE1hcHBlciBmcm9tICdkYXRhLWJpbmQtbWFwcGVyJztcbmltcG9ydCB7IHNjYWxlT3JkaW5hbCB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCB7IHNjaGVtZVBhaXJlZCB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYyc7XG5pbXBvcnQgdGlueUNvbG9yIGZyb20gJ3Rpbnljb2xvcjInO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCkge1xuICBpZiAodC5oYXMoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIocywgYSkge1xuICByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoZSwgdCwgYSkge1xuICBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSwgdC5zZXQoZSwgYSk7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQyKHMsIGEsIHIpIHtcbiAgcmV0dXJuIHMuc2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QodCwgZSwgcikge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgdmFyIG8gPSBbbnVsbF07XG4gIG8ucHVzaC5hcHBseShvLCBlKTtcbiAgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTtcbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgZmFsc2UsIG8uY29uZmlndXJhYmxlID0gdHJ1ZSwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSB0cnVlKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIHJldHVybiBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgdmFyIHAgPSBfc3VwZXJQcm9wQmFzZShlLCB0KTtcbiAgICBpZiAocCkge1xuICAgICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIHQpO1xuICAgICAgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7XG4gICAgfVxuICB9LCBfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSB0cnVlLFxuICAgICAgbyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSA7IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9IHRydWUsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodW5kZWZpbmVkICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKHQsIG8pIHtcbiAgZm9yICg7ICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIG51bGwgIT09ICh0ID0gX2dldFByb3RvdHlwZU9mKHQpKTspO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BHZXQodCwgbywgZSwgcikge1xuICB2YXIgcCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKHQucHJvdG90eXBlICksIG8sIGUpO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gcC5hcHBseShlLCB0KTtcbiAgfSA6IHA7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBfbWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gbWF0ZXJpYWxEaXNwb3NlKG1hdGVyaWFsKSB7XG4gIGlmIChtYXRlcmlhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWF0ZXJpYWwuZm9yRWFjaChfbWF0ZXJpYWxEaXNwb3NlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICBtYXRlcmlhbC5tYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gIH1cbn07XG52YXIgX2RlYWxsb2NhdGUgPSBmdW5jdGlvbiBkZWFsbG9jYXRlKG9iaikge1xuICBpZiAob2JqLmdlb21ldHJ5KSB7XG4gICAgb2JqLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLm1hdGVyaWFsKSB7XG4gICAgX21hdGVyaWFsRGlzcG9zZShvYmoubWF0ZXJpYWwpO1xuICB9XG4gIGlmIChvYmoudGV4dHVyZSkge1xuICAgIG9iai50ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgb2JqLmNoaWxkcmVuLmZvckVhY2goX2RlYWxsb2NhdGUpO1xuICB9XG59O1xudmFyIGVtcHR5T2JqZWN0ID0gZnVuY3Rpb24gZW1wdHlPYmplY3Qob2JqKSB7XG4gIHdoaWxlIChvYmouY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGNoaWxkT2JqID0gb2JqLmNoaWxkcmVuWzBdO1xuICAgIG9iai5yZW1vdmUoY2hpbGRPYmopO1xuICAgIF9kZWFsbG9jYXRlKGNoaWxkT2JqKTtcbiAgfVxufTtcblxudmFyIF9kYXRhQmluZEF0dHIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfb2JqQmluZEF0dHIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBUaHJlZURpZ2VzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RhdGFCaW5kTWFwcGVyKSB7XG4gIGZ1bmN0aW9uIFRocmVlRGlnZXN0KHNjZW5lKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZGF0YUJpbmRBdHRyID0gX3JlZi5kYXRhQmluZEF0dHIsXG4gICAgICBkYXRhQmluZEF0dHIgPSBfcmVmJGRhdGFCaW5kQXR0ciA9PT0gdW5kZWZpbmVkID8gJ19fZGF0YScgOiBfcmVmJGRhdGFCaW5kQXR0cixcbiAgICAgIF9yZWYkb2JqQmluZEF0dHIgPSBfcmVmLm9iakJpbmRBdHRyLFxuICAgICAgb2JqQmluZEF0dHIgPSBfcmVmJG9iakJpbmRBdHRyID09PSB1bmRlZmluZWQgPyAnX190aHJlZU9iaicgOiBfcmVmJG9iakJpbmRBdHRyO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaHJlZURpZ2VzdCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFRocmVlRGlnZXN0KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic2NlbmVcIiwgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2RhdGFCaW5kQXR0ciwgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX29iakJpbmRBdHRyLCB1bmRlZmluZWQpO1xuICAgIF90aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfZGF0YUJpbmRBdHRyLCBfdGhpcywgZGF0YUJpbmRBdHRyKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9vYmpCaW5kQXR0ciwgX3RoaXMsIG9iakJpbmRBdHRyKTtcbiAgICBfdGhpcy5vblJlbW92ZU9iaihmdW5jdGlvbiAoKSB7fSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUaHJlZURpZ2VzdCwgX0RhdGFCaW5kTWFwcGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUaHJlZURpZ2VzdCwgW3tcbiAgICBrZXk6IFwib25DcmVhdGVPYmpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DcmVhdGVPYmooZm4pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgX3N1cGVyUHJvcEdldChUaHJlZURpZ2VzdCwgXCJvbkNyZWF0ZU9ialwiLCB0aGlzKShbZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGZuKGQpO1xuICAgICAgICBkW19jbGFzc1ByaXZhdGVGaWVsZEdldDIoX29iakJpbmRBdHRyLCBfdGhpczIpXSA9IG9iajtcbiAgICAgICAgb2JqW19jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2RhdGFCaW5kQXR0ciwgX3RoaXMyKV0gPSBkO1xuICAgICAgICBfdGhpczIuc2NlbmUuYWRkKG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25SZW1vdmVPYmpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZW1vdmVPYmooZm4pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgX3N1cGVyUHJvcEdldChUaHJlZURpZ2VzdCwgXCJvblJlbW92ZU9ialwiLCB0aGlzKShbZnVuY3Rpb24gKG9iaiwgZElkKSB7XG4gICAgICAgIHZhciBkID0gX3N1cGVyUHJvcEdldChUaHJlZURpZ2VzdCwgXCJnZXREYXRhXCIsIF90aGlzMykoW29ial0pO1xuICAgICAgICBmbihvYmosIGRJZCk7XG4gICAgICAgIF90aGlzMy5zY2VuZS5yZW1vdmUob2JqKTtcbiAgICAgICAgZW1wdHlPYmplY3Qob2JqKTtcbiAgICAgICAgZGVsZXRlIGRbX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Mihfb2JqQmluZEF0dHIsIF90aGlzMyldO1xuICAgICAgfV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KERhdGFCaW5kTWFwcGVyKTtcblxudmFyIGNvbG9yU3RyMkhleCA9IGZ1bmN0aW9uIGNvbG9yU3RyMkhleChzdHIpIHtcbiAgcmV0dXJuIGlzTmFOKHN0cikgPyBwYXJzZUludCh0aW55Q29sb3Ioc3RyKS50b0hleCgpLCAxNikgOiBzdHI7XG59O1xudmFyIGNvbG9yQWxwaGEgPSBmdW5jdGlvbiBjb2xvckFscGhhKHN0cikge1xuICByZXR1cm4gaXNOYU4oc3RyKSA/IHRpbnlDb2xvcihzdHIpLmdldEFscGhhKCkgOiAxO1xufTtcbnZhciBhdXRvQ29sb3JTY2FsZSA9IHNjYWxlT3JkaW5hbChzY2hlbWVQYWlyZWQpO1xuXG4vLyBBdXRvc2V0IGF0dHJpYnV0ZSBjb2xvckZpZWxkIGJ5IGNvbG9yQnlBY2Nlc3NvciBwcm9wZXJ0eVxuLy8gSWYgYW4gb2JqZWN0IGhhcyBhbHJlYWR5IGEgY29sb3IsIGRvbid0IHNldCBpdFxuLy8gT2JqZWN0cyBjYW4gYmUgbm9kZXMgb3IgbGlua3NcbmZ1bmN0aW9uIGF1dG9Db2xvck9iamVjdHMob2JqZWN0cywgY29sb3JCeUFjY2Vzc29yLCBjb2xvckZpZWxkKSB7XG4gIGlmICghY29sb3JCeUFjY2Vzc29yIHx8IHR5cGVvZiBjb2xvckZpZWxkICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBvYmplY3RzLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICFvYmpbY29sb3JGaWVsZF07XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIG9ialtjb2xvckZpZWxkXSA9IGF1dG9Db2xvclNjYWxlKGNvbG9yQnlBY2Nlc3NvcihvYmopKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERhZ0RlcHRocyAoX3JlZiwgaWRBY2Nlc3Nvcikge1xuICB2YXIgbm9kZXMgPSBfcmVmLm5vZGVzLFxuICAgIGxpbmtzID0gX3JlZi5saW5rcztcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICBfcmVmMiRub2RlRmlsdGVyID0gX3JlZjIubm9kZUZpbHRlcixcbiAgICBub2RlRmlsdGVyID0gX3JlZjIkbm9kZUZpbHRlciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSA6IF9yZWYyJG5vZGVGaWx0ZXIsXG4gICAgX3JlZjIkb25Mb29wRXJyb3IgPSBfcmVmMi5vbkxvb3BFcnJvcixcbiAgICBvbkxvb3BFcnJvciA9IF9yZWYyJG9uTG9vcEVycm9yID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobG9vcElkcykge1xuICAgICAgdGhyb3cgXCJJbnZhbGlkIERBRyBzdHJ1Y3R1cmUhIEZvdW5kIGN5Y2xlIGluIG5vZGUgcGF0aDogXCIuY29uY2F0KGxvb3BJZHMuam9pbignIC0+ICcpLCBcIi5cIik7XG4gICAgfSA6IF9yZWYyJG9uTG9vcEVycm9yO1xuICAvLyBsaW5rZWQgZ3JhcGhcbiAgdmFyIGdyYXBoID0ge307XG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZ3JhcGhbaWRBY2Nlc3Nvcihub2RlKV0gPSB7XG4gICAgICBkYXRhOiBub2RlLFxuICAgICAgb3V0OiBbXSxcbiAgICAgIGRlcHRoOiAtMSxcbiAgICAgIHNraXA6ICFub2RlRmlsdGVyKG5vZGUpXG4gICAgfTtcbiAgfSk7XG4gIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHNvdXJjZSA9IF9yZWYzLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYzLnRhcmdldDtcbiAgICB2YXIgc291cmNlSWQgPSBnZXROb2RlSWQoc291cmNlKTtcbiAgICB2YXIgdGFyZ2V0SWQgPSBnZXROb2RlSWQodGFyZ2V0KTtcbiAgICBpZiAoIWdyYXBoLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkgdGhyb3cgXCJNaXNzaW5nIHNvdXJjZSBub2RlIHdpdGggaWQ6IFwiLmNvbmNhdChzb3VyY2VJZCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXRJZCkpIHRocm93IFwiTWlzc2luZyB0YXJnZXQgbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQodGFyZ2V0SWQpO1xuICAgIHZhciBzb3VyY2VOb2RlID0gZ3JhcGhbc291cmNlSWRdO1xuICAgIHZhciB0YXJnZXROb2RlID0gZ3JhcGhbdGFyZ2V0SWRdO1xuICAgIHNvdXJjZU5vZGUub3V0LnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgZnVuY3Rpb24gZ2V0Tm9kZUlkKG5vZGUpIHtcbiAgICAgIHJldHVybiBfdHlwZW9mKG5vZGUpID09PSAnb2JqZWN0JyA/IGlkQWNjZXNzb3Iobm9kZSkgOiBub2RlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBmb3VuZExvb3BzID0gW107XG4gIHRyYXZlcnNlKE9iamVjdC52YWx1ZXMoZ3JhcGgpKTtcbiAgdmFyIG5vZGVEZXB0aHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5lbnRyaWVzKGdyYXBoKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgbm9kZSA9IF9yZWY1WzFdO1xuICAgIHJldHVybiAhbm9kZS5za2lwO1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgdmFyIF9yZWY3ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjYsIDIpLFxuICAgICAgaWQgPSBfcmVmN1swXSxcbiAgICAgIG5vZGUgPSBfcmVmN1sxXTtcbiAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBpZCwgbm9kZS5kZXB0aCk7XG4gIH0pKSkpO1xuICByZXR1cm4gbm9kZURlcHRocztcbiAgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZXMpIHtcbiAgICB2YXIgbm9kZVN0YWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB2YXIgY3VycmVudERlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlU3RhY2suaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIGxvb3AgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjay5zbGljZShub2RlU3RhY2suaW5kZXhPZihub2RlKSkpLCBbbm9kZV0pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBpZEFjY2Vzc29yKGQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZvdW5kTG9vcHMuc29tZShmdW5jdGlvbiAoZm91bmRMb29wKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kTG9vcC5sZW5ndGggPT09IGxvb3AubGVuZ3RoICYmIGZvdW5kTG9vcC5ldmVyeShmdW5jdGlvbiAoaWQsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkID09PSBsb29wW2lkeF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgZm91bmRMb29wcy5wdXNoKGxvb3ApO1xuICAgICAgICAgIG9uTG9vcEVycm9yKGxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnREZXB0aCA+IG5vZGUuZGVwdGgpIHtcbiAgICAgICAgLy8gRG9uJ3QgdW5uZWNlc3NhcmlseSByZXZpc2l0IGNodW5rcyBvZiB0aGUgZ3JhcGhcbiAgICAgICAgbm9kZS5kZXB0aCA9IGN1cnJlbnREZXB0aDtcbiAgICAgICAgdHJhdmVyc2Uobm9kZS5vdXQsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZVN0YWNrKSwgW25vZGVdKSwgY3VycmVudERlcHRoICsgKG5vZGUuc2tpcCA/IDAgOiAxKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGhyZWUkMSA9IHdpbmRvdy5USFJFRSA/IHdpbmRvdy5USFJFRSAvLyBQcmVmZXIgY29uc3VtcHRpb24gZnJvbSBnbG9iYWwgVEhSRUUsIGlmIGV4aXN0c1xuOiB7XG4gIEdyb3VwOiBHcm91cCxcbiAgTWVzaDogTWVzaCxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogTWVzaExhbWJlcnRNYXRlcmlhbCxcbiAgQ29sb3I6IENvbG9yLFxuICBCdWZmZXJHZW9tZXRyeTogQnVmZmVyR2VvbWV0cnksXG4gIEJ1ZmZlckF0dHJpYnV0ZTogQnVmZmVyQXR0cmlidXRlLFxuICBNYXRyaXg0OiBNYXRyaXg0LFxuICBWZWN0b3IzOiBWZWN0b3IzLFxuICBTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG4gIEN5bGluZGVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXG4gIFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxuICBDb25lR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcbiAgTGluZTogTGluZSxcbiAgTGluZUJhc2ljTWF0ZXJpYWw6IExpbmVCYXNpY01hdGVyaWFsLFxuICBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6IFF1YWRyYXRpY0JlemllckN1cnZlMyxcbiAgQ3ViaWNCZXppZXJDdXJ2ZTM6IEN1YmljQmV6aWVyQ3VydmUzLFxuICBCb3gzOiBCb3gzXG59O1xudmFyIG5ncmFwaCA9IHtcbiAgZ3JhcGg6IGdyYXBoLFxuICBmb3JjZWxheW91dDogZm9yY2VsYXlvdXRcbn07XG5cbi8vXG5cbnZhciBEQUdfTEVWRUxfTk9ERV9SQVRJTyA9IDI7XG5cbi8vIHN1cHBvcnQgbXVsdGlwbGUgbWV0aG9kIG5hbWVzIGZvciBiYWNrd2FyZHMgdGhyZWVqcyBjb21wYXRpYmlsaXR5XG52YXIgc2V0QXR0cmlidXRlRm4gPSBuZXcgdGhyZWUkMS5CdWZmZXJHZW9tZXRyeSgpLnNldEF0dHJpYnV0ZSA/ICdzZXRBdHRyaWJ1dGUnIDogJ2FkZEF0dHJpYnV0ZSc7XG52YXIgYXBwbHlNYXRyaXg0Rm4gPSBuZXcgdGhyZWUkMS5CdWZmZXJHZW9tZXRyeSgpLmFwcGx5TWF0cml4NCA/ICdhcHBseU1hdHJpeDQnIDogJ2FwcGx5TWF0cml4JztcbnZhciBGb3JjZUdyYXBoID0gS2Fwc3VsZSh7XG4gIHByb3BzOiB7XG4gICAganNvblVybDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGpzb25VcmwsIHN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChqc29uVXJsICYmICFzdGF0ZS5mZXRjaGluZ0pzb24pIHtcbiAgICAgICAgICAvLyBMb2FkIGRhdGEgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICBzdGF0ZS5mZXRjaGluZ0pzb24gPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm9uTG9hZGluZygpO1xuICAgICAgICAgIGZldGNoKGpzb25VcmwpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByLmpzb24oKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICBzdGF0ZS5mZXRjaGluZ0pzb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLm9uRmluaXNoTG9hZGluZyhqc29uKTtcbiAgICAgICAgICAgIF90aGlzLmdyYXBoRGF0YShqc29uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGdyYXBoRGF0YSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBQYXVzZSBzaW11bGF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICB9XG4gICAgfSxcbiAgICBudW1EaW1lbnNpb25zOiB7XG4gICAgICBcImRlZmF1bHRcIjogMyxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShudW1EaW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBjaGFyZ2VGb3JjZSA9IHN0YXRlLmQzRm9yY2VMYXlvdXQuZm9yY2UoJ2NoYXJnZScpO1xuICAgICAgICAvLyBJbmNyZWFzZSByZXB1bHNpb24gb24gM0QgbW9kZSBmb3IgaW1wcm92ZWQgc3BhdGlhbCBzZXBhcmF0aW9uXG4gICAgICAgIGlmIChjaGFyZ2VGb3JjZSkge1xuICAgICAgICAgIGNoYXJnZUZvcmNlLnN0cmVuZ3RoKG51bURpbSA+IDIgPyAtNjAgOiAtMzApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1EaW0gPCAzKSB7XG4gICAgICAgICAgZXJhc2VEaW1lbnNpb24oc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLCAneicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1EaW0gPCAyKSB7XG4gICAgICAgICAgZXJhc2VEaW1lbnNpb24oc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLCAneScpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVyYXNlRGltZW5zaW9uKG5vZGVzLCBkaW0pIHtcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkZWxldGUgZFtkaW1dOyAvLyBwb3NpdGlvblxuICAgICAgICAgICAgZGVsZXRlIGRbXCJ2XCIuY29uY2F0KGRpbSldOyAvLyB2ZWxvY2l0eVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdNb2RlOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZGFnTW9kZSwgc3RhdGUpIHtcbiAgICAgICAgLy8gdGQsIGJ1LCBsciwgcmwsIHppbiwgem91dCwgcmFkaWFsaW4sIHJhZGlhbG91dFxuICAgICAgICAhZGFnTW9kZSAmJiBzdGF0ZS5mb3JjZUVuZ2luZSA9PT0gJ2QzJyAmJiAoc3RhdGUuZ3JhcGhEYXRhLm5vZGVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uZnggPSBuLmZ5ID0gbi5meiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7IC8vIHVuZml4IG5vZGVzIHdoZW4gZGlzYWJsaW5nIGRhZyBtb2RlXG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdMZXZlbERpc3RhbmNlOiB7fSxcbiAgICBkYWdOb2RlRmlsdGVyOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQobm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGFnRXJyb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUmVsU2l6ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDRcbiAgICB9LFxuICAgIC8vIHZvbHVtZSBwZXIgdmFsIHVuaXRcbiAgICBub2RlSWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnaWQnXG4gICAgfSxcbiAgICBub2RlVmFsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3ZhbCdcbiAgICB9LFxuICAgIG5vZGVSZXNvbHV0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogOFxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIHNwaGVyZSdzIGNpcmN1bWZlcmVuY2VcbiAgICBub2RlQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InXG4gICAgfSxcbiAgICBub2RlQXV0b0NvbG9yQnk6IHt9LFxuICAgIG5vZGVPcGFjaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC43NVxuICAgIH0sXG4gICAgbm9kZVZpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlXG4gICAgfSxcbiAgICBub2RlVGhyZWVPYmplY3Q6IHt9LFxuICAgIG5vZGVUaHJlZU9iamVjdEV4dGVuZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUG9zaXRpb25VcGRhdGU6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBjdXN0b20gZnVuY3Rpb24gdG8gY2FsbCBmb3IgdXBkYXRpbmcgdGhlIG5vZGUncyBwb3NpdGlvbi4gU2lnbmF0dXJlOiAodGhyZWVPYmosIHsgeCwgeSwgen0sIG5vZGUpLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhlIHJlZ3VsYXIgbm9kZSBwb3NpdGlvbiB1cGRhdGUgd2lsbCBub3QgcnVuLlxuICAgIGxpbmtTb3VyY2U6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnc291cmNlJ1xuICAgIH0sXG4gICAgbGlua1RhcmdldDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd0YXJnZXQnXG4gICAgfSxcbiAgICBsaW5rVmlzaWJpbGl0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIGxpbmtDb2xvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdjb2xvcidcbiAgICB9LFxuICAgIGxpbmtBdXRvQ29sb3JCeToge30sXG4gICAgbGlua09wYWNpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjJcbiAgICB9LFxuICAgIGxpbmtXaWR0aDoge30sXG4gICAgLy8gUm91bmRlZCB0byBuZWFyZXN0IGRlY2ltYWwuIEZvciBmYWxzeSB2YWx1ZXMgdXNlIGRpbWVuc2lvbmxlc3MgbGluZSB3aXRoIDFweCByZWdhcmRsZXNzIG9mIGRpc3RhbmNlLlxuICAgIGxpbmtSZXNvbHV0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNlxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgcmFkaWFsIHNlZ21lbnRzIGluIGVhY2ggbGluZSB0dWJlJ3MgZ2VvbWV0cnlcbiAgICBsaW5rQ3VydmF0dXJlOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBsaW5lIGN1cnZhdHVyZSByYWRpdXMgKDA6IHN0cmFpZ2h0LCAxOiBzZW1pLWNpcmNsZSlcbiAgICBsaW5rQ3VydmVSb3RhdGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gbGluZSBjdXJ2ZSByb3RhdGlvbiBhbG9uZyB0aGUgbGluZSBheGlzICgwOiBpbnRlcmVjdGlvbiB3aXRoIFhZIHBsYW5lLCBQSTogdXBzaWRlIGRvd24pXG4gICAgbGlua01hdGVyaWFsOiB7fSxcbiAgICBsaW5rVGhyZWVPYmplY3Q6IHt9LFxuICAgIGxpbmtUaHJlZU9iamVjdEV4dGVuZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rUG9zaXRpb25VcGRhdGU6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBjdXN0b20gZnVuY3Rpb24gdG8gY2FsbCBmb3IgdXBkYXRpbmcgdGhlIGxpbmsncyBwb3NpdGlvbi4gU2lnbmF0dXJlOiAodGhyZWVPYmosIHsgc3RhcnQ6IHsgeCwgeSwgen0sICBlbmQ6IHsgeCwgeSwgeiB9fSwgbGluaykuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLCB0aGUgcmVndWxhciBsaW5rIHBvc2l0aW9uIHVwZGF0ZSB3aWxsIG5vdCBydW4uXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yOiB7fSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyB2YWx1ZSBiZXR3ZWVuIDA8PjEgaW5kaWNhdGluZyB0aGUgcmVsYXRpdmUgcG9zIGFsb25nIHRoZSAoZXhwb3NlZCkgbGluZVxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDhcbiAgICB9LFxuICAgIC8vIGhvdyBtYW55IHNsaWNlIHNlZ21lbnRzIGluIHRoZSBhcnJvdydzIGNvbmljIGNpcmN1bWZlcmVuY2VcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXM6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfSxcbiAgICAvLyBhbmltYXRlIHBob3RvbnMgdHJhdmVsbGluZyBpbiB0aGUgbGluayBkaXJlY3Rpb25cbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBpbiBsaW5rIGxlbmd0aCByYXRpbyBwZXIgZnJhbWVcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC41XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yOiB7fSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0XG4gICAgfSxcbiAgICAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgcGFydGljbGUgc3BoZXJlJ3MgY2lyY3VtZmVyZW5jZVxuICAgIGZvcmNlRW5naW5lOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2QzJ1xuICAgIH0sXG4gICAgLy8gZDMgb3IgbmdyYXBoXG4gICAgZDNBbHBoYU1pbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIGQzQWxwaGFEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDIyOCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGFscGhhRGVjYXksIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmQzRm9yY2VMYXlvdXQuYWxwaGFEZWNheShhbHBoYURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzQWxwaGFUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoYWxwaGFUYXJnZXQsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmQzRm9yY2VMYXlvdXQuYWxwaGFUYXJnZXQoYWxwaGFUYXJnZXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDNWZWxvY2l0eURlY2F5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC40LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmVsb2NpdHlEZWNheSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZDNGb3JjZUxheW91dC52ZWxvY2l0eURlY2F5KHZlbG9jaXR5RGVjYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmdyYXBoUGh5c2ljczoge1xuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgLy8gZGVmYXVsdHMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYW52YWthL25ncmFwaC5waHlzaWNzLnNpbXVsYXRvci9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgICAgICB0aW1lU3RlcDogMjAsXG4gICAgICAgIGdyYXZpdHk6IC0xLjIsXG4gICAgICAgIHRoZXRhOiAwLjgsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMzAsXG4gICAgICAgIHNwcmluZ0NvZWZmaWNpZW50OiAwLjAwMDgsXG4gICAgICAgIGRyYWdDb2VmZmljaWVudDogMC4wMlxuICAgICAgfVxuICAgIH0sXG4gICAgd2FybXVwVGlja3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIGhvdyBtYW55IHRpbWVzIHRvIHRpY2sgdGhlIGZvcmNlIGVuZ2luZSBhdCBpbml0IGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcbiAgICBjb29sZG93blRpY2tzOiB7XG4gICAgICBcImRlZmF1bHRcIjogSW5maW5pdHksXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgY29vbGRvd25UaW1lOiB7XG4gICAgICBcImRlZmF1bHRcIjogMTUwMDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gbXNcbiAgICBvbkxvYWRpbmc6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRmluaXNoTG9hZGluZzoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25VcGRhdGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRmluaXNoVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVRpY2s6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRW5naW5lU3RvcDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goc3RhdGUpIHtcbiAgICAgIHN0YXRlLl9mbHVzaE9iamVjdHMgPSB0cnVlO1xuICAgICAgc3RhdGUuX3JlcmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEV4cG9zZSBkMyBmb3JjZXMgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuICAgIGQzRm9yY2U6IGZ1bmN0aW9uIGQzRm9yY2Uoc3RhdGUsIGZvcmNlTmFtZSwgZm9yY2VGbikge1xuICAgICAgaWYgKGZvcmNlRm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuZDNGb3JjZUxheW91dC5mb3JjZShmb3JjZU5hbWUpOyAvLyBGb3JjZSBnZXR0ZXJcbiAgICAgIH1cbiAgICAgIHN0YXRlLmQzRm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lLCBmb3JjZUZuKTsgLy8gRm9yY2Ugc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGQzUmVoZWF0U2ltdWxhdGlvbjogZnVuY3Rpb24gZDNSZWhlYXRTaW11bGF0aW9uKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmFscGhhKDEpO1xuICAgICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyByZXNldCBjb29sZG93biBzdGF0ZVxuICAgIHJlc2V0Q291bnRkb3duOiBmdW5jdGlvbiByZXNldENvdW50ZG93bihzdGF0ZSkge1xuICAgICAgc3RhdGUuY250VGlja3MgPSAwO1xuICAgICAgc3RhdGUuc3RhcnRUaWNrVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdGlja0ZyYW1lOiBmdW5jdGlvbiB0aWNrRnJhbWUoc3RhdGUpIHtcbiAgICAgIHZhciBpc0QzU2ltID0gc3RhdGUuZm9yY2VFbmdpbmUgIT09ICduZ3JhcGgnO1xuICAgICAgaWYgKHN0YXRlLmVuZ2luZVJ1bm5pbmcpIHtcbiAgICAgICAgbGF5b3V0VGljaygpO1xuICAgICAgfVxuICAgICAgdXBkYXRlQXJyb3dzKCk7XG4gICAgICB1cGRhdGVQaG90b25zKCk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy9cblxuICAgICAgZnVuY3Rpb24gbGF5b3V0VGljaygpIHtcbiAgICAgICAgaWYgKCsrc3RhdGUuY250VGlja3MgPiBzdGF0ZS5jb29sZG93blRpY2tzIHx8IG5ldyBEYXRlKCkgLSBzdGF0ZS5zdGFydFRpY2tUaW1lID4gc3RhdGUuY29vbGRvd25UaW1lIHx8IGlzRDNTaW0gJiYgc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZDNGb3JjZUxheW91dC5hbHBoYSgpIDwgc3RhdGUuZDNBbHBoYU1pbikge1xuICAgICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gU3RvcCB0aWNraW5nIGdyYXBoXG4gICAgICAgICAgc3RhdGUub25FbmdpbmVTdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGF5b3V0W2lzRDNTaW0gPyAndGljaycgOiAnc3RlcCddKCk7IC8vIFRpY2sgaXRcbiAgICAgICAgICBzdGF0ZS5vbkVuZ2luZVRpY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZVRocmVlT2JqZWN0RXh0ZW5kQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVUaHJlZU9iamVjdEV4dGVuZCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHBvc2l0aW9uXG4gICAgICAgIHN0YXRlLm5vZGVEYXRhTWFwcGVyLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBub2RlID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBvYmogPSBfcmVmMlsxXTtcbiAgICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICAgIHZhciBwb3MgPSBpc0QzU2ltID8gbm9kZSA6IHN0YXRlLmxheW91dC5nZXROb2RlUG9zaXRpb24obm9kZVtzdGF0ZS5ub2RlSWRdKTtcbiAgICAgICAgICB2YXIgZXh0ZW5kZWRPYmogPSBub2RlVGhyZWVPYmplY3RFeHRlbmRBY2Nlc3Nvcihub2RlKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm5vZGVQb3NpdGlvblVwZGF0ZSB8fCAhc3RhdGUubm9kZVBvc2l0aW9uVXBkYXRlKGV4dGVuZGVkT2JqID8gb2JqLmNoaWxkcmVuWzBdIDogb2JqLCB7XG4gICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgIHk6IHBvcy55LFxuICAgICAgICAgICAgejogcG9zLnpcbiAgICAgICAgICB9LCBub2RlKSAvLyBwYXNzIGNoaWxkIGN1c3RvbSBvYmplY3QgaWYgZXh0ZW5kaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgfHwgZXh0ZW5kZWRPYmopIHtcbiAgICAgICAgICAgIG9iai5wb3NpdGlvbi54ID0gcG9zLng7XG4gICAgICAgICAgICBvYmoucG9zaXRpb24ueSA9IHBvcy55IHx8IDA7XG4gICAgICAgICAgICBvYmoucG9zaXRpb24ueiA9IHBvcy56IHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgbGlua3MgcG9zaXRpb25cbiAgICAgICAgdmFyIGxpbmtXaWR0aEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rV2lkdGgpO1xuICAgICAgICB2YXIgbGlua0N1cnZhdHVyZUFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ3VydmF0dXJlKTtcbiAgICAgICAgdmFyIGxpbmtDdXJ2ZVJvdGF0aW9uQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDdXJ2ZVJvdGF0aW9uKTtcbiAgICAgICAgdmFyIGxpbmtUaHJlZU9iamVjdEV4dGVuZEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVGhyZWVPYmplY3RFeHRlbmQpO1xuICAgICAgICBzdGF0ZS5saW5rRGF0YU1hcHBlci5lbnRyaWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICBsaW5rID0gX3JlZjRbMF0sXG4gICAgICAgICAgICBsaW5lT2JqID0gX3JlZjRbMV07XG4gICAgICAgICAgaWYgKCFsaW5lT2JqKSByZXR1cm47XG4gICAgICAgICAgdmFyIHBvcyA9IGlzRDNTaW0gPyBsaW5rIDogc3RhdGUubGF5b3V0LmdldExpbmtQb3NpdGlvbihzdGF0ZS5sYXlvdXQuZ3JhcGguZ2V0TGluayhsaW5rLnNvdXJjZSwgbGluay50YXJnZXQpLmlkKTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NbaXNEM1NpbSA/ICdzb3VyY2UnIDogJ2Zyb20nXTtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zW2lzRDNTaW0gPyAndGFyZ2V0JyA6ICd0byddO1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIGNhbGNMaW5rQ3VydmUobGluayk7IC8vIGNhbGN1bGF0ZSBsaW5rIGN1cnZlIGZvciBhbGwgbGlua3MsIGluY2x1ZGluZyBjdXN0b20gcmVwbGFjZWQsIHNvIGl0IGNhbiBiZSB1c2VkIGluIGRpcmVjdGlvbmFsIGZ1bmN0aW9uYWxpdHlcblxuICAgICAgICAgIHZhciBleHRlbmRlZE9iaiA9IGxpbmtUaHJlZU9iamVjdEV4dGVuZEFjY2Vzc29yKGxpbmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5saW5rUG9zaXRpb25VcGRhdGUgJiYgc3RhdGUubGlua1Bvc2l0aW9uVXBkYXRlKGV4dGVuZGVkT2JqID8gbGluZU9iai5jaGlsZHJlblsxXSA6IGxpbmVPYmosXG4gICAgICAgICAgLy8gcGFzcyBjaGlsZCBjdXN0b20gb2JqZWN0IGlmIGV4dGVuZGluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIHg6IHN0YXJ0LngsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0LnksXG4gICAgICAgICAgICAgIHo6IHN0YXJ0LnpcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgeDogZW5kLngsXG4gICAgICAgICAgICAgIHk6IGVuZC55LFxuICAgICAgICAgICAgICB6OiBlbmQuelxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGxpbmspICYmICFleHRlbmRlZE9iaikge1xuICAgICAgICAgICAgLy8gZXhpdCBpZiBzdWNjZXNzZnVsbHkgY3VzdG9tIHVwZGF0ZWQgcG9zaXRpb24gb2Ygbm9uLWV4dGVuZGVkIG9ialxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VydmVSZXNvbHV0aW9uID0gMzA7IC8vICMgbGluZSBzZWdtZW50c1xuICAgICAgICAgIHZhciBjdXJ2ZSA9IGxpbmsuX19jdXJ2ZTtcblxuICAgICAgICAgIC8vIHNlbGVjdCBkZWZhdWx0IGxpbmUgb2JqIGlmIGl0J3MgYW4gZXh0ZW5kZWQgZ3JvdXBcbiAgICAgICAgICB2YXIgbGluZSA9IGxpbmVPYmouY2hpbGRyZW4ubGVuZ3RoID8gbGluZU9iai5jaGlsZHJlblswXSA6IGxpbmVPYmo7XG4gICAgICAgICAgaWYgKGxpbmUudHlwZSA9PT0gJ0xpbmUnKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgbGluZSBnZW9tZXRyeVxuICAgICAgICAgICAgaWYgKCFjdXJ2ZSkge1xuICAgICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICAgIHZhciBsaW5lUG9zID0gbGluZS5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgIGlmICghbGluZVBvcyB8fCAhbGluZVBvcy5hcnJheSB8fCBsaW5lUG9zLmFycmF5Lmxlbmd0aCAhPT0gNikge1xuICAgICAgICAgICAgICAgIGxpbmUuZ2VvbWV0cnlbc2V0QXR0cmlidXRlRm5dKCdwb3NpdGlvbicsIGxpbmVQb3MgPSBuZXcgdGhyZWUkMS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSgyICogMyksIDMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaW5lUG9zLmFycmF5WzBdID0gc3RhcnQueDtcbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVsxXSA9IHN0YXJ0LnkgfHwgMDtcbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVsyXSA9IHN0YXJ0LnogfHwgMDtcbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVszXSA9IGVuZC54O1xuICAgICAgICAgICAgICBsaW5lUG9zLmFycmF5WzRdID0gZW5kLnkgfHwgMDtcbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVs1XSA9IGVuZC56IHx8IDA7XG4gICAgICAgICAgICAgIGxpbmVQb3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYmV6aWVyIGN1cnZlIGxpbmVcbiAgICAgICAgICAgICAgdmFyIGN1cnZlUG50cyA9IGN1cnZlLmdldFBvaW50cyhjdXJ2ZVJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAvLyByZXNpemUgYnVmZmVyIGlmIG5lZWRlZFxuICAgICAgICAgICAgICBpZiAobGluZS5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykuYXJyYXkubGVuZ3RoICE9PSBjdXJ2ZVBudHMubGVuZ3RoICogMykge1xuICAgICAgICAgICAgICAgIGxpbmUuZ2VvbWV0cnlbc2V0QXR0cmlidXRlRm5dKCdwb3NpdGlvbicsIG5ldyB0aHJlZSQxLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGN1cnZlUG50cy5sZW5ndGggKiAzKSwgMykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxpbmUuZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyhjdXJ2ZVBudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZS5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ01lc2gnKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY3lsaW5kZXIgZ2VvbWV0cnlcblxuICAgICAgICAgICAgaWYgKCFjdXJ2ZSkge1xuICAgICAgICAgICAgICAvLyBzdHJhaWdodCB0dWJlXG4gICAgICAgICAgICAgIGlmICghbGluZS5nZW9tZXRyeS50eXBlLm1hdGNoKC9eQ3lsaW5kZXIoQnVmZmVyKT9HZW9tZXRyeSQvKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rV2lkdGggPSBNYXRoLmNlaWwobGlua1dpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGxpbmtXaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IHRocmVlJDEuQ3lsaW5kZXJHZW9tZXRyeShyLCByLCAxLCBzdGF0ZS5saW5rUmVzb2x1dGlvbiwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5W2FwcGx5TWF0cml4NEZuXShuZXcgdGhyZWUkMS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKDAsIDEgLyAyLCAwKSk7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlbYXBwbHlNYXRyaXg0Rm5dKG5ldyB0aHJlZSQxLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKE1hdGguUEkgLyAyKSk7XG4gICAgICAgICAgICAgICAgbGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgbGluZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB2U3RhcnQgPSBuZXcgdGhyZWUkMS5WZWN0b3IzKHN0YXJ0LngsIHN0YXJ0LnkgfHwgMCwgc3RhcnQueiB8fCAwKTtcbiAgICAgICAgICAgICAgdmFyIHZFbmQgPSBuZXcgdGhyZWUkMS5WZWN0b3IzKGVuZC54LCBlbmQueSB8fCAwLCBlbmQueiB8fCAwKTtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdlN0YXJ0LmRpc3RhbmNlVG8odkVuZCk7XG4gICAgICAgICAgICAgIGxpbmUucG9zaXRpb24ueCA9IHZTdGFydC54O1xuICAgICAgICAgICAgICBsaW5lLnBvc2l0aW9uLnkgPSB2U3RhcnQueTtcbiAgICAgICAgICAgICAgbGluZS5wb3NpdGlvbi56ID0gdlN0YXJ0Lno7XG4gICAgICAgICAgICAgIGxpbmUuc2NhbGUueiA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICBsaW5lLnBhcmVudC5sb2NhbFRvV29ybGQodkVuZCk7IC8vIGxvb2tBdCByZXF1aXJlcyB3b3JsZCBjb29yZHNcbiAgICAgICAgICAgICAgbGluZS5sb29rQXQodkVuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjdXJ2ZWQgdHViZVxuICAgICAgICAgICAgICBpZiAoIWxpbmUuZ2VvbWV0cnkudHlwZS5tYXRjaCgvXlR1YmUoQnVmZmVyKT9HZW9tZXRyeSQvKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IG9iamVjdCBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgICAgIGxpbmUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICAgICAgICAgIGxpbmUucm90YXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICAgICAgICAgIGxpbmUuc2NhbGUuc2V0KDEsIDEsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBfbGlua1dpZHRoID0gTWF0aC5jZWlsKGxpbmtXaWR0aEFjY2Vzc29yKGxpbmspICogMTApIC8gMTA7XG4gICAgICAgICAgICAgIHZhciBfciA9IF9saW5rV2lkdGggLyAyO1xuICAgICAgICAgICAgICB2YXIgX2dlb21ldHJ5ID0gbmV3IHRocmVlJDEuVHViZUdlb21ldHJ5KGN1cnZlLCBjdXJ2ZVJlc29sdXRpb24sIF9yLCBzdGF0ZS5saW5rUmVzb2x1dGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICBsaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgbGluZS5nZW9tZXRyeSA9IF9nZW9tZXRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gY2FsY0xpbmtDdXJ2ZShsaW5rKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGlzRDNTaW0gPyBsaW5rIDogc3RhdGUubGF5b3V0LmdldExpbmtQb3NpdGlvbihzdGF0ZS5sYXlvdXQuZ3JhcGguZ2V0TGluayhsaW5rLnNvdXJjZSwgbGluay50YXJnZXQpLmlkKTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NbaXNEM1NpbSA/ICdzb3VyY2UnIDogJ2Zyb20nXTtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zW2lzRDNTaW0gPyAndGFyZ2V0JyA6ICd0byddO1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIHZhciBjdXJ2YXR1cmUgPSBsaW5rQ3VydmF0dXJlQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgaWYgKCFjdXJ2YXR1cmUpIHtcbiAgICAgICAgICAgIGxpbmsuX19jdXJ2ZSA9IG51bGw7IC8vIFN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmV6aWVyIGN1cnZlIGxpbmUgKG9ubHkgZm9yIGxpbmUgdHlwZXMpXG4gICAgICAgICAgICB2YXIgdlN0YXJ0ID0gbmV3IHRocmVlJDEuVmVjdG9yMyhzdGFydC54LCBzdGFydC55IHx8IDAsIHN0YXJ0LnogfHwgMCk7XG4gICAgICAgICAgICB2YXIgdkVuZCA9IG5ldyB0aHJlZSQxLlZlY3RvcjMoZW5kLngsIGVuZC55IHx8IDAsIGVuZC56IHx8IDApO1xuICAgICAgICAgICAgdmFyIGwgPSB2U3RhcnQuZGlzdGFuY2VUbyh2RW5kKTsgLy8gbGluZSBsZW5ndGhcblxuICAgICAgICAgICAgdmFyIGN1cnZlO1xuICAgICAgICAgICAgdmFyIGN1cnZlUm90YXRpb24gPSBsaW5rQ3VydmVSb3RhdGlvbkFjY2Vzc29yKGxpbmspO1xuICAgICAgICAgICAgaWYgKGwgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICAgICAgICAgICAgdmFyIGR5ID0gZW5kLnkgLSBzdGFydC55IHx8IDA7XG4gICAgICAgICAgICAgIHZhciB2TGluZSA9IG5ldyB0aHJlZSQxLlZlY3RvcjMoKS5zdWJWZWN0b3JzKHZFbmQsIHZTdGFydCk7XG4gICAgICAgICAgICAgIHZhciBjcCA9IHZMaW5lLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoY3VydmF0dXJlKS5jcm9zcyhkeCAhPT0gMCB8fCBkeSAhPT0gMCA/IG5ldyB0aHJlZSQxLlZlY3RvcjMoMCwgMCwgMSkgOiBuZXcgdGhyZWUkMS5WZWN0b3IzKDAsIDEsIDApKSAvLyBhdm9pZCBjcm9zcy1wcm9kdWN0IG9mIHBhcmFsbGVsIHZlY3RvcnMgKHByZWZlciBaLCBmYWxsYmFjayB0byBZKVxuICAgICAgICAgICAgICAuYXBwbHlBeGlzQW5nbGUodkxpbmUubm9ybWFsaXplKCksIGN1cnZlUm90YXRpb24pIC8vIHJvdGF0ZSBhbG9uZyBsaW5lIGF4aXMgYWNjb3JkaW5nIHRvIGxpbmtDdXJ2ZVJvdGF0aW9uXG4gICAgICAgICAgICAgIC5hZGQobmV3IHRocmVlJDEuVmVjdG9yMygpLmFkZFZlY3RvcnModlN0YXJ0LCB2RW5kKS5kaXZpZGVTY2FsYXIoMikpO1xuICAgICAgICAgICAgICBjdXJ2ZSA9IG5ldyB0aHJlZSQxLlF1YWRyYXRpY0JlemllckN1cnZlMyh2U3RhcnQsIGNwLCB2RW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNhbWUgcG9pbnQsIGRyYXcgYSBsb29wXG4gICAgICAgICAgICAgIHZhciBkID0gY3VydmF0dXJlICogNzA7XG4gICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IC1jdXJ2ZVJvdGF0aW9uOyAvLyBSb3RhdGUgY2xvY2t3aXNlIChmcm9tIFogYW5nbGUgcGVyc3BlY3RpdmUpXG4gICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZW5kQW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgY3VydmUgPSBuZXcgdGhyZWUkMS5DdWJpY0JlemllckN1cnZlMyh2U3RhcnQsIG5ldyB0aHJlZSQxLlZlY3RvcjMoZCAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBkICogTWF0aC5zaW4oc3RhcnRBbmdsZSksIDApLmFkZCh2U3RhcnQpLCBuZXcgdGhyZWUkMS5WZWN0b3IzKGQgKiBNYXRoLmNvcyhlbmRBbmdsZSksIGQgKiBNYXRoLnNpbihlbmRBbmdsZSksIDApLmFkZCh2U3RhcnQpLCB2RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmsuX19jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlQXJyb3dzKCkge1xuICAgICAgICAvLyB1cGRhdGUgbGluayBhcnJvdyBwb3NpdGlvblxuICAgICAgICB2YXIgYXJyb3dSZWxQb3NBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MpO1xuICAgICAgICB2YXIgYXJyb3dMZW5ndGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgpO1xuICAgICAgICB2YXIgbm9kZVZhbEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmFsKTtcbiAgICAgICAgc3RhdGUuYXJyb3dEYXRhTWFwcGVyLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgICAgICAgIGxpbmsgPSBfcmVmNlswXSxcbiAgICAgICAgICAgIGFycm93T2JqID0gX3JlZjZbMV07XG4gICAgICAgICAgaWYgKCFhcnJvd09iaikgcmV0dXJuO1xuICAgICAgICAgIHZhciBwb3MgPSBpc0QzU2ltID8gbGluayA6IHN0YXRlLmxheW91dC5nZXRMaW5rUG9zaXRpb24oc3RhdGUubGF5b3V0LmdyYXBoLmdldExpbmsobGluay5zb3VyY2UsIGxpbmsudGFyZ2V0KS5pZCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zW2lzRDNTaW0gPyAnc291cmNlJyA6ICdmcm9tJ107XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc1tpc0QzU2ltID8gJ3RhcmdldCcgOiAndG8nXTtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgc3RhcnRSID0gTWF0aC5jYnJ0KE1hdGgubWF4KDAsIG5vZGVWYWxBY2Nlc3NvcihzdGFydCkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemU7XG4gICAgICAgICAgdmFyIGVuZFIgPSBNYXRoLmNicnQoTWF0aC5tYXgoMCwgbm9kZVZhbEFjY2Vzc29yKGVuZCkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemU7XG4gICAgICAgICAgdmFyIGFycm93TGVuZ3RoID0gYXJyb3dMZW5ndGhBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICB2YXIgYXJyb3dSZWxQb3MgPSBhcnJvd1JlbFBvc0FjY2Vzc29yKGxpbmspO1xuICAgICAgICAgIHZhciBnZXRQb3NBbG9uZ0xpbmUgPSBsaW5rLl9fY3VydmUgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuX19jdXJ2ZS5nZXRQb2ludCh0KTtcbiAgICAgICAgICB9IC8vIGludGVycG9sYXRlIGFsb25nIGJlemllciBjdXJ2ZVxuICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmU6IGludGVycG9sYXRlIGxpbmVhcmx5XG4gICAgICAgICAgICB2YXIgaXBsdCA9IGZ1bmN0aW9uIGlwbHQoZGltLCBzdGFydCwgZW5kLCB0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydFtkaW1dICsgKGVuZFtkaW1dIC0gc3RhcnRbZGltXSkgKiB0IHx8IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogaXBsdCgneCcsIHN0YXJ0LCBlbmQsIHQpLFxuICAgICAgICAgICAgICB5OiBpcGx0KCd5Jywgc3RhcnQsIGVuZCwgdCksXG4gICAgICAgICAgICAgIHo6IGlwbHQoJ3onLCBzdGFydCwgZW5kLCB0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBsaW5lTGVuID0gbGluay5fX2N1cnZlID8gbGluay5fX2N1cnZlLmdldExlbmd0aCgpIDogTWF0aC5zcXJ0KFsneCcsICd5JywgJ3onXS5tYXAoZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KChlbmRbZGltXSB8fCAwKSAtIChzdGFydFtkaW1dIHx8IDApLCAyKTtcbiAgICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdikge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHY7XG4gICAgICAgICAgfSwgMCkpO1xuICAgICAgICAgIHZhciBwb3NBbG9uZ0xpbmUgPSBzdGFydFIgKyBhcnJvd0xlbmd0aCArIChsaW5lTGVuIC0gc3RhcnRSIC0gZW5kUiAtIGFycm93TGVuZ3RoKSAqIGFycm93UmVsUG9zO1xuICAgICAgICAgIHZhciBhcnJvd0hlYWQgPSBnZXRQb3NBbG9uZ0xpbmUocG9zQWxvbmdMaW5lIC8gbGluZUxlbik7XG4gICAgICAgICAgdmFyIGFycm93VGFpbCA9IGdldFBvc0Fsb25nTGluZSgocG9zQWxvbmdMaW5lIC0gYXJyb3dMZW5ndGgpIC8gbGluZUxlbik7XG4gICAgICAgICAgWyd4JywgJ3knLCAneiddLmZvckVhY2goZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycm93T2JqLnBvc2l0aW9uW2RpbV0gPSBhcnJvd1RhaWxbZGltXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaGVhZFZlYyA9IF9jb25zdHJ1Y3QodGhyZWUkMS5WZWN0b3IzLCBfdG9Db25zdW1hYmxlQXJyYXkoWyd4JywgJ3knLCAneiddLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGFycm93SGVhZFtjXTtcbiAgICAgICAgICB9KSkpO1xuICAgICAgICAgIGFycm93T2JqLnBhcmVudC5sb2NhbFRvV29ybGQoaGVhZFZlYyk7IC8vIGxvb2tBdCByZXF1aXJlcyB3b3JsZCBjb29yZHNcbiAgICAgICAgICBhcnJvd09iai5sb29rQXQoaGVhZFZlYyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlUGhvdG9ucygpIHtcbiAgICAgICAgLy8gdXBkYXRlIGxpbmsgcGFydGljbGUgcG9zaXRpb25zXG4gICAgICAgIHZhciBwYXJ0aWNsZVNwZWVkQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBwaG90b25zT2JqID0gc3RhdGUucGFydGljbGVzRGF0YU1hcHBlci5nZXRPYmoobGluayk7XG4gICAgICAgICAgdmFyIGN5Y2xlUGhvdG9ucyA9IHBob3RvbnNPYmogJiYgcGhvdG9uc09iai5jaGlsZHJlbjtcbiAgICAgICAgICB2YXIgc2luZ2xlSG9wUGhvdG9ucyA9IGxpbmsuX19zaW5nbGVIb3BQaG90b25zT2JqICYmIGxpbmsuX19zaW5nbGVIb3BQaG90b25zT2JqLmNoaWxkcmVuO1xuICAgICAgICAgIGlmICgoIXNpbmdsZUhvcFBob3RvbnMgfHwgIXNpbmdsZUhvcFBob3RvbnMubGVuZ3RoKSAmJiAoIWN5Y2xlUGhvdG9ucyB8fCAhY3ljbGVQaG90b25zLmxlbmd0aCkpIHJldHVybjtcbiAgICAgICAgICB2YXIgcG9zID0gaXNEM1NpbSA/IGxpbmsgOiBzdGF0ZS5sYXlvdXQuZ2V0TGlua1Bvc2l0aW9uKHN0YXRlLmxheW91dC5ncmFwaC5nZXRMaW5rKGxpbmsuc291cmNlLCBsaW5rLnRhcmdldCkuaWQpO1xuICAgICAgICAgIHZhciBzdGFydCA9IHBvc1tpc0QzU2ltID8gJ3NvdXJjZScgOiAnZnJvbSddO1xuICAgICAgICAgIHZhciBlbmQgPSBwb3NbaXNEM1NpbSA/ICd0YXJnZXQnIDogJ3RvJ107XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIHBhcnRpY2xlU3BlZWQgPSBwYXJ0aWNsZVNwZWVkQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgdmFyIGdldFBob3RvblBvcyA9IGxpbmsuX19jdXJ2ZSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGluay5fX2N1cnZlLmdldFBvaW50KHQpO1xuICAgICAgICAgIH0gLy8gaW50ZXJwb2xhdGUgYWxvbmcgYmV6aWVyIGN1cnZlXG4gICAgICAgICAgOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgIHZhciBpcGx0ID0gZnVuY3Rpb24gaXBsdChkaW0sIHN0YXJ0LCBlbmQsIHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0W2RpbV0gKyAoZW5kW2RpbV0gLSBzdGFydFtkaW1dKSAqIHQgfHwgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiBpcGx0KCd4Jywgc3RhcnQsIGVuZCwgdCksXG4gICAgICAgICAgICAgIHk6IGlwbHQoJ3knLCBzdGFydCwgZW5kLCB0KSxcbiAgICAgICAgICAgICAgejogaXBsdCgneicsIHN0YXJ0LCBlbmQsIHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHBob3RvbnMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGN5Y2xlUGhvdG9ucyB8fCBbXSksIF90b0NvbnN1bWFibGVBcnJheShzaW5nbGVIb3BQaG90b25zIHx8IFtdKSk7XG4gICAgICAgICAgcGhvdG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwaG90b24sIGlkeCkge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUhvcCA9IHBob3Rvbi5wYXJlbnQuX19saW5rVGhyZWVPYmpUeXBlID09PSAnc2luZ2xlSG9wUGhvdG9ucyc7XG4gICAgICAgICAgICBpZiAoIXBob3Rvbi5oYXNPd25Qcm9wZXJ0eSgnX19wcm9ncmVzc1JhdGlvJykpIHtcbiAgICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA9IHNpbmdsZUhvcCA/IDAgOiBpZHggLyBjeWNsZVBob3RvbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyArPSBwYXJ0aWNsZVNwZWVkO1xuICAgICAgICAgICAgaWYgKHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPj0gMSkge1xuICAgICAgICAgICAgICBpZiAoIXNpbmdsZUhvcCkge1xuICAgICAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPSBwaG90b24uX19wcm9ncmVzc1JhdGlvICUgMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgcGFydGljbGVcbiAgICAgICAgICAgICAgICBwaG90b24ucGFyZW50LnJlbW92ZShwaG90b24pO1xuICAgICAgICAgICAgICAgIGVtcHR5T2JqZWN0KHBob3Rvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGhvdG9uUG9zUmF0aW8gPSBwaG90b24uX19wcm9ncmVzc1JhdGlvO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGdldFBob3RvblBvcyhwaG90b25Qb3NSYXRpbyk7XG4gICAgICAgICAgICBbJ3gnLCAneScsICd6J10uZm9yRWFjaChmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwaG90b24ucG9zaXRpb25bZGltXSA9IHBvc1tkaW1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdFBhcnRpY2xlOiBmdW5jdGlvbiBlbWl0UGFydGljbGUoc3RhdGUsIGxpbmspIHtcbiAgICAgIGlmIChsaW5rICYmIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICBpZiAoIWxpbmsuX19zaW5nbGVIb3BQaG90b25zT2JqKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG5ldyB0aHJlZSQxLkdyb3VwKCk7XG4gICAgICAgICAgb2JqLl9fbGlua1RocmVlT2JqVHlwZSA9ICdzaW5nbGVIb3BQaG90b25zJztcbiAgICAgICAgICBsaW5rLl9fc2luZ2xlSG9wUGhvdG9uc09iaiA9IG9iajtcbiAgICAgICAgICBzdGF0ZS5ncmFwaFNjZW5lLmFkZChvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0aWNsZVdpZHRoQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgpO1xuICAgICAgICB2YXIgcGhvdG9uUiA9IE1hdGguY2VpbChwYXJ0aWNsZVdpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMCAvIDI7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlUmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIHBhcnRpY2xlR2VvbWV0cnkgPSBuZXcgdGhyZWUkMS5TcGhlcmVHZW9tZXRyeShwaG90b25SLCBudW1TZWdtZW50cywgbnVtU2VnbWVudHMpO1xuICAgICAgICB2YXIgbGlua0NvbG9yQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICAgIHZhciBwYXJ0aWNsZUNvbG9yQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3IpO1xuICAgICAgICB2YXIgcGhvdG9uQ29sb3IgPSBwYXJ0aWNsZUNvbG9yQWNjZXNzb3IobGluaykgfHwgbGlua0NvbG9yQWNjZXNzb3IobGluaykgfHwgJyNmMGYwZjAnO1xuICAgICAgICB2YXIgbWF0ZXJpYWxDb2xvciA9IG5ldyB0aHJlZSQxLkNvbG9yKGNvbG9yU3RyMkhleChwaG90b25Db2xvcikpO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IHN0YXRlLmxpbmtPcGFjaXR5ICogMztcbiAgICAgICAgdmFyIHBhcnRpY2xlTWF0ZXJpYWwgPSBuZXcgdGhyZWUkMS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogbWF0ZXJpYWxDb2xvcixcbiAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBhIHNpbmdsZSBob3AgcGFydGljbGVcbiAgICAgICAgbGluay5fX3NpbmdsZUhvcFBob3RvbnNPYmouYWRkKG5ldyB0aHJlZSQxLk1lc2gocGFydGljbGVHZW9tZXRyeSwgcGFydGljbGVNYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRHcmFwaEJib3g6IGZ1bmN0aW9uIGdldEdyYXBoQmJveChzdGF0ZSkge1xuICAgICAgdmFyIG5vZGVGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgaWYgKCFzdGF0ZS5pbml0aWFsaXNlZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbGxlY3QgYWxsIG5lc3RlZCBnZW9tZXRyaWVzIGJib3hlc1xuICAgICAgdmFyIGJib3hlcyA9IGZ1bmN0aW9uIGdldEJib3hlcyhvYmopIHtcbiAgICAgICAgdmFyIGJib3hlcyA9IFtdO1xuICAgICAgICBpZiAob2JqLmdlb21ldHJ5KSB7XG4gICAgICAgICAgb2JqLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICAgIHZhciBib3ggPSBuZXcgdGhyZWUkMS5Cb3gzKCk7XG4gICAgICAgICAgYm94LmNvcHkob2JqLmdlb21ldHJ5LmJvdW5kaW5nQm94KS5hcHBseU1hdHJpeDQob2JqLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICBiYm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYm94ZXMuY29uY2F0LmFwcGx5KGJib3hlcywgX3RvQ29uc3VtYWJsZUFycmF5KChvYmouY2hpbGRyZW4gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuICFvYmouaGFzT3duUHJvcGVydHkoJ19fZ3JhcGhPYmpUeXBlJykgfHwgb2JqLl9fZ3JhcGhPYmpUeXBlID09PSAnbm9kZScgJiYgbm9kZUZpbHRlcihvYmouX19kYXRhKTtcbiAgICAgICAgfSAvLyBleGNsdWRlIGZpbHRlcmVkIG91dCBub2Rlc1xuICAgICAgICApLm1hcChnZXRCYm94ZXMpKSk7XG4gICAgICB9KHN0YXRlLmdyYXBoU2NlbmUpO1xuICAgICAgaWYgKCFiYm94ZXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gZXh0cmFjdCBnbG9iYWwgeCx5LHogbWluL21heFxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfdG9Db25zdW1hYmxlQXJyYXkoWyd4JywgJ3knLCAneiddLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBjLCBbbWluKGJib3hlcywgZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgICAgcmV0dXJuIGJiLm1pbltjXTtcbiAgICAgICAgfSksIG1heChiYm94ZXMsIGZ1bmN0aW9uIChiYikge1xuICAgICAgICAgIHJldHVybiBiYi5tYXhbY107XG4gICAgICAgIH0pXSk7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgfSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGQzRm9yY2VMYXlvdXQ6IGZvcmNlU2ltdWxhdGlvbigpLmZvcmNlKCdsaW5rJywgZm9yY2VMaW5rKCkpLmZvcmNlKCdjaGFyZ2UnLCBmb3JjZU1hbnlCb2R5KCkpLmZvcmNlKCdjZW50ZXInLCBmb3JjZUNlbnRlcigpKS5mb3JjZSgnZGFnUmFkaWFsJywgbnVsbCkuc3RvcCgpLFxuICAgICAgZW5naW5lUnVubmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRocmVlT2JqLCBzdGF0ZSkge1xuICAgIC8vIE1haW4gdGhyZWUgb2JqZWN0IHRvIG1hbmlwdWxhdGVcbiAgICBzdGF0ZS5ncmFwaFNjZW5lID0gdGhyZWVPYmo7XG4gICAgc3RhdGUubm9kZURhdGFNYXBwZXIgPSBuZXcgVGhyZWVEaWdlc3QodGhyZWVPYmosIHtcbiAgICAgIG9iakJpbmRBdHRyOiAnX190aHJlZU9iaidcbiAgICB9KTtcbiAgICBzdGF0ZS5saW5rRGF0YU1hcHBlciA9IG5ldyBUaHJlZURpZ2VzdCh0aHJlZU9iaiwge1xuICAgICAgb2JqQmluZEF0dHI6ICdfX2xpbmVPYmonXG4gICAgfSk7XG4gICAgc3RhdGUuYXJyb3dEYXRhTWFwcGVyID0gbmV3IFRocmVlRGlnZXN0KHRocmVlT2JqLCB7XG4gICAgICBvYmpCaW5kQXR0cjogJ19fYXJyb3dPYmonXG4gICAgfSk7XG4gICAgc3RhdGUucGFydGljbGVzRGF0YU1hcHBlciA9IG5ldyBUaHJlZURpZ2VzdCh0aHJlZU9iaiwge1xuICAgICAgb2JqQmluZEF0dHI6ICdfX3Bob3RvbnNPYmonXG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHN0YXRlLCBjaGFuZ2VkUHJvcHMpIHtcbiAgICB2YXIgaGFzQW55UHJvcENoYW5nZWQgPSBmdW5jdGlvbiBoYXNBbnlQcm9wQ2hhbmdlZChwcm9wTGlzdCkge1xuICAgICAgcmV0dXJuIHByb3BMaXN0LnNvbWUoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBwYXVzZSBzaW11bGF0aW9uXG4gICAgdHlwZW9mIHN0YXRlLm9uVXBkYXRlID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUub25VcGRhdGUoKTtcbiAgICBpZiAoc3RhdGUubm9kZUF1dG9Db2xvckJ5ICE9PSBudWxsICYmIGhhc0FueVByb3BDaGFuZ2VkKFsnbm9kZUF1dG9Db2xvckJ5JywgJ2dyYXBoRGF0YScsICdub2RlQ29sb3InXSkpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBub2Rlc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubm9kZXMsIGFjY2Vzc29yRm4oc3RhdGUubm9kZUF1dG9Db2xvckJ5KSwgc3RhdGUubm9kZUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSAhPT0gbnVsbCAmJiBoYXNBbnlQcm9wQ2hhbmdlZChbJ2xpbmtBdXRvQ29sb3JCeScsICdncmFwaERhdGEnLCAnbGlua0NvbG9yJ10pKSB7XG4gICAgICAvLyBBdXRvIGFkZCBjb2xvciB0byB1bmNvbG9yZWQgbGlua3NcbiAgICAgIGF1dG9Db2xvck9iamVjdHMoc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLCBhY2Nlc3NvckZuKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSksIHN0YXRlLmxpbmtDb2xvcik7XG4gICAgfVxuXG4gICAgLy8gRGlnZXN0IG5vZGVzIFdlYkdMIG9iamVjdHNcbiAgICBpZiAoc3RhdGUuX2ZsdXNoT2JqZWN0cyB8fCBoYXNBbnlQcm9wQ2hhbmdlZChbJ2dyYXBoRGF0YScsICdub2RlVGhyZWVPYmplY3QnLCAnbm9kZVRocmVlT2JqZWN0RXh0ZW5kJywgJ25vZGVWYWwnLCAnbm9kZUNvbG9yJywgJ25vZGVWaXNpYmlsaXR5JywgJ25vZGVSZWxTaXplJywgJ25vZGVSZXNvbHV0aW9uJywgJ25vZGVPcGFjaXR5J10pKSB7XG4gICAgICB2YXIgY3VzdG9tT2JqZWN0QWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVUaHJlZU9iamVjdCk7XG4gICAgICB2YXIgY3VzdG9tT2JqZWN0RXh0ZW5kQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVUaHJlZU9iamVjdEV4dGVuZCk7XG4gICAgICB2YXIgdmFsQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgdmFyIGNvbG9yQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVDb2xvcik7XG4gICAgICB2YXIgdmlzaWJpbGl0eUFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmlzaWJpbGl0eSk7XG4gICAgICB2YXIgc3BoZXJlR2VvbWV0cmllcyA9IHt9OyAvLyBpbmRleGVkIGJ5IG5vZGUgdmFsdWVcbiAgICAgIHZhciBzcGhlcmVNYXRlcmlhbHMgPSB7fTsgLy8gaW5kZXhlZCBieSBjb2xvclxuXG4gICAgICBpZiAoc3RhdGUuX2ZsdXNoT2JqZWN0cyB8fCBoYXNBbnlQcm9wQ2hhbmdlZChbXG4gICAgICAvLyByZWNyZWF0ZSBvYmplY3RzIGlmIGFueSBvZiB0aGVzZSBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgICdub2RlVGhyZWVPYmplY3QnLCAnbm9kZVRocmVlT2JqZWN0RXh0ZW5kJ10pKSBzdGF0ZS5ub2RlRGF0YU1hcHBlci5jbGVhcigpO1xuICAgICAgc3RhdGUubm9kZURhdGFNYXBwZXIub25DcmVhdGVPYmooZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1c3RvbU9iaiA9IGN1c3RvbU9iamVjdEFjY2Vzc29yKG5vZGUpO1xuICAgICAgICB2YXIgZXh0ZW5kT2JqID0gY3VzdG9tT2JqZWN0RXh0ZW5kQWNjZXNzb3Iobm9kZSk7XG4gICAgICAgIGlmIChjdXN0b21PYmogJiYgc3RhdGUubm9kZVRocmVlT2JqZWN0ID09PSBjdXN0b21PYmopIHtcbiAgICAgICAgICAvLyBjbG9uZSBvYmplY3QgaWYgaXQncyBhIHNoYXJlZCBvYmplY3QgYW1vbmcgYWxsIG5vZGVzXG4gICAgICAgICAgY3VzdG9tT2JqID0gY3VzdG9tT2JqLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgaWYgKGN1c3RvbU9iaiAmJiAhZXh0ZW5kT2JqKSB7XG4gICAgICAgICAgb2JqID0gY3VzdG9tT2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkZCBkZWZhdWx0IG9iamVjdCAoc3BoZXJlIG1lc2gpXG4gICAgICAgICAgb2JqID0gbmV3IHRocmVlJDEuTWVzaCgpO1xuICAgICAgICAgIG9iai5fX2dyYXBoRGVmYXVsdE9iaiA9IHRydWU7XG4gICAgICAgICAgaWYgKGN1c3RvbU9iaiAmJiBleHRlbmRPYmopIHtcbiAgICAgICAgICAgIG9iai5hZGQoY3VzdG9tT2JqKTsgLy8gZXh0ZW5kIGRlZmF1bHQgd2l0aCBjdXN0b21cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLl9fZ3JhcGhPYmpUeXBlID0gJ25vZGUnOyAvLyBBZGQgb2JqZWN0IHR5cGVcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSkub25VcGRhdGVPYmooZnVuY3Rpb24gKG9iaiwgbm9kZSkge1xuICAgICAgICBpZiAob2JqLl9fZ3JhcGhEZWZhdWx0T2JqKSB7XG4gICAgICAgICAgLy8gYnlwYXNzIGludGVybmFsIHVwZGF0ZXMgZm9yIGN1c3RvbSBub2RlIG9iamVjdHNcbiAgICAgICAgICB2YXIgdmFsID0gdmFsQWNjZXNzb3Iobm9kZSkgfHwgMTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5jYnJ0KHZhbCkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzdGF0ZS5ub2RlUmVzb2x1dGlvbjtcbiAgICAgICAgICBpZiAoIW9iai5nZW9tZXRyeS50eXBlLm1hdGNoKC9eU3BoZXJlKEJ1ZmZlcik/R2VvbWV0cnkkLykgfHwgb2JqLmdlb21ldHJ5LnBhcmFtZXRlcnMucmFkaXVzICE9PSByYWRpdXMgfHwgb2JqLmdlb21ldHJ5LnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyAhPT0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgIGlmICghc3BoZXJlR2VvbWV0cmllcy5oYXNPd25Qcm9wZXJ0eSh2YWwpKSB7XG4gICAgICAgICAgICAgIHNwaGVyZUdlb21ldHJpZXNbdmFsXSA9IG5ldyB0aHJlZSQxLlNwaGVyZUdlb21ldHJ5KHJhZGl1cywgbnVtU2VnbWVudHMsIG51bVNlZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBvYmouZ2VvbWV0cnkgPSBzcGhlcmVHZW9tZXRyaWVzW3ZhbF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yQWNjZXNzb3Iobm9kZSk7XG4gICAgICAgICAgdmFyIG1hdGVyaWFsQ29sb3IgPSBuZXcgdGhyZWUkMS5Db2xvcihjb2xvclN0cjJIZXgoY29sb3IgfHwgJyNmZmZmYWEnKSk7XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBzdGF0ZS5ub2RlT3BhY2l0eSAqIGNvbG9yQWxwaGEoY29sb3IpO1xuICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnIHx8ICFvYmoubWF0ZXJpYWwuY29sb3IuZXF1YWxzKG1hdGVyaWFsQ29sb3IpIHx8IG9iai5tYXRlcmlhbC5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG4gICAgICAgICAgICBpZiAoIXNwaGVyZU1hdGVyaWFscy5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHtcbiAgICAgICAgICAgICAgc3BoZXJlTWF0ZXJpYWxzW2NvbG9yXSA9IG5ldyB0aHJlZSQxLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiBtYXRlcmlhbENvbG9yLFxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmoubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgb2JqLm1hdGVyaWFsID0gc3BoZXJlTWF0ZXJpYWxzW2NvbG9yXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmRpZ2VzdChzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKHZpc2liaWxpdHlBY2Nlc3NvcikpO1xuICAgIH1cblxuICAgIC8vIERpZ2VzdCBsaW5rcyBXZWJHTCBvYmplY3RzXG4gICAgaWYgKHN0YXRlLl9mbHVzaE9iamVjdHMgfHwgaGFzQW55UHJvcENoYW5nZWQoWydncmFwaERhdGEnLCAnbGlua1RocmVlT2JqZWN0JywgJ2xpbmtUaHJlZU9iamVjdEV4dGVuZCcsICdsaW5rTWF0ZXJpYWwnLCAnbGlua0NvbG9yJywgJ2xpbmtXaWR0aCcsICdsaW5rVmlzaWJpbGl0eScsICdsaW5rUmVzb2x1dGlvbicsICdsaW5rT3BhY2l0eScsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCcsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbicsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlUmVzb2x1dGlvbiddKSkge1xuICAgICAgdmFyIF9jdXN0b21PYmplY3RBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1RocmVlT2JqZWN0KTtcbiAgICAgIHZhciBfY3VzdG9tT2JqZWN0RXh0ZW5kQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtUaHJlZU9iamVjdEV4dGVuZCk7XG4gICAgICB2YXIgY3VzdG9tTWF0ZXJpYWxBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua01hdGVyaWFsKTtcbiAgICAgIHZhciBfdmlzaWJpbGl0eUFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICB2YXIgX2NvbG9yQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICB2YXIgd2lkdGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1dpZHRoKTtcbiAgICAgIHZhciBjeWxpbmRlckdlb21ldHJpZXMgPSB7fTsgLy8gaW5kZXhlZCBieSBsaW5rIHdpZHRoXG4gICAgICB2YXIgbGFtYmVydExpbmVNYXRlcmlhbHMgPSB7fTsgLy8gZm9yIGN5bGluZGVyIG9iamVjdHMsIGluZGV4ZWQgYnkgbGluayBjb2xvclxuICAgICAgdmFyIGJhc2ljTGluZU1hdGVyaWFscyA9IHt9OyAvLyBmb3IgbGluZSBvYmplY3RzLCBpbmRleGVkIGJ5IGxpbmsgY29sb3JcblxuICAgICAgdmFyIHZpc2libGVMaW5rcyA9IHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoX3Zpc2liaWxpdHlBY2Nlc3Nvcik7XG5cbiAgICAgIC8vIGxpbmVzIGRpZ2VzdCBjeWNsZVxuICAgICAgaWYgKHN0YXRlLl9mbHVzaE9iamVjdHMgfHwgaGFzQW55UHJvcENoYW5nZWQoW1xuICAgICAgLy8gcmVjcmVhdGUgb2JqZWN0cyBpZiBhbnkgb2YgdGhlc2UgcHJvcHMgaGF2ZSBjaGFuZ2VkXG4gICAgICAnbGlua1RocmVlT2JqZWN0JywgJ2xpbmtUaHJlZU9iamVjdEV4dGVuZCcsICdsaW5rV2lkdGgnXSkpIHN0YXRlLmxpbmtEYXRhTWFwcGVyLmNsZWFyKCk7XG4gICAgICBzdGF0ZS5saW5rRGF0YU1hcHBlci5vblJlbW92ZU9iaihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzaW5nbGUgcGhvdG9uc1xuICAgICAgICB2YXIgc2luZ2xlUGhvdG9uc09iaiA9IG9iai5fX2RhdGEgJiYgb2JqLl9fZGF0YS5fX3NpbmdsZUhvcFBob3RvbnNPYmo7XG4gICAgICAgIGlmIChzaW5nbGVQaG90b25zT2JqKSB7XG4gICAgICAgICAgc2luZ2xlUGhvdG9uc09iai5wYXJlbnQucmVtb3ZlKHNpbmdsZVBob3RvbnNPYmopO1xuICAgICAgICAgIGVtcHR5T2JqZWN0KHNpbmdsZVBob3RvbnNPYmopO1xuICAgICAgICAgIGRlbGV0ZSBvYmouX19kYXRhLl9fc2luZ2xlSG9wUGhvdG9uc09iajtcbiAgICAgICAgfVxuICAgICAgfSkub25DcmVhdGVPYmooZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgdmFyIGN1c3RvbU9iaiA9IF9jdXN0b21PYmplY3RBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgdmFyIGV4dGVuZE9iaiA9IF9jdXN0b21PYmplY3RFeHRlbmRBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgaWYgKGN1c3RvbU9iaiAmJiBzdGF0ZS5saW5rVGhyZWVPYmplY3QgPT09IGN1c3RvbU9iaikge1xuICAgICAgICAgIC8vIGNsb25lIG9iamVjdCBpZiBpdCdzIGEgc2hhcmVkIG9iamVjdCBhbW9uZyBhbGwgbGlua3NcbiAgICAgICAgICBjdXN0b21PYmogPSBjdXN0b21PYmouY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdE9iajtcbiAgICAgICAgaWYgKCFjdXN0b21PYmogfHwgZXh0ZW5kT2JqKSB7XG4gICAgICAgICAgLy8gY29uc3RydWN0IGRlZmF1bHQgbGluZSBvYmpcbiAgICAgICAgICB2YXIgdXNlQ3lsaW5kZXIgPSAhIXdpZHRoQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgaWYgKHVzZUN5bGluZGVyKSB7XG4gICAgICAgICAgICBkZWZhdWx0T2JqID0gbmV3IHRocmVlJDEuTWVzaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgcGxhaW4gbGluZSAoY29uc3RhbnQgd2lkdGgpXG4gICAgICAgICAgICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IHRocmVlJDEuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGxpbmVHZW9tZXRyeVtzZXRBdHRyaWJ1dGVGbl0oJ3Bvc2l0aW9uJywgbmV3IHRocmVlJDEuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoMiAqIDMpLCAzKSk7XG4gICAgICAgICAgICBkZWZhdWx0T2JqID0gbmV3IHRocmVlJDEuTGluZShsaW5lR2VvbWV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqO1xuICAgICAgICBpZiAoIWN1c3RvbU9iaikge1xuICAgICAgICAgIG9iaiA9IGRlZmF1bHRPYmo7XG4gICAgICAgICAgb2JqLl9fZ3JhcGhEZWZhdWx0T2JqID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWV4dGVuZE9iaikge1xuICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSBvYmplY3RcbiAgICAgICAgICAgIG9iaiA9IGN1c3RvbU9iajtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXh0ZW5kIGRlZmF1bHQgd2l0aCBjdXN0b20gaW4gYSBncm91cFxuICAgICAgICAgICAgb2JqID0gbmV3IHRocmVlJDEuR3JvdXAoKTtcbiAgICAgICAgICAgIG9iai5fX2dyYXBoRGVmYXVsdE9iaiA9IHRydWU7XG4gICAgICAgICAgICBvYmouYWRkKGRlZmF1bHRPYmopO1xuICAgICAgICAgICAgb2JqLmFkZChjdXN0b21PYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmoucmVuZGVyT3JkZXIgPSAxMDsgLy8gUHJldmVudCB2aXN1YWwgZ2xpdGNoZXMgb2YgZGFyayBsaW5lcyBvbiB0b3Agb2Ygbm9kZXMgYnkgcmVuZGVyaW5nIHRoZW0gbGFzdFxuXG4gICAgICAgIG9iai5fX2dyYXBoT2JqVHlwZSA9ICdsaW5rJzsgLy8gQWRkIG9iamVjdCB0eXBlXG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0pLm9uVXBkYXRlT2JqKGZ1bmN0aW9uICh1cGRPYmosIGxpbmspIHtcbiAgICAgICAgaWYgKHVwZE9iai5fX2dyYXBoRGVmYXVsdE9iaikge1xuICAgICAgICAgIC8vIGJ5cGFzcyBpbnRlcm5hbCB1cGRhdGVzIGZvciBjdXN0b20gbGluayBvYmplY3RzXG4gICAgICAgICAgLy8gc2VsZWN0IGRlZmF1bHQgb2JqZWN0IGlmIGl0J3MgYW4gZXh0ZW5kZWQgZ3JvdXBcbiAgICAgICAgICB2YXIgb2JqID0gdXBkT2JqLmNoaWxkcmVuLmxlbmd0aCA/IHVwZE9iai5jaGlsZHJlblswXSA6IHVwZE9iajtcbiAgICAgICAgICB2YXIgbGlua1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMDtcbiAgICAgICAgICB2YXIgdXNlQ3lsaW5kZXIgPSAhIWxpbmtXaWR0aDtcbiAgICAgICAgICBpZiAodXNlQ3lsaW5kZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gbGlua1dpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciBudW1TZWdtZW50cyA9IHN0YXRlLmxpbmtSZXNvbHV0aW9uO1xuICAgICAgICAgICAgaWYgKCFvYmouZ2VvbWV0cnkudHlwZS5tYXRjaCgvXkN5bGluZGVyKEJ1ZmZlcik/R2VvbWV0cnkkLykgfHwgb2JqLmdlb21ldHJ5LnBhcmFtZXRlcnMucmFkaXVzVG9wICE9PSByIHx8IG9iai5nZW9tZXRyeS5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzICE9PSBudW1TZWdtZW50cykge1xuICAgICAgICAgICAgICBpZiAoIWN5bGluZGVyR2VvbWV0cmllcy5oYXNPd25Qcm9wZXJ0eShsaW5rV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IHRocmVlJDEuQ3lsaW5kZXJHZW9tZXRyeShyLCByLCAxLCBudW1TZWdtZW50cywgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5W2FwcGx5TWF0cml4NEZuXShuZXcgdGhyZWUkMS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKDAsIDEgLyAyLCAwKSk7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlbYXBwbHlNYXRyaXg0Rm5dKG5ldyB0aHJlZSQxLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKE1hdGguUEkgLyAyKSk7XG4gICAgICAgICAgICAgICAgY3lsaW5kZXJHZW9tZXRyaWVzW2xpbmtXaWR0aF0gPSBnZW9tZXRyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvYmouZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICBvYmouZ2VvbWV0cnkgPSBjeWxpbmRlckdlb21ldHJpZXNbbGlua1dpZHRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1c3RvbU1hdGVyaWFsID0gY3VzdG9tTWF0ZXJpYWxBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICBpZiAoY3VzdG9tTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIG9iai5tYXRlcmlhbCA9IGN1c3RvbU1hdGVyaWFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfY29sb3JBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbENvbG9yID0gbmV3IHRocmVlJDEuQ29sb3IoY29sb3JTdHIySGV4KGNvbG9yIHx8ICcjZjBmMGYwJykpO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBzdGF0ZS5saW5rT3BhY2l0eSAqIGNvbG9yQWxwaGEoY29sb3IpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsVHlwZSA9IHVzZUN5bGluZGVyID8gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnIDogJ0xpbmVCYXNpY01hdGVyaWFsJztcbiAgICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwudHlwZSAhPT0gbWF0ZXJpYWxUeXBlIHx8ICFvYmoubWF0ZXJpYWwuY29sb3IuZXF1YWxzKG1hdGVyaWFsQ29sb3IpIHx8IG9iai5tYXRlcmlhbC5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lTWF0ZXJpYWxzID0gdXNlQ3lsaW5kZXIgPyBsYW1iZXJ0TGluZU1hdGVyaWFscyA6IGJhc2ljTGluZU1hdGVyaWFscztcbiAgICAgICAgICAgICAgaWYgKCFsaW5lTWF0ZXJpYWxzLmhhc093blByb3BlcnR5KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGxpbmVNYXRlcmlhbHNbY29sb3JdID0gbmV3IHRocmVlJDFbbWF0ZXJpYWxUeXBlXSh7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogbWF0ZXJpYWxDb2xvcixcbiAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiBvcGFjaXR5IDwgMSxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICBkZXB0aFdyaXRlOiBvcGFjaXR5ID49IDEgLy8gUHJldmVudCB0cmFuc3BhcmVuY3kgaXNzdWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsID0gbGluZU1hdGVyaWFsc1tjb2xvcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5kaWdlc3QodmlzaWJsZUxpbmtzKTtcblxuICAgICAgLy8gQXJyb3dzIGRpZ2VzdCBjeWNsZVxuICAgICAgaWYgKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoIHx8IGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgnKSkge1xuICAgICAgICB2YXIgYXJyb3dMZW5ndGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgpO1xuICAgICAgICB2YXIgYXJyb3dDb2xvckFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yKTtcbiAgICAgICAgc3RhdGUuYXJyb3dEYXRhTWFwcGVyLm9uQ3JlYXRlT2JqKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb2JqID0gbmV3IHRocmVlJDEuTWVzaCh1bmRlZmluZWQsIG5ldyB0aHJlZSQxLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgb2JqLl9fbGlua1RocmVlT2JqVHlwZSA9ICdhcnJvdyc7IC8vIEFkZCBvYmplY3QgdHlwZVxuXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSkub25VcGRhdGVPYmooZnVuY3Rpb24gKG9iaiwgbGluaykge1xuICAgICAgICAgIHZhciBhcnJvd0xlbmd0aCA9IGFycm93TGVuZ3RoQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dSZXNvbHV0aW9uO1xuICAgICAgICAgIGlmICghb2JqLmdlb21ldHJ5LnR5cGUubWF0Y2goL15Db25lKEJ1ZmZlcik/R2VvbWV0cnkkLykgfHwgb2JqLmdlb21ldHJ5LnBhcmFtZXRlcnMuaGVpZ2h0ICE9PSBhcnJvd0xlbmd0aCB8fCBvYmouZ2VvbWV0cnkucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyAhPT0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBjb25lR2VvbWV0cnkgPSBuZXcgdGhyZWUkMS5Db25lR2VvbWV0cnkoYXJyb3dMZW5ndGggKiAwLjI1LCBhcnJvd0xlbmd0aCwgbnVtU2VnbWVudHMpO1xuICAgICAgICAgICAgLy8gQ29ycmVjdCBvcmllbnRhdGlvblxuICAgICAgICAgICAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSgwLCBhcnJvd0xlbmd0aCAvIDIsIDApO1xuICAgICAgICAgICAgY29uZUdlb21ldHJ5LnJvdGF0ZVgoTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgb2JqLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IGNvbmVHZW9tZXRyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFycm93Q29sb3IgPSBhcnJvd0NvbG9yQWNjZXNzb3IobGluaykgfHwgX2NvbG9yQWNjZXNzb3IobGluaykgfHwgJyNmMGYwZjAnO1xuICAgICAgICAgIG9iai5tYXRlcmlhbC5jb2xvciA9IG5ldyB0aHJlZSQxLkNvbG9yKGNvbG9yU3RyMkhleChhcnJvd0NvbG9yKSk7XG4gICAgICAgICAgb2JqLm1hdGVyaWFsLm9wYWNpdHkgPSBzdGF0ZS5saW5rT3BhY2l0eSAqIDMgKiBjb2xvckFscGhhKGFycm93Q29sb3IpO1xuICAgICAgICB9KS5kaWdlc3QodmlzaWJsZUxpbmtzLmZpbHRlcihhcnJvd0xlbmd0aEFjY2Vzc29yKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBob3RvbiBwYXJ0aWNsZXMgZGlnZXN0IGN5Y2xlXG4gICAgICBpZiAoc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVzIHx8IGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbGlua0RpcmVjdGlvbmFsUGFydGljbGVzJykpIHtcbiAgICAgICAgdmFyIHBhcnRpY2xlc0FjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMpO1xuICAgICAgICB2YXIgcGFydGljbGVXaWR0aEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoKTtcbiAgICAgICAgdmFyIHBhcnRpY2xlQ29sb3JBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcik7XG4gICAgICAgIHZhciBwYXJ0aWNsZU1hdGVyaWFscyA9IHt9OyAvLyBpbmRleGVkIGJ5IGxpbmsgY29sb3JcbiAgICAgICAgdmFyIHBhcnRpY2xlR2VvbWV0cmllcyA9IHt9OyAvLyBpbmRleGVkIGJ5IHBhcnRpY2xlIHdpZHRoXG5cbiAgICAgICAgc3RhdGUucGFydGljbGVzRGF0YU1hcHBlci5vbkNyZWF0ZU9iaihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG5ldyB0aHJlZSQxLkdyb3VwKCk7XG4gICAgICAgICAgb2JqLl9fbGlua1RocmVlT2JqVHlwZSA9ICdwaG90b25zJzsgLy8gQWRkIG9iamVjdCB0eXBlXG5cbiAgICAgICAgICBvYmouX19waG90b25EYXRhTWFwcGVyID0gbmV3IFRocmVlRGlnZXN0KG9iaik7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSkub25VcGRhdGVPYmooZnVuY3Rpb24gKG9iaiwgbGluaykge1xuICAgICAgICAgIHZhciBudW1QaG90b25zID0gTWF0aC5yb3VuZChNYXRoLmFicyhwYXJ0aWNsZXNBY2Nlc3NvcihsaW5rKSkpO1xuICAgICAgICAgIHZhciBjdXJQaG90b24gPSAhIW9iai5jaGlsZHJlbi5sZW5ndGggJiYgb2JqLmNoaWxkcmVuWzBdO1xuICAgICAgICAgIHZhciBwaG90b25SID0gTWF0aC5jZWlsKHBhcnRpY2xlV2lkdGhBY2Nlc3NvcihsaW5rKSAqIDEwKSAvIDEwIC8gMjtcbiAgICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb247XG4gICAgICAgICAgdmFyIHBhcnRpY2xlR2VvbWV0cnk7XG4gICAgICAgICAgaWYgKGN1clBob3RvbiAmJiBjdXJQaG90b24uZ2VvbWV0cnkucGFyYW1ldGVycy5yYWRpdXMgPT09IHBob3RvblIgJiYgY3VyUGhvdG9uLmdlb21ldHJ5LnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyA9PT0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlR2VvbWV0cnkgPSBjdXJQaG90b24uZ2VvbWV0cnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcGFydGljbGVHZW9tZXRyaWVzLmhhc093blByb3BlcnR5KHBob3RvblIpKSB7XG4gICAgICAgICAgICAgIHBhcnRpY2xlR2VvbWV0cmllc1twaG90b25SXSA9IG5ldyB0aHJlZSQxLlNwaGVyZUdlb21ldHJ5KHBob3RvblIsIG51bVNlZ21lbnRzLCBudW1TZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZUdlb21ldHJ5ID0gcGFydGljbGVHZW9tZXRyaWVzW3Bob3RvblJdO1xuICAgICAgICAgICAgY3VyUGhvdG9uICYmIGN1clBob3Rvbi5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwaG90b25Db2xvciA9IHBhcnRpY2xlQ29sb3JBY2Nlc3NvcihsaW5rKSB8fCBfY29sb3JBY2Nlc3NvcihsaW5rKSB8fCAnI2YwZjBmMCc7XG4gICAgICAgICAgdmFyIG1hdGVyaWFsQ29sb3IgPSBuZXcgdGhyZWUkMS5Db2xvcihjb2xvclN0cjJIZXgocGhvdG9uQ29sb3IpKTtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IHN0YXRlLmxpbmtPcGFjaXR5ICogMztcbiAgICAgICAgICB2YXIgcGFydGljbGVNYXRlcmlhbDtcbiAgICAgICAgICBpZiAoY3VyUGhvdG9uICYmIGN1clBob3Rvbi5tYXRlcmlhbC5jb2xvci5lcXVhbHMobWF0ZXJpYWxDb2xvcikgJiYgY3VyUGhvdG9uLm1hdGVyaWFsLm9wYWNpdHkgPT09IG9wYWNpdHkpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlTWF0ZXJpYWwgPSBjdXJQaG90b24ubWF0ZXJpYWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcGFydGljbGVNYXRlcmlhbHMuaGFzT3duUHJvcGVydHkocGhvdG9uQ29sb3IpKSB7XG4gICAgICAgICAgICAgIHBhcnRpY2xlTWF0ZXJpYWxzW3Bob3RvbkNvbG9yXSA9IG5ldyB0aHJlZSQxLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiBtYXRlcmlhbENvbG9yLFxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZU1hdGVyaWFsID0gcGFydGljbGVNYXRlcmlhbHNbcGhvdG9uQ29sb3JdO1xuICAgICAgICAgICAgY3VyUGhvdG9uICYmIGN1clBob3Rvbi5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGlnZXN0IGN5Y2xlIGZvciBlYWNoIHBob3RvblxuICAgICAgICAgIG9iai5fX3Bob3RvbkRhdGFNYXBwZXIuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkeDtcbiAgICAgICAgICB9KS5vbkNyZWF0ZU9iaihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRocmVlJDEuTWVzaChwYXJ0aWNsZUdlb21ldHJ5LCBwYXJ0aWNsZU1hdGVyaWFsKTtcbiAgICAgICAgICB9KS5vblVwZGF0ZU9iaihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYmouZ2VvbWV0cnkgPSBwYXJ0aWNsZUdlb21ldHJ5O1xuICAgICAgICAgICAgb2JqLm1hdGVyaWFsID0gcGFydGljbGVNYXRlcmlhbDtcbiAgICAgICAgICB9KS5kaWdlc3QoX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBBcnJheShudW1QaG90b25zKSkubWFwKGZ1bmN0aW9uIChfLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkeDogaWR4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkuZGlnZXN0KHZpc2libGVMaW5rcy5maWx0ZXIocGFydGljbGVzQWNjZXNzb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuX2ZsdXNoT2JqZWN0cyA9IGZhbHNlOyAvLyByZXNldCBvYmplY3RzIHJlZnJlc2ggZmxhZ1xuXG4gICAgLy8gc2ltdWxhdGlvbiBlbmdpbmVcbiAgICBpZiAoaGFzQW55UHJvcENoYW5nZWQoWydncmFwaERhdGEnLCAnbm9kZUlkJywgJ2xpbmtTb3VyY2UnLCAnbGlua1RhcmdldCcsICdudW1EaW1lbnNpb25zJywgJ2ZvcmNlRW5naW5lJywgJ2RhZ01vZGUnLCAnZGFnTm9kZUZpbHRlcicsICdkYWdMZXZlbERpc3RhbmNlJ10pKSB7XG4gICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cblxuICAgICAgLy8gcGFyc2UgbGlua3NcbiAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIGxpbmsuc291cmNlID0gbGlua1tzdGF0ZS5saW5rU291cmNlXTtcbiAgICAgICAgbGluay50YXJnZXQgPSBsaW5rW3N0YXRlLmxpbmtUYXJnZXRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZlZWQgZGF0YSB0byBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAgICAgIHZhciBpc0QzU2ltID0gc3RhdGUuZm9yY2VFbmdpbmUgIT09ICduZ3JhcGgnO1xuICAgICAgdmFyIGxheW91dDtcbiAgICAgIGlmIChpc0QzU2ltKSB7XG4gICAgICAgIC8vIEQzLWZvcmNlXG4gICAgICAgIChsYXlvdXQgPSBzdGF0ZS5kM0ZvcmNlTGF5b3V0KS5zdG9wKCkuYWxwaGEoMSkgLy8gcmUtaGVhdCB0aGUgc2ltdWxhdGlvblxuICAgICAgICAubnVtRGltZW5zaW9ucyhzdGF0ZS5udW1EaW1lbnNpb25zKS5ub2RlcyhzdGF0ZS5ncmFwaERhdGEubm9kZXMpO1xuXG4gICAgICAgIC8vIGFkZCBsaW5rcyAoaWYgbGluayBmb3JjZSBpcyBzdGlsbCBhY3RpdmUpXG4gICAgICAgIHZhciBsaW5rRm9yY2UgPSBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmZvcmNlKCdsaW5rJyk7XG4gICAgICAgIGlmIChsaW5rRm9yY2UpIHtcbiAgICAgICAgICBsaW5rRm9yY2UuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkW3N0YXRlLm5vZGVJZF07XG4gICAgICAgICAgfSkubGlua3Moc3RhdGUuZ3JhcGhEYXRhLmxpbmtzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGRhZyBmb3JjZSBjb25zdHJhaW50c1xuICAgICAgICB2YXIgbm9kZURlcHRocyA9IHN0YXRlLmRhZ01vZGUgJiYgZ2V0RGFnRGVwdGhzKHN0YXRlLmdyYXBoRGF0YSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtzdGF0ZS5ub2RlSWRdO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbm9kZUZpbHRlcjogc3RhdGUuZGFnTm9kZUZpbHRlcixcbiAgICAgICAgICBvbkxvb3BFcnJvcjogc3RhdGUub25EYWdFcnJvciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhEZXB0aCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKG5vZGVEZXB0aHMgfHwgW10pKSk7XG4gICAgICAgIHZhciBkYWdMZXZlbERpc3RhbmNlID0gc3RhdGUuZGFnTGV2ZWxEaXN0YW5jZSB8fCBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoIC8gKG1heERlcHRoIHx8IDEpICogREFHX0xFVkVMX05PREVfUkFUSU8gKiAoWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IDAuNyA6IDEpO1xuXG4gICAgICAgIC8vIFJlc2V0IHJlbGV2YW50IGYqIHdoZW4gc3dhcHBpbmcgZGFnIG1vZGVzXG4gICAgICAgIGlmIChbJ2xyJywgJ3JsJywgJ3RkJywgJ2J1JywgJ3ppbicsICd6b3V0J10uaW5jbHVkZXMoY2hhbmdlZFByb3BzLmRhZ01vZGUpKSB7XG4gICAgICAgICAgdmFyIHJlc2V0UHJvcCA9IFsnbHInLCAncmwnXS5pbmNsdWRlcyhjaGFuZ2VkUHJvcHMuZGFnTW9kZSkgPyAnZngnIDogWyd0ZCcsICdidSddLmluY2x1ZGVzKGNoYW5nZWRQcm9wcy5kYWdNb2RlKSA/ICdmeScgOiAnZnonO1xuICAgICAgICAgIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIoc3RhdGUuZGFnTm9kZUZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBub2RlW3Jlc2V0UHJvcF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXggbm9kZXMgdG8geCx5LHogZm9yIGRhZyBtb2RlXG4gICAgICAgIGlmIChbJ2xyJywgJ3JsJywgJ3RkJywgJ2J1JywgJ3ppbicsICd6b3V0J10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSkpIHtcbiAgICAgICAgICB2YXIgaW52ZXJ0ID0gWydybCcsICd0ZCcsICd6b3V0J10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSk7XG4gICAgICAgICAgdmFyIGZpeEZuID0gZnVuY3Rpb24gZml4Rm4obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChub2RlRGVwdGhzW25vZGVbc3RhdGUubm9kZUlkXV0gLSBtYXhEZXB0aCAvIDIpICogZGFnTGV2ZWxEaXN0YW5jZSAqIChpbnZlcnQgPyAtMSA6IDEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIF9yZXNldFByb3AgPSBbJ2xyJywgJ3JsJ10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSkgPyAnZngnIDogWyd0ZCcsICdidSddLmluY2x1ZGVzKHN0YXRlLmRhZ01vZGUpID8gJ2Z5JyA6ICdmeic7XG4gICAgICAgICAgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihzdGF0ZS5kYWdOb2RlRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtfcmVzZXRQcm9wXSA9IGZpeEZuKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHJhZGlhbCBmb3JjZSBmb3IgcmFkaWFsIGRhZ3NcbiAgICAgICAgc3RhdGUuZDNGb3JjZUxheW91dC5mb3JjZSgnZGFnUmFkaWFsJywgWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IGZvcmNlUmFkaWFsKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIG5vZGVEZXB0aCA9IG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSB8fCAtMTtcbiAgICAgICAgICByZXR1cm4gKHN0YXRlLmRhZ01vZGUgPT09ICdyYWRpYWxpbicgPyBtYXhEZXB0aCAtIG5vZGVEZXB0aCA6IG5vZGVEZXB0aCkgKiBkYWdMZXZlbERpc3RhbmNlO1xuICAgICAgICB9KS5zdHJlbmd0aChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5kYWdOb2RlRmlsdGVyKG5vZGUpID8gMSA6IDA7XG4gICAgICAgIH0pIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZ3JhcGhcbiAgICAgICAgdmFyIF9ncmFwaCA9IG5ncmFwaC5ncmFwaCgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIF9ncmFwaC5hZGROb2RlKG5vZGVbc3RhdGUubm9kZUlkXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIF9ncmFwaC5hZGRMaW5rKGxpbmsuc291cmNlLCBsaW5rLnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQgPSBuZ3JhcGguZm9yY2VsYXlvdXQoX2dyYXBoLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgZGltZW5zaW9uczogc3RhdGUubnVtRGltZW5zaW9uc1xuICAgICAgICB9LCBzdGF0ZS5uZ3JhcGhQaHlzaWNzKSk7XG4gICAgICAgIGxheW91dC5ncmFwaCA9IF9ncmFwaDsgLy8gQXR0YWNoIGdyYXBoIHJlZmVyZW5jZSB0byBsYXlvdXRcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUud2FybXVwVGlja3MgJiYgIShpc0QzU2ltICYmIHN0YXRlLmQzQWxwaGFNaW4gPiAwICYmIHN0YXRlLmQzRm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pOyBpKyspIHtcbiAgICAgICAgbGF5b3V0W2lzRDNTaW0gPyBcInRpY2tcIiA6IFwic3RlcFwiXSgpO1xuICAgICAgfSAvLyBJbml0aWFsIHRpY2tzIGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcblxuICAgICAgc3RhdGUubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgIH1cbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gdHJ1ZTsgLy8gcmVzdW1lIHNpbXVsYXRpb25cblxuICAgIHN0YXRlLm9uRmluaXNoVXBkYXRlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBmcm9tS2Fwc3VsZSAoa2Fwc3VsZSkge1xuICB2YXIgYmFzZUNsYXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBPYmplY3Q7XG4gIHZhciBpbml0S2Fwc3VsZVdpdGhTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIEZvcmNlR3JhcGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9iYXNlQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiBGb3JjZUdyYXBoKCkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlR3JhcGgpO1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRm9yY2VHcmFwaCwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIF90aGlzLl9fa2Fwc3VsZUluc3RhbmNlID0gX2NvbnN0cnVjdChrYXBzdWxlLCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGluaXRLYXBzdWxlV2l0aFNlbGYgPyBbX3RoaXNdIDogW10pLCBhcmdzKSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0cyhGb3JjZUdyYXBoLCBfYmFzZUNsYXNzKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZvcmNlR3JhcGgpO1xuICB9KGJhc2VDbGFzcyk7IC8vIGF0dGFjaCBrYXBzdWxlIHByb3BzL21ldGhvZHMgdG8gY2xhc3MgcHJvdG90eXBlXG4gIE9iamVjdC5rZXlzKGthcHN1bGUoKSkuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBGb3JjZUdyYXBoLnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRfX2thcHN1bGVJbnN0YW47XG4gICAgICB2YXIgcmV0dXJuVmFsID0gKF90aGlzJF9fa2Fwc3VsZUluc3RhbiA9IHRoaXMuX19rYXBzdWxlSW5zdGFuY2UpW21dLmFwcGx5KF90aGlzJF9fa2Fwc3VsZUluc3RhbiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiByZXR1cm5WYWwgPT09IHRoaXMuX19rYXBzdWxlSW5zdGFuY2UgPyB0aGlzIC8vIGNoYWluIGJhc2VkIG9uIHRoaXMgY2xhc3MsIG5vdCB0aGUga2Fwc3VsZSBvYmpcbiAgICAgIDogcmV0dXJuVmFsO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gRm9yY2VHcmFwaDtcbn1cblxudmFyIHRocmVlID0gd2luZG93LlRIUkVFID8gd2luZG93LlRIUkVFIDoge1xuICBHcm91cDogR3JvdXBcbn07IC8vIFByZWZlciBjb25zdW1wdGlvbiBmcm9tIGdsb2JhbCBUSFJFRSwgaWYgZXhpc3RzXG52YXIgdGhyZWVGb3JjZWdyYXBoID0gZnJvbUthcHN1bGUoRm9yY2VHcmFwaCwgdGhyZWUuR3JvdXAsIHRydWUpO1xuXG5leHBvcnQgeyB0aHJlZUZvcmNlZ3JhcGggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-forcegraph/dist/three-forcegraph.mjs\n");

/***/ })

};
;