/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ngraph.forcelayout";
exports.ids = ["vendor-chunks/ngraph.forcelayout"];
exports.modules = {

/***/ "(ssr)/./node_modules/ngraph.forcelayout/index.js":
/*!**************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = createLayout;\nmodule.exports.simulator = __webpack_require__(/*! ./lib/createPhysicsSimulator */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js\");\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"(ssr)/./node_modules/ngraph.events/index.js\");\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = (physicsSettings && physicsSettings.createSimulator) || __webpack_require__(/*! ./lib/createPhysicsSimulator */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js\");\n  var physicsSimulator = createSimulator(physicsSettings);\n  if (Array.isArray(physicsSettings)) throw new Error('Physics settings is expected to be an object');\n\n  var nodeMass = graph.version > 19 ? defaultSetNodeMass : defaultArrayNodeMass;\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass;\n  }\n\n  var nodeBodies = new Map();\n  var springs = {};\n  var bodiesCount = 0;\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var wasStable = false;\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; False otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function() {\n      if (bodiesCount === 0) {\n        updateStableStatus(true);\n        return true;\n      }\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n\n      var ratio = lastMove/bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n      updateStableStatus(isStableNow);\n\n\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is treated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is\n     */\n    getForceVectorLength: getForceVectorLength,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step operation\n     */\n    lastMove: 0\n  };\n\n  eventify(api);\n\n  return api;\n\n  function updateStableStatus(isStableNow) {\n    if (wasStable !== isStableNow) {\n      wasStable = isStableNow;\n      onStableChanged(isStableNow);\n    }\n  }\n\n  function forEachBody(cb) {\n    nodeBodies.forEach(cb);\n  }\n\n  function getForceVectorLength() {\n    var fx = 0, fy = 0;\n    forEachBody(function(body) {\n      fx += Math.abs(body.force.x);\n      fy += Math.abs(body.force.y);\n    });\n    return Math.sqrt(fx * fx + fy * fy);\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies.get(nodeId);\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n\n      nodeBodies.set(nodeId, body);\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies.get(nodeId);\n    if (body) {\n      nodeBodies.delete(nodeId);\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies.get(link.fromId),\n        toBody  = nodeBodies.get(link.toId),\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number');\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be marked\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies.get(nodeId);\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultArrayNodeMass(nodeId) {\n    // This function is for older versions of ngraph.graph.\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n\n  function defaultSetNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.size / 3.0;\n  }\n}\n\nfunction noop() { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsMkpBQWtFOztBQUVsRSxlQUFlLG1CQUFPLENBQUMsa0VBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGLG1CQUFPLENBQUMsMkdBQThCO0FBQ3RIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7O0FBR0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLGNBQWMsTUFBTTtBQUNyQyxpQkFBaUIsWUFBWSxNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVMsMENBQTBDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWljaGFcXERvd25sb2Fkc1xcem91YmtvZmZzaXRlXFxwZXJzb25hbHNpdGVcXG5vZGVfbW9kdWxlc1xcbmdyYXBoLmZvcmNlbGF5b3V0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxheW91dDtcbm1vZHVsZS5leHBvcnRzLnNpbXVsYXRvciA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZVBoeXNpY3NTaW11bGF0b3InKTtcblxudmFyIGV2ZW50aWZ5ID0gcmVxdWlyZSgnbmdyYXBoLmV2ZW50cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgZm9yY2UgYmFzZWQgbGF5b3V0IGZvciBhIGdpdmVuIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bmdyYXBoLmdyYXBofSBncmFwaCB3aGljaCBuZWVkcyB0byBiZSBsYWlkIG91dFxuICogQHBhcmFtIHtvYmplY3R9IHBoeXNpY3NTZXR0aW5ncyBpZiB5b3UgbmVlZCBjdXN0b20gc2V0dGluZ3NcbiAqIGZvciBwaHlzaWNzIHNpbXVsYXRvciB5b3UgY2FuIHBhc3MgeW91ciBvd24gc2V0dGluZ3MgaGVyZS4gSWYgaXQncyBub3QgcGFzc2VkXG4gKiBhIGRlZmF1bHQgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGF5b3V0KGdyYXBoLCBwaHlzaWNzU2V0dGluZ3MpIHtcbiAgaWYgKCFncmFwaCkge1xuICAgIHRocm93IG5ldyBFcnJvcignR3JhcGggc3RydWN0dXJlIGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciBjcmVhdGVTaW11bGF0b3IgPSAocGh5c2ljc1NldHRpbmdzICYmIHBoeXNpY3NTZXR0aW5ncy5jcmVhdGVTaW11bGF0b3IpIHx8IHJlcXVpcmUoJy4vbGliL2NyZWF0ZVBoeXNpY3NTaW11bGF0b3InKTtcbiAgdmFyIHBoeXNpY3NTaW11bGF0b3IgPSBjcmVhdGVTaW11bGF0b3IocGh5c2ljc1NldHRpbmdzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGh5c2ljc1NldHRpbmdzKSkgdGhyb3cgbmV3IEVycm9yKCdQaHlzaWNzIHNldHRpbmdzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCcpO1xuXG4gIHZhciBub2RlTWFzcyA9IGdyYXBoLnZlcnNpb24gPiAxOSA/IGRlZmF1bHRTZXROb2RlTWFzcyA6IGRlZmF1bHRBcnJheU5vZGVNYXNzO1xuICBpZiAocGh5c2ljc1NldHRpbmdzICYmIHR5cGVvZiBwaHlzaWNzU2V0dGluZ3Mubm9kZU1hc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlTWFzcyA9IHBoeXNpY3NTZXR0aW5ncy5ub2RlTWFzcztcbiAgfVxuXG4gIHZhciBub2RlQm9kaWVzID0gbmV3IE1hcCgpO1xuICB2YXIgc3ByaW5ncyA9IHt9O1xuICB2YXIgYm9kaWVzQ291bnQgPSAwO1xuXG4gIHZhciBzcHJpbmdUcmFuc2Zvcm0gPSBwaHlzaWNzU2ltdWxhdG9yLnNldHRpbmdzLnNwcmluZ1RyYW5zZm9ybSB8fCBub29wO1xuXG4gIC8vIEluaXRpYWxpemUgcGh5c2ljcyB3aXRoIHdoYXQgd2UgaGF2ZSBpbiB0aGUgZ3JhcGg6XG4gIGluaXRQaHlzaWNzKCk7XG4gIGxpc3RlblRvRXZlbnRzKCk7XG5cbiAgdmFyIHdhc1N0YWJsZSA9IGZhbHNlO1xuXG4gIHZhciBhcGkgPSB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgb25lIHN0ZXAgb2YgaXRlcmF0aXZlIGxheW91dCBhbGdvcml0aG1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBzeXN0ZW0gc2hvdWxkIGJlIGNvbnNpZGVyZWQgc3RhYmxlOyBGYWxzZSBvdGhlcndpc2UuXG4gICAgICogVGhlIHN5c3RlbSBpcyBzdGFibGUgaWYgbm8gZnVydGhlciBjYWxsIHRvIGBzdGVwKClgIGNhbiBpbXByb3ZlIHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgc3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYm9kaWVzQ291bnQgPT09IDApIHtcbiAgICAgICAgdXBkYXRlU3RhYmxlU3RhdHVzKHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RNb3ZlID0gcGh5c2ljc1NpbXVsYXRvci5zdGVwKCk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIG1vdmVtZW50IGluIGNhc2UgaWYgc29tZW9uZSB3YW50cyB0byBxdWVyeSBpdCBpbiB0aGUgc3RlcFxuICAgICAgLy8gY2FsbGJhY2suXG4gICAgICBhcGkubGFzdE1vdmUgPSBsYXN0TW92ZTtcblxuICAgICAgLy8gQWxsb3cgbGlzdGVuZXJzIHRvIHBlcmZvcm0gbG93LWxldmVsIGFjdGlvbnMgYWZ0ZXIgbm9kZXMgYXJlIHVwZGF0ZWQuXG4gICAgICBhcGkuZmlyZSgnc3RlcCcpO1xuXG4gICAgICB2YXIgcmF0aW8gPSBsYXN0TW92ZS9ib2RpZXNDb3VudDtcbiAgICAgIHZhciBpc1N0YWJsZU5vdyA9IHJhdGlvIDw9IDAuMDE7IC8vIFRPRE86IFRoZSBudW1iZXIgaXMgc29tZXdoYXQgYXJiaXRyYXJ5Li4uXG4gICAgICB1cGRhdGVTdGFibGVTdGF0dXMoaXNTdGFibGVOb3cpO1xuXG5cbiAgICAgIHJldHVybiBpc1N0YWJsZU5vdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gYG5vZGVJZGAgcmV0dXJucyBwb3NpdGlvblxuICAgICAqL1xuICAgIGdldE5vZGVQb3NpdGlvbjogZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgcmV0dXJuIGdldEluaXRpYWxpemVkQm9keShub2RlSWQpLnBvcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwb3NpdGlvbiBvZiBhIG5vZGUgdG8gYSBnaXZlbiBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWQgbm9kZSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggcG9zaXRpb24gb2YgYSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgcG9zaXRpb24gb2YgYSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB6IHBvc2l0aW9uIG9mIG5vZGUgKG9ubHkgaWYgYXBwbGljYWJsZSB0byBib2R5KVxuICAgICAqL1xuICAgIHNldE5vZGVQb3NpdGlvbjogZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgdmFyIGJvZHkgPSBnZXRJbml0aWFsaXplZEJvZHkobm9kZUlkKTtcbiAgICAgIGJvZHkuc2V0UG9zaXRpb24uYXBwbHkoYm9keSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IExpbmsgcG9zaXRpb24gYnkgbGluayBpZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuZnJvbX0ge3gsIHl9IGNvb3JkaW5hdGVzIG9mIGxpbmsgc3RhcnRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LnRvfSB7eCwgeX0gY29vcmRpbmF0ZXMgb2YgbGluayBlbmRcbiAgICAgKi9cbiAgICBnZXRMaW5rUG9zaXRpb246IGZ1bmN0aW9uIChsaW5rSWQpIHtcbiAgICAgIHZhciBzcHJpbmcgPSBzcHJpbmdzW2xpbmtJZF07XG4gICAgICBpZiAoc3ByaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogc3ByaW5nLmZyb20ucG9zLFxuICAgICAgICAgIHRvOiBzcHJpbmcudG8ucG9zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFyZWEgcmVxdWlyZWQgdG8gZml0IGluIHRoZSBncmFwaC4gT2JqZWN0IGNvbnRhaW5zXG4gICAgICogYHgxYCwgYHkxYCAtIHRvcCBsZWZ0IGNvb3JkaW5hdGVzXG4gICAgICogYHgyYCwgYHkyYCAtIGJvdHRvbSByaWdodCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGdldEdyYXBoUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBoeXNpY3NTaW11bGF0b3IuZ2V0QkJveCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVhY2ggYm9keSBpbiB0aGUgbGF5b3V0IHNpbXVsYXRvciBhbmQgcGVyZm9ybXMgYSBjYWxsYmFjayhib2R5LCBub2RlSWQpXG4gICAgICovXG4gICAgZm9yRWFjaEJvZHk6IGZvckVhY2hCb2R5LFxuXG4gICAgLypcbiAgICAgKiBSZXF1ZXN0cyBsYXlvdXQgYWxnb3JpdGhtIHRvIHBpbi91bnBpbiBub2RlIHRvIGl0cyBjdXJyZW50IHBvc2l0aW9uXG4gICAgICogUGlubmVkIG5vZGVzIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgbGF5b3V0IGFsZ29yaXRobSBhbmQgYWx3YXlzXG4gICAgICogcmVtYWluIGF0IHRoZWlyIHBvc2l0aW9uXG4gICAgICovXG4gICAgcGluTm9kZTogZnVuY3Rpb24gKG5vZGUsIGlzUGlubmVkKSB7XG4gICAgICB2YXIgYm9keSA9IGdldEluaXRpYWxpemVkQm9keShub2RlLmlkKTtcbiAgICAgICBib2R5LmlzUGlubmVkID0gISFpc1Bpbm5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gZ3JhcGgncyBub2RlIGlzIGN1cnJlbnRseSBwaW5uZWRcbiAgICAgKi9cbiAgICBpc05vZGVQaW5uZWQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gZ2V0SW5pdGlhbGl6ZWRCb2R5KG5vZGUuaWQpLmlzUGlubmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHJlbGVhc2UgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgZ3JhcGgub2ZmKCdjaGFuZ2VkJywgb25HcmFwaENoYW5nZWQpO1xuICAgICAgYXBpLmZpcmUoJ2Rpc3Bvc2VkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgcGh5c2ljYWwgYm9keSBmb3IgYSBnaXZlbiBub2RlIGlkLiBJZiBub2RlIGlzIG5vdCBmb3VuZCB1bmRlZmluZWRcbiAgICAgKiB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXRCb2R5OiBnZXRCb2R5LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzcHJpbmcgZm9yIGEgZ2l2ZW4gZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rSWQgbGluayBpZGVudGlmZXIuIElmIHR3byBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aGVuXG4gICAgICogdGhpcyBhcmd1bWVudCBpcyB0cmVhdGVkIGFzIGZvcm1Ob2RlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRvSWQgd2hlbiBkZWZpbmVkIHRoaXMgcGFyYW1ldGVyIGRlbm90ZXMgaGVhZCBvZiB0aGUgbGlua1xuICAgICAqIGFuZCBmaXJzdCBhcmd1bWVudCBpcyB0cmVhdGVkIGFzIHRhaWwgb2YgdGhlIGxpbmsgKGZyb21JZClcbiAgICAgKi9cbiAgICBnZXRTcHJpbmc6IGdldFNwcmluZyxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVuZ3RoIG9mIGN1bXVsYXRpdmUgZm9yY2UgdmVjdG9yLiBUaGUgY2xvc2VyIHRoaXMgdG8gemVybyAtIHRoZSBtb3JlIHN0YWJsZSB0aGUgc3lzdGVtIGlzXG4gICAgICovXG4gICAgZ2V0Rm9yY2VWZWN0b3JMZW5ndGg6IGdldEZvcmNlVmVjdG9yTGVuZ3RoLFxuXG4gICAgLyoqXG4gICAgICogW1JlYWQgb25seV0gR2V0cyBjdXJyZW50IHBoeXNpY3Mgc2ltdWxhdG9yXG4gICAgICovXG4gICAgc2ltdWxhdG9yOiBwaHlzaWNzU2ltdWxhdG9yLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ3JhcGggdGhhdCB3YXMgdXNlZCBmb3IgbGF5b3V0XG4gICAgICovXG4gICAgZ3JhcGg6IGdyYXBoLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbW91bnQgb2YgbW92ZW1lbnQgcGVyZm9ybWVkIGR1cmluZyBsYXN0IHN0ZXAgb3BlcmF0aW9uXG4gICAgICovXG4gICAgbGFzdE1vdmU6IDBcbiAgfTtcblxuICBldmVudGlmeShhcGkpO1xuXG4gIHJldHVybiBhcGk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU3RhYmxlU3RhdHVzKGlzU3RhYmxlTm93KSB7XG4gICAgaWYgKHdhc1N0YWJsZSAhPT0gaXNTdGFibGVOb3cpIHtcbiAgICAgIHdhc1N0YWJsZSA9IGlzU3RhYmxlTm93O1xuICAgICAgb25TdGFibGVDaGFuZ2VkKGlzU3RhYmxlTm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoQm9keShjYikge1xuICAgIG5vZGVCb2RpZXMuZm9yRWFjaChjYik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGb3JjZVZlY3Rvckxlbmd0aCgpIHtcbiAgICB2YXIgZnggPSAwLCBmeSA9IDA7XG4gICAgZm9yRWFjaEJvZHkoZnVuY3Rpb24oYm9keSkge1xuICAgICAgZnggKz0gTWF0aC5hYnMoYm9keS5mb3JjZS54KTtcbiAgICAgIGZ5ICs9IE1hdGguYWJzKGJvZHkuZm9yY2UueSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChmeCAqIGZ4ICsgZnkgKiBmeSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTcHJpbmcoZnJvbUlkLCB0b0lkKSB7XG4gICAgdmFyIGxpbmtJZDtcbiAgICBpZiAodG9JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gYXNzdW1lIGZyb21JZCBhcyBhIGxpbmtJZDpcbiAgICAgICAgbGlua0lkID0gZnJvbUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXNzdW1lIGZyb21JZCB0byBiZSBhIGxpbmsgb2JqZWN0OlxuICAgICAgICBsaW5rSWQgPSBmcm9tSWQuaWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvSWQgaXMgZGVmaW5lZCwgc2hvdWxkIGdyYWIgbGluazpcbiAgICAgIHZhciBsaW5rID0gZ3JhcGguaGFzTGluayhmcm9tSWQsIHRvSWQpO1xuICAgICAgaWYgKCFsaW5rKSByZXR1cm47XG4gICAgICBsaW5rSWQgPSBsaW5rLmlkO1xuICAgIH1cblxuICAgIHJldHVybiBzcHJpbmdzW2xpbmtJZF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb2R5KG5vZGVJZCkge1xuICAgIHJldHVybiBub2RlQm9kaWVzLmdldChub2RlSWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuVG9FdmVudHMoKSB7XG4gICAgZ3JhcGgub24oJ2NoYW5nZWQnLCBvbkdyYXBoQ2hhbmdlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblN0YWJsZUNoYW5nZWQoaXNTdGFibGUpIHtcbiAgICBhcGkuZmlyZSgnc3RhYmxlJywgaXNTdGFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25HcmFwaENoYW5nZWQoY2hhbmdlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICBpZiAoY2hhbmdlLmNoYW5nZVR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uubm9kZSkge1xuICAgICAgICAgIGluaXRCb2R5KGNoYW5nZS5ub2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLmxpbmspIHtcbiAgICAgICAgICBpbml0TGluayhjaGFuZ2UubGluayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLmNoYW5nZVR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uubm9kZSkge1xuICAgICAgICAgIHJlbGVhc2VOb2RlKGNoYW5nZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLmxpbmspIHtcbiAgICAgICAgICByZWxlYXNlTGluayhjaGFuZ2UubGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYm9kaWVzQ291bnQgPSBncmFwaC5nZXROb2Rlc0NvdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UGh5c2ljcygpIHtcbiAgICBib2RpZXNDb3VudCA9IDA7XG5cbiAgICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaW5pdEJvZHkobm9kZS5pZCk7XG4gICAgICBib2RpZXNDb3VudCArPSAxO1xuICAgIH0pO1xuXG4gICAgZ3JhcGguZm9yRWFjaExpbmsoaW5pdExpbmspO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEJvZHkobm9kZUlkKSB7XG4gICAgdmFyIGJvZHkgPSBub2RlQm9kaWVzLmdldChub2RlSWQpO1xuICAgIGlmICghYm9keSkge1xuICAgICAgdmFyIG5vZGUgPSBncmFwaC5nZXROb2RlKG5vZGVJZCk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0Qm9keSgpIHdhcyBjYWxsZWQgd2l0aCB1bmtub3duIG5vZGUgaWQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb247XG4gICAgICBpZiAoIXBvcykge1xuICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ2V0TmVpZ2hib3JCb2RpZXMobm9kZSk7XG4gICAgICAgIHBvcyA9IHBoeXNpY3NTaW11bGF0b3IuZ2V0QmVzdE5ld0JvZHlQb3NpdGlvbihuZWlnaGJvcnMpO1xuICAgICAgfVxuXG4gICAgICBib2R5ID0gcGh5c2ljc1NpbXVsYXRvci5hZGRCb2R5QXQocG9zKTtcbiAgICAgIGJvZHkuaWQgPSBub2RlSWQ7XG5cbiAgICAgIG5vZGVCb2RpZXMuc2V0KG5vZGVJZCwgYm9keSk7XG4gICAgICB1cGRhdGVCb2R5TWFzcyhub2RlSWQpO1xuXG4gICAgICBpZiAoaXNOb2RlT3JpZ2luYWxseVBpbm5lZChub2RlKSkge1xuICAgICAgICBib2R5LmlzUGlubmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlTm9kZShub2RlKSB7XG4gICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgdmFyIGJvZHkgPSBub2RlQm9kaWVzLmdldChub2RlSWQpO1xuICAgIGlmIChib2R5KSB7XG4gICAgICBub2RlQm9kaWVzLmRlbGV0ZShub2RlSWQpO1xuICAgICAgcGh5c2ljc1NpbXVsYXRvci5yZW1vdmVCb2R5KGJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRMaW5rKGxpbmspIHtcbiAgICB1cGRhdGVCb2R5TWFzcyhsaW5rLmZyb21JZCk7XG4gICAgdXBkYXRlQm9keU1hc3MobGluay50b0lkKTtcblxuICAgIHZhciBmcm9tQm9keSA9IG5vZGVCb2RpZXMuZ2V0KGxpbmsuZnJvbUlkKSxcbiAgICAgICAgdG9Cb2R5ICA9IG5vZGVCb2RpZXMuZ2V0KGxpbmsudG9JZCksXG4gICAgICAgIHNwcmluZyA9IHBoeXNpY3NTaW11bGF0b3IuYWRkU3ByaW5nKGZyb21Cb2R5LCB0b0JvZHksIGxpbmsubGVuZ3RoKTtcblxuICAgIHNwcmluZ1RyYW5zZm9ybShsaW5rLCBzcHJpbmcpO1xuXG4gICAgc3ByaW5nc1tsaW5rLmlkXSA9IHNwcmluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2VMaW5rKGxpbmspIHtcbiAgICB2YXIgc3ByaW5nID0gc3ByaW5nc1tsaW5rLmlkXTtcbiAgICBpZiAoc3ByaW5nKSB7XG4gICAgICB2YXIgZnJvbSA9IGdyYXBoLmdldE5vZGUobGluay5mcm9tSWQpLFxuICAgICAgICAgIHRvID0gZ3JhcGguZ2V0Tm9kZShsaW5rLnRvSWQpO1xuXG4gICAgICBpZiAoZnJvbSkgdXBkYXRlQm9keU1hc3MoZnJvbS5pZCk7XG4gICAgICBpZiAodG8pIHVwZGF0ZUJvZHlNYXNzKHRvLmlkKTtcblxuICAgICAgZGVsZXRlIHNwcmluZ3NbbGluay5pZF07XG5cbiAgICAgIHBoeXNpY3NTaW11bGF0b3IucmVtb3ZlU3ByaW5nKHNwcmluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVpZ2hib3JCb2RpZXMobm9kZSkge1xuICAgIC8vIFRPRE86IENvdWxkIHByb2JhYmx5IGJlIGRvbmUgYmV0dGVyIG9uIG1lbW9yeVxuICAgIHZhciBuZWlnaGJvcnMgPSBbXTtcbiAgICBpZiAoIW5vZGUubGlua3MpIHtcbiAgICAgIHJldHVybiBuZWlnaGJvcnM7XG4gICAgfVxuICAgIHZhciBtYXhOZWlnaGJvcnMgPSBNYXRoLm1pbihub2RlLmxpbmtzLmxlbmd0aCwgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOZWlnaGJvcnM7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBub2RlLmxpbmtzW2ldO1xuICAgICAgdmFyIG90aGVyQm9keSA9IGxpbmsuZnJvbUlkICE9PSBub2RlLmlkID8gbm9kZUJvZGllcy5nZXQobGluay5mcm9tSWQpIDogbm9kZUJvZGllcy5nZXQobGluay50b0lkKTtcbiAgICAgIGlmIChvdGhlckJvZHkgJiYgb3RoZXJCb2R5LnBvcykge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChvdGhlckJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVCb2R5TWFzcyhub2RlSWQpIHtcbiAgICB2YXIgYm9keSA9IG5vZGVCb2RpZXMuZ2V0KG5vZGVJZCk7XG4gICAgYm9keS5tYXNzID0gbm9kZU1hc3Mobm9kZUlkKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGJvZHkubWFzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBtYXNzIHNob3VsZCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBncmFwaCBub2RlIGhhcyBpbiBpdHMgc2V0dGluZ3MgcGlubmVkIGF0dHJpYnV0ZSxcbiAgICogd2hpY2ggbWVhbnMgbGF5b3V0IGFsZ29yaXRobSBjYW5ub3QgbW92ZSBpdC4gTm9kZSBjYW4gYmUgbWFya2VkXG4gICAqIGFzIHBpbm5lZCwgaWYgaXQgaGFzIFwiaXNQaW5uZWRcIiBhdHRyaWJ1dGUsIG9yIHdoZW4gbm9kZS5kYXRhIGhhcyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgYSBncmFwaCBub2RlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgbm9kZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBwaW5uZWQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTm9kZU9yaWdpbmFsbHlQaW5uZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJiAobm9kZS5pc1Bpbm5lZCB8fCAobm9kZS5kYXRhICYmIG5vZGUuZGF0YS5pc1Bpbm5lZCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluaXRpYWxpemVkQm9keShub2RlSWQpIHtcbiAgICB2YXIgYm9keSA9IG5vZGVCb2RpZXMuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICBpbml0Qm9keShub2RlSWQpO1xuICAgICAgYm9keSA9IG5vZGVCb2RpZXMuZ2V0KG5vZGVJZCk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbWFzcyBvZiBhIGJvZHksIHdoaWNoIGNvcnJlc3BvbmRzIHRvIG5vZGUgd2l0aCBnaXZlbiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBub2RlSWQgaWRlbnRpZmllciBvZiBhIG5vZGUsIGZvciB3aGljaCBib2R5IG1hc3MgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZWNvbW1lbmRlZCBtYXNzIG9mIHRoZSBib2R5O1xuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdEFycmF5Tm9kZU1hc3Mobm9kZUlkKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgbmdyYXBoLmdyYXBoLlxuICAgIHZhciBsaW5rcyA9IGdyYXBoLmdldExpbmtzKG5vZGVJZCk7XG4gICAgaWYgKCFsaW5rcykgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDEgKyBsaW5rcy5sZW5ndGggLyAzLjA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0U2V0Tm9kZU1hc3Mobm9kZUlkKSB7XG4gICAgdmFyIGxpbmtzID0gZ3JhcGguZ2V0TGlua3Mobm9kZUlkKTtcbiAgICBpZiAoIWxpbmtzKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMSArIGxpbmtzLnNpemUgLyAzLjA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const getVariableName = __webpack_require__(/*! ./getVariableName */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js\");\n\nmodule.exports = function createPatternBuilder(dimension) {\n\n  return pattern;\n  \n  function pattern(template, config) {\n    let indent = (config && config.indent) || 0;\n    let join = (config && config.join !== undefined) ? config.join : '\\n';\n    let indentString = Array(indent + 1).join(' ');\n    let buffer = [];\n    for (let i = 0; i < dimension; ++i) {\n      let variableName = getVariableName(i);\n      let prefix = (i === 0) ? '' : indentString;\n      buffer.push(prefix + template.replace(/{var}/g, variableName));\n    }\n    return buffer.join(join);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9jcmVhdGVQYXR0ZXJuQnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBbUI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXG5ncmFwaC5mb3JjZWxheW91dFxcbGliXFxjb2RlR2VuZXJhdG9yc1xcY3JlYXRlUGF0dGVybkJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0VmFyaWFibGVOYW1lID0gcmVxdWlyZSgnLi9nZXRWYXJpYWJsZU5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQnVpbGRlcihkaW1lbnNpb24pIHtcblxuICByZXR1cm4gcGF0dGVybjtcbiAgXG4gIGZ1bmN0aW9uIHBhdHRlcm4odGVtcGxhdGUsIGNvbmZpZykge1xuICAgIGxldCBpbmRlbnQgPSAoY29uZmlnICYmIGNvbmZpZy5pbmRlbnQpIHx8IDA7XG4gICAgbGV0IGpvaW4gPSAoY29uZmlnICYmIGNvbmZpZy5qb2luICE9PSB1bmRlZmluZWQpID8gY29uZmlnLmpvaW4gOiAnXFxuJztcbiAgICBsZXQgaW5kZW50U3RyaW5nID0gQXJyYXkoaW5kZW50ICsgMSkuam9pbignICcpO1xuICAgIGxldCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBsZXQgdmFyaWFibGVOYW1lID0gZ2V0VmFyaWFibGVOYW1lKGkpO1xuICAgICAgbGV0IHByZWZpeCA9IChpID09PSAwKSA/ICcnIDogaW5kZW50U3RyaW5nO1xuICAgICAgYnVmZmVyLnB1c2gocHJlZml4ICsgdGVtcGxhdGUucmVwbGFjZSgve3Zhcn0vZywgdmFyaWFibGVOYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihqb2luKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = generateBoundsFunction;\nmodule.exports.generateFunctionBody = generateBoundsFunctionBody;\n\nconst createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\n\nfunction generateBoundsFunction(dimension) {\n  let code = generateBoundsFunctionBody(dimension);\n  return new Function('bodies', 'settings', 'random', code);\n}\n\nfunction generateBoundsFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n\n  let code = `\n  var boundingBox = {\n    ${pattern('min_{var}: 0, max_{var}: 0,', {indent: 4})}\n  };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n      var ${pattern('base_{var} = 0', {join: ', '})};\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          let neighborPos = neighbors[i].pos;\n          ${pattern('base_{var} += neighborPos.{var};', {indent: 10})}\n        }\n\n        ${pattern('base_{var} /= neighbors.length;', {indent: 8})}\n      } else {\n        ${pattern('base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;', {indent: 8})}\n      }\n\n      var springLength = settings.springLength;\n      return {\n        ${pattern('{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,', {indent: 8})}\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; // No bodies - no borders.\n\n    ${pattern('var max_{var} = -Infinity;', {indent: 4})}\n    ${pattern('var min_{var} = Infinity;', {indent: 4})}\n\n    while(i--) {\n      // this is O(n), it could be done faster with quadtree, if we check the root node bounds\n      var bodyPos = bodies[i].pos;\n      ${pattern('if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};', {indent: 6})}\n      ${pattern('if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};', {indent: 6})}\n    }\n\n    ${pattern('boundingBox.min_{var} = min_{var};', {indent: 4})}\n    ${pattern('boundingBox.max_{var} = max_{var};', {indent: 4})}\n  }\n\n  function resetBoundingBox() {\n    ${pattern('boundingBox.min_{var} = boundingBox.max_{var} = 0;', {indent: 4})}\n  }\n`;\n  return code;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUJvdW5kcy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DLDZCQUE2QixtQkFBTyxDQUFDLGtIQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxjQUFjLElBQUksVUFBVSxJQUFJLFFBQVEsVUFBVTtBQUN4RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxlQUFlLEtBQUssT0FBTyxXQUFXOztBQUVsRDtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQSxZQUFZLGVBQWUsS0FBSyxnQkFBZ0IsS0FBSyxJQUFJLFdBQVc7QUFDcEU7O0FBRUEsVUFBVSxlQUFlLEtBQUssb0JBQW9CLElBQUksVUFBVTtBQUNoRSxRQUFRO0FBQ1IsVUFBVSxlQUFlLEtBQUssb0JBQW9CLEtBQUssbUJBQW1CLElBQUksTUFBTSxJQUFJLFVBQVU7QUFDbEc7O0FBRUE7QUFDQTtBQUNBLFVBQVUsVUFBVSxJQUFJLFFBQVEsS0FBSyxpREFBaUQsVUFBVTtBQUNoRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsTUFBTSxrQkFBa0IsS0FBSyxZQUFZLElBQUksVUFBVTtBQUN2RCxNQUFNLGtCQUFrQixLQUFLLFdBQVcsSUFBSSxVQUFVOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQixLQUFLLE9BQU8sSUFBSSxPQUFPLEtBQUssV0FBVyxLQUFLLElBQUksVUFBVTtBQUN4RixRQUFRLHNCQUFzQixLQUFLLE9BQU8sSUFBSSxPQUFPLEtBQUssV0FBVyxLQUFLLElBQUksVUFBVTtBQUN4Rjs7QUFFQSxNQUFNLDBCQUEwQixLQUFLLE9BQU8sS0FBSyxJQUFJLFVBQVU7QUFDL0QsTUFBTSwwQkFBMEIsS0FBSyxPQUFPLEtBQUssSUFBSSxVQUFVO0FBQy9EOztBQUVBO0FBQ0EsTUFBTSwwQkFBMEIsS0FBSyxtQkFBbUIsS0FBSyxJQUFJLElBQUksVUFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWNoYVxcRG93bmxvYWRzXFx6b3Via29mZnNpdGVcXHBlcnNvbmFsc2l0ZVxcbm9kZV9tb2R1bGVzXFxuZ3JhcGguZm9yY2VsYXlvdXRcXGxpYlxcY29kZUdlbmVyYXRvcnNcXGdlbmVyYXRlQm91bmRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUJvdW5kc0Z1bmN0aW9uO1xubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkgPSBnZW5lcmF0ZUJvdW5kc0Z1bmN0aW9uQm9keTtcblxuY29uc3QgY3JlYXRlUGF0dGVybkJ1aWxkZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVBhdHRlcm5CdWlsZGVyJyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQm91bmRzRnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gIGxldCBjb2RlID0gZ2VuZXJhdGVCb3VuZHNGdW5jdGlvbkJvZHkoZGltZW5zaW9uKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignYm9kaWVzJywgJ3NldHRpbmdzJywgJ3JhbmRvbScsIGNvZGUpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJvdW5kc0Z1bmN0aW9uQm9keShkaW1lbnNpb24pIHtcbiAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuQnVpbGRlcihkaW1lbnNpb24pO1xuXG4gIGxldCBjb2RlID0gYFxuICB2YXIgYm91bmRpbmdCb3ggPSB7XG4gICAgJHtwYXR0ZXJuKCdtaW5fe3Zhcn06IDAsIG1heF97dmFyfTogMCwnLCB7aW5kZW50OiA0fSl9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBib3g6IGJvdW5kaW5nQm94LFxuXG4gICAgdXBkYXRlOiB1cGRhdGVCb3VuZGluZ0JveCxcblxuICAgIHJlc2V0OiByZXNldEJvdW5kaW5nQm94LFxuXG4gICAgZ2V0QmVzdE5ld1Bvc2l0aW9uOiBmdW5jdGlvbiAobmVpZ2hib3JzKSB7XG4gICAgICB2YXIgJHtwYXR0ZXJuKCdiYXNlX3t2YXJ9ID0gMCcsIHtqb2luOiAnLCAnfSl9O1xuXG4gICAgICBpZiAobmVpZ2hib3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGxldCBuZWlnaGJvclBvcyA9IG5laWdoYm9yc1tpXS5wb3M7XG4gICAgICAgICAgJHtwYXR0ZXJuKCdiYXNlX3t2YXJ9ICs9IG5laWdoYm9yUG9zLnt2YXJ9OycsIHtpbmRlbnQ6IDEwfSl9XG4gICAgICAgIH1cblxuICAgICAgICAke3BhdHRlcm4oJ2Jhc2Vfe3Zhcn0gLz0gbmVpZ2hib3JzLmxlbmd0aDsnLCB7aW5kZW50OiA4fSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3BhdHRlcm4oJ2Jhc2Vfe3Zhcn0gPSAoYm91bmRpbmdCb3gubWluX3t2YXJ9ICsgYm91bmRpbmdCb3gubWF4X3t2YXJ9KSAvIDI7Jywge2luZGVudDogOH0pfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ByaW5nTGVuZ3RoID0gc2V0dGluZ3Muc3ByaW5nTGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJHtwYXR0ZXJuKCd7dmFyfTogYmFzZV97dmFyfSArIChyYW5kb20ubmV4dERvdWJsZSgpIC0gMC41KSAqIHNwcmluZ0xlbmd0aCwnLCB7aW5kZW50OiA4fSl9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCgpIHtcbiAgICB2YXIgaSA9IGJvZGllcy5sZW5ndGg7XG4gICAgaWYgKGkgPT09IDApIHJldHVybjsgLy8gTm8gYm9kaWVzIC0gbm8gYm9yZGVycy5cblxuICAgICR7cGF0dGVybigndmFyIG1heF97dmFyfSA9IC1JbmZpbml0eTsnLCB7aW5kZW50OiA0fSl9XG4gICAgJHtwYXR0ZXJuKCd2YXIgbWluX3t2YXJ9ID0gSW5maW5pdHk7Jywge2luZGVudDogNH0pfVxuXG4gICAgd2hpbGUoaS0tKSB7XG4gICAgICAvLyB0aGlzIGlzIE8obiksIGl0IGNvdWxkIGJlIGRvbmUgZmFzdGVyIHdpdGggcXVhZHRyZWUsIGlmIHdlIGNoZWNrIHRoZSByb290IG5vZGUgYm91bmRzXG4gICAgICB2YXIgYm9keVBvcyA9IGJvZGllc1tpXS5wb3M7XG4gICAgICAke3BhdHRlcm4oJ2lmIChib2R5UG9zLnt2YXJ9IDwgbWluX3t2YXJ9KSBtaW5fe3Zhcn0gPSBib2R5UG9zLnt2YXJ9OycsIHtpbmRlbnQ6IDZ9KX1cbiAgICAgICR7cGF0dGVybignaWYgKGJvZHlQb3Mue3Zhcn0gPiBtYXhfe3Zhcn0pIG1heF97dmFyfSA9IGJvZHlQb3Mue3Zhcn07Jywge2luZGVudDogNn0pfVxuICAgIH1cblxuICAgICR7cGF0dGVybignYm91bmRpbmdCb3gubWluX3t2YXJ9ID0gbWluX3t2YXJ9OycsIHtpbmRlbnQ6IDR9KX1cbiAgICAke3BhdHRlcm4oJ2JvdW5kaW5nQm94Lm1heF97dmFyfSA9IG1heF97dmFyfTsnLCB7aW5kZW50OiA0fSl9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEJvdW5kaW5nQm94KCkge1xuICAgICR7cGF0dGVybignYm91bmRpbmdCb3gubWluX3t2YXJ9ID0gYm91bmRpbmdCb3gubWF4X3t2YXJ9ID0gMDsnLCB7aW5kZW50OiA0fSl9XG4gIH1cbmA7XG4gIHJldHVybiBjb2RlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateBodyFunction;\nmodule.exports.generateCreateBodyFunctionBody = generateCreateBodyFunctionBody;\n\n// InlineTransform: getVectorCode\nmodule.exports.getVectorCode = getVectorCode;\n// InlineTransform: getBodyCode\nmodule.exports.getBodyCode = getBodyCode;\n// InlineTransformExport: module.exports = function() { return Body; }\n\nfunction generateCreateBodyFunction(dimension, debugSetters) {\n  let code = generateCreateBodyFunctionBody(dimension, debugSetters);\n  let {Body} = (new Function(code))();\n  return Body;\n}\n\nfunction generateCreateBodyFunctionBody(dimension, debugSetters) {\n  let code = `\n${getVectorCode(dimension, debugSetters)}\n${getBodyCode(dimension, debugSetters)}\nreturn {Body: Body, Vector: Vector};\n`;\n  return code;\n}\n\nfunction getBodyCode(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let variableList = pattern('{var}', {join: ', '});\n  return `\nfunction Body(${variableList}) {\n  this.isPinned = false;\n  this.pos = new Vector(${variableList});\n  this.force = new Vector();\n  this.velocity = new Vector();\n  this.mass = 1;\n\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.reset = function() {\n  this.force.reset();\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.setPosition = function (${variableList}) {\n  ${pattern('this.pos.{var} = {var} || 0;', {indent: 2})}\n};`;\n}\n\nfunction getVectorCode(dimension, debugSetters) {\n  let pattern = createPatternBuilder(dimension);\n  let setters = '';\n  if (debugSetters) {\n    setters = `${pattern(\"\\n\\\n   var v{var};\\n\\\nObject.defineProperty(this, '{var}', {\\n\\\n  set: function(v) { \\n\\\n    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');\\n\\\n    v{var} = v; \\n\\\n  },\\n\\\n  get: function() { return v{var}; }\\n\\\n});\")}`;\n  }\n\n  let variableList = pattern('{var}', {join: ', '});\n  return `function Vector(${variableList}) {\n  ${setters}\n    if (typeof arguments[0] === 'object') {\n      // could be another vector\n      let v = arguments[0];\n      ${pattern('if (!Number.isFinite(v.{var})) throw new Error(\"Expected value is not a finite number at Vector constructor ({var})\");', {indent: 4})}\n      ${pattern('this.{var} = v.{var};', {indent: 4})}\n    } else {\n      ${pattern('this.{var} = typeof {var} === \"number\" ? {var} : 0;', {indent: 4})}\n    }\n  }\n  \n  Vector.prototype.reset = function () {\n    ${pattern('this.{var} = ', {join: ''})}0;\n  };`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUNyZWF0ZUJvZHkuanMiLCJtYXBwaW5ncyI6IjtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLGtIQUF3Qjs7QUFFN0Q7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLElBQUksSUFBSSxXQUFXO0FBQ2xEO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGFBQWE7QUFDdEQsSUFBSSxtQkFBbUIsS0FBSyxHQUFHLEtBQUssS0FBSyxJQUFJLFVBQVU7QUFDdkQsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVMsS0FBSztBQUNkLDhCQUE4QixJQUFJLElBQUk7QUFDdEMscUJBQXFCO0FBQ3JCLHlFQUF5RSxJQUFJLEdBQUc7QUFDaEYsTUFBTSxLQUFLLEtBQUs7QUFDaEIsR0FBRztBQUNILG9CQUFvQixTQUFTLE9BQU87QUFDcEMsQ0FBQyxFQUFFLEdBQUc7QUFDTjs7QUFFQSwrQkFBK0IsSUFBSSxJQUFJLFdBQVc7QUFDbEQsNEJBQTRCLGFBQWE7QUFDekMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDLElBQUksa0ZBQWtGLElBQUksSUFBSSxJQUFJLFVBQVU7QUFDckosUUFBUSxlQUFlLEtBQUssS0FBSyxLQUFLLElBQUksVUFBVTtBQUNwRCxNQUFNO0FBQ04sUUFBUSxlQUFlLEtBQUssVUFBVSxLQUFLLGdCQUFnQixLQUFLLElBQUksSUFBSSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxlQUFlLEtBQUssTUFBTSxTQUFTLEVBQUU7QUFDM0MsSUFBSTtBQUNKIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXG5ncmFwaC5mb3JjZWxheW91dFxcbGliXFxjb2RlR2VuZXJhdG9yc1xcZ2VuZXJhdGVDcmVhdGVCb2R5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgY3JlYXRlUGF0dGVybkJ1aWxkZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVBhdHRlcm5CdWlsZGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDcmVhdGVCb2R5RnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZUNyZWF0ZUJvZHlGdW5jdGlvbkJvZHkgPSBnZW5lcmF0ZUNyZWF0ZUJvZHlGdW5jdGlvbkJvZHk7XG5cbi8vIElubGluZVRyYW5zZm9ybTogZ2V0VmVjdG9yQ29kZVxubW9kdWxlLmV4cG9ydHMuZ2V0VmVjdG9yQ29kZSA9IGdldFZlY3RvckNvZGU7XG4vLyBJbmxpbmVUcmFuc2Zvcm06IGdldEJvZHlDb2RlXG5tb2R1bGUuZXhwb3J0cy5nZXRCb2R5Q29kZSA9IGdldEJvZHlDb2RlO1xuLy8gSW5saW5lVHJhbnNmb3JtRXhwb3J0OiBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gQm9keTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNyZWF0ZUJvZHlGdW5jdGlvbihkaW1lbnNpb24sIGRlYnVnU2V0dGVycykge1xuICBsZXQgY29kZSA9IGdlbmVyYXRlQ3JlYXRlQm9keUZ1bmN0aW9uQm9keShkaW1lbnNpb24sIGRlYnVnU2V0dGVycyk7XG4gIGxldCB7Qm9keX0gPSAobmV3IEZ1bmN0aW9uKGNvZGUpKSgpO1xuICByZXR1cm4gQm9keTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVCb2R5RnVuY3Rpb25Cb2R5KGRpbWVuc2lvbiwgZGVidWdTZXR0ZXJzKSB7XG4gIGxldCBjb2RlID0gYFxuJHtnZXRWZWN0b3JDb2RlKGRpbWVuc2lvbiwgZGVidWdTZXR0ZXJzKX1cbiR7Z2V0Qm9keUNvZGUoZGltZW5zaW9uLCBkZWJ1Z1NldHRlcnMpfVxucmV0dXJuIHtCb2R5OiBCb2R5LCBWZWN0b3I6IFZlY3Rvcn07XG5gO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm9keUNvZGUoZGltZW5zaW9uKSB7XG4gIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybkJ1aWxkZXIoZGltZW5zaW9uKTtcbiAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhdHRlcm4oJ3t2YXJ9Jywge2pvaW46ICcsICd9KTtcbiAgcmV0dXJuIGBcbmZ1bmN0aW9uIEJvZHkoJHt2YXJpYWJsZUxpc3R9KSB7XG4gIHRoaXMuaXNQaW5uZWQgPSBmYWxzZTtcbiAgdGhpcy5wb3MgPSBuZXcgVmVjdG9yKCR7dmFyaWFibGVMaXN0fSk7XG4gIHRoaXMuZm9yY2UgPSBuZXcgVmVjdG9yKCk7XG4gIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yKCk7XG4gIHRoaXMubWFzcyA9IDE7XG5cbiAgdGhpcy5zcHJpbmdDb3VudCA9IDA7XG4gIHRoaXMuc3ByaW5nTGVuZ3RoID0gMDtcbn1cblxuQm9keS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mb3JjZS5yZXNldCgpO1xuICB0aGlzLnNwcmluZ0NvdW50ID0gMDtcbiAgdGhpcy5zcHJpbmdMZW5ndGggPSAwO1xufVxuXG5Cb2R5LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgke3ZhcmlhYmxlTGlzdH0pIHtcbiAgJHtwYXR0ZXJuKCd0aGlzLnBvcy57dmFyfSA9IHt2YXJ9IHx8IDA7Jywge2luZGVudDogMn0pfVxufTtgO1xufVxuXG5mdW5jdGlvbiBnZXRWZWN0b3JDb2RlKGRpbWVuc2lvbiwgZGVidWdTZXR0ZXJzKSB7XG4gIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybkJ1aWxkZXIoZGltZW5zaW9uKTtcbiAgbGV0IHNldHRlcnMgPSAnJztcbiAgaWYgKGRlYnVnU2V0dGVycykge1xuICAgIHNldHRlcnMgPSBgJHtwYXR0ZXJuKFwiXFxuXFxcbiAgIHZhciB2e3Zhcn07XFxuXFxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAne3Zhcn0nLCB7XFxuXFxcbiAgc2V0OiBmdW5jdGlvbih2KSB7IFxcblxcXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBub24tbnVtYmVycyB0byB7dmFyfScpO1xcblxcXG4gICAgdnt2YXJ9ID0gdjsgXFxuXFxcbiAgfSxcXG5cXFxuICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdnt2YXJ9OyB9XFxuXFxcbn0pO1wiKX1gO1xuICB9XG5cbiAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhdHRlcm4oJ3t2YXJ9Jywge2pvaW46ICcsICd9KTtcbiAgcmV0dXJuIGBmdW5jdGlvbiBWZWN0b3IoJHt2YXJpYWJsZUxpc3R9KSB7XG4gICR7c2V0dGVyc31cbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGNvdWxkIGJlIGFub3RoZXIgdmVjdG9yXG4gICAgICBsZXQgdiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICR7cGF0dGVybignaWYgKCFOdW1iZXIuaXNGaW5pdGUodi57dmFyfSkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHZhbHVlIGlzIG5vdCBhIGZpbml0ZSBudW1iZXIgYXQgVmVjdG9yIGNvbnN0cnVjdG9yICh7dmFyfSlcIik7Jywge2luZGVudDogNH0pfVxuICAgICAgJHtwYXR0ZXJuKCd0aGlzLnt2YXJ9ID0gdi57dmFyfTsnLCB7aW5kZW50OiA0fSl9XG4gICAgfSBlbHNlIHtcbiAgICAgICR7cGF0dGVybigndGhpcy57dmFyfSA9IHR5cGVvZiB7dmFyfSA9PT0gXCJudW1iZXJcIiA/IHt2YXJ9IDogMDsnLCB7aW5kZW50OiA0fSl9XG4gICAgfVxuICB9XG4gIFxuICBWZWN0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICR7cGF0dGVybigndGhpcy57dmFyfSA9ICcsIHtqb2luOiAnJ30pfTA7XG4gIH07YDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateDragForceFunction;\nmodule.exports.generateCreateDragForceFunctionBody = generateCreateDragForceFunctionBody;\n\nfunction generateCreateDragForceFunction(dimension) {\n  let code = generateCreateDragForceFunctionBody(dimension);\n  return new Function('options', code);\n}\n\nfunction generateCreateDragForceFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');\n\n  return {\n    update: function(body) {\n      ${pattern('body.force.{var} -= options.dragCoefficient * body.velocity.{var};', {indent: 6})}\n    }\n  };\n`;\n  return code;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkIsbUJBQU8sQ0FBQyxrSEFBd0I7O0FBRTdEO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUIsS0FBSyw0Q0FBNEMsS0FBSyxJQUFJLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWNoYVxcRG93bmxvYWRzXFx6b3Via29mZnNpdGVcXHBlcnNvbmFsc2l0ZVxcbm9kZV9tb2R1bGVzXFxuZ3JhcGguZm9yY2VsYXlvdXRcXGxpYlxcY29kZUdlbmVyYXRvcnNcXGdlbmVyYXRlQ3JlYXRlRHJhZ0ZvcmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVBhdHRlcm5CdWlsZGVyID0gcmVxdWlyZSgnLi9jcmVhdGVQYXR0ZXJuQnVpbGRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ3JlYXRlRHJhZ0ZvcmNlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZUZ1bmN0aW9uQm9keSA9IGdlbmVyYXRlQ3JlYXRlRHJhZ0ZvcmNlRnVuY3Rpb25Cb2R5O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZUZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICBsZXQgY29kZSA9IGdlbmVyYXRlQ3JlYXRlRHJhZ0ZvcmNlRnVuY3Rpb25Cb2R5KGRpbWVuc2lvbik7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oJ29wdGlvbnMnLCBjb2RlKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVEcmFnRm9yY2VGdW5jdGlvbkJvZHkoZGltZW5zaW9uKSB7XG4gIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybkJ1aWxkZXIoZGltZW5zaW9uKTtcbiAgbGV0IGNvZGUgPSBgXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMuZHJhZ0NvZWZmaWNpZW50KSkgdGhyb3cgbmV3IEVycm9yKCdkcmFnQ29lZmZpY2llbnQgaXMgbm90IGEgZmluaXRlIG51bWJlcicpO1xuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAke3BhdHRlcm4oJ2JvZHkuZm9yY2Uue3Zhcn0gLT0gb3B0aW9ucy5kcmFnQ29lZmZpY2llbnQgKiBib2R5LnZlbG9jaXR5Lnt2YXJ9OycsIHtpbmRlbnQ6IDZ9KX1cbiAgICB9XG4gIH07XG5gO1xuICByZXR1cm4gY29kZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateSpringForceFunction;\nmodule.exports.generateCreateSpringForceFunctionBody = generateCreateSpringForceFunctionBody;\n\nfunction generateCreateSpringForceFunction(dimension) {\n  let code = generateCreateSpringForceFunctionBody(dimension);\n  return new Function('options', 'random', code);\n}\n\nfunction generateCreateSpringForceFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');\n  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');\n\n  return {\n    /**\n     * Updates forces acting on a spring\n     */\n    update: function (spring) {\n      var body1 = spring.from;\n      var body2 = spring.to;\n      var length = spring.length < 0 ? options.springLength : spring.length;\n      ${pattern('var d{var} = body2.pos.{var} - body1.pos.{var};', {indent: 6})}\n      var r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n      if (r === 0) {\n        ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n      }\n\n      var d = r - length;\n      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;\n\n      ${pattern('body1.force.{var} += coefficient * d{var}', {indent: 6})};\n      body1.springCount += 1;\n      body1.springLength += r;\n\n      ${pattern('body2.force.{var} -= coefficient * d{var}', {indent: 6})};\n      body2.springCount += 1;\n      body2.springLength += r;\n    }\n  };\n`;\n  return code;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUNyZWF0ZVNwcmluZ0ZvcmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QixtQkFBTyxDQUFDLGtIQUF3Qjs7QUFFN0Q7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZSxLQUFLLGFBQWEsS0FBSyxhQUFhLEtBQUssSUFBSSxVQUFVO0FBQzlFLDBCQUEwQixXQUFXLEtBQUssSUFBSSxJQUFJLElBQUksWUFBWSxFQUFFOztBQUVwRTtBQUNBLFVBQVUsV0FBVyxLQUFLLG1DQUFtQyxJQUFJLFVBQVU7QUFDM0Usd0JBQXdCLFdBQVcsS0FBSyxJQUFJLElBQUksSUFBSSxZQUFZLEVBQUU7QUFDbEU7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLHNCQUFzQixLQUFLLG1CQUFtQixJQUFJLElBQUksVUFBVTtBQUN4RTtBQUNBOztBQUVBLFFBQVEsc0JBQXNCLEtBQUssbUJBQW1CLElBQUksSUFBSSxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXG5ncmFwaC5mb3JjZWxheW91dFxcbGliXFxjb2RlR2VuZXJhdG9yc1xcZ2VuZXJhdGVDcmVhdGVTcHJpbmdGb3JjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVQYXR0ZXJuQnVpbGRlciA9IHJlcXVpcmUoJy4vY3JlYXRlUGF0dGVybkJ1aWxkZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNyZWF0ZVNwcmluZ0ZvcmNlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZUNyZWF0ZVNwcmluZ0ZvcmNlRnVuY3Rpb25Cb2R5ID0gZ2VuZXJhdGVDcmVhdGVTcHJpbmdGb3JjZUZ1bmN0aW9uQm9keTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVTcHJpbmdGb3JjZUZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICBsZXQgY29kZSA9IGdlbmVyYXRlQ3JlYXRlU3ByaW5nRm9yY2VGdW5jdGlvbkJvZHkoZGltZW5zaW9uKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignb3B0aW9ucycsICdyYW5kb20nLCBjb2RlKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVTcHJpbmdGb3JjZUZ1bmN0aW9uQm9keShkaW1lbnNpb24pIHtcbiAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuQnVpbGRlcihkaW1lbnNpb24pO1xuICBsZXQgY29kZSA9IGBcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5zcHJpbmdDb2VmZmljaWVudCkpIHRocm93IG5ldyBFcnJvcignU3ByaW5nIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlcicpO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShvcHRpb25zLnNwcmluZ0xlbmd0aCkpIHRocm93IG5ldyBFcnJvcignU3ByaW5nIGxlbmd0aCBpcyBub3QgYSBudW1iZXInKTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZm9yY2VzIGFjdGluZyBvbiBhIHNwcmluZ1xuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHNwcmluZykge1xuICAgICAgdmFyIGJvZHkxID0gc3ByaW5nLmZyb207XG4gICAgICB2YXIgYm9keTIgPSBzcHJpbmcudG87XG4gICAgICB2YXIgbGVuZ3RoID0gc3ByaW5nLmxlbmd0aCA8IDAgPyBvcHRpb25zLnNwcmluZ0xlbmd0aCA6IHNwcmluZy5sZW5ndGg7XG4gICAgICAke3BhdHRlcm4oJ3ZhciBke3Zhcn0gPSBib2R5Mi5wb3Mue3Zhcn0gLSBib2R5MS5wb3Mue3Zhcn07Jywge2luZGVudDogNn0pfVxuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoJHtwYXR0ZXJuKCdke3Zhcn0gKiBke3Zhcn0nLCB7am9pbjogJyArICd9KX0pO1xuXG4gICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAke3BhdHRlcm4oJ2R7dmFyfSA9IChyYW5kb20ubmV4dERvdWJsZSgpIC0gMC41KSAvIDUwOycsIHtpbmRlbnQ6IDh9KX1cbiAgICAgICAgciA9IE1hdGguc3FydCgke3BhdHRlcm4oJ2R7dmFyfSAqIGR7dmFyfScsIHtqb2luOiAnICsgJ30pfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkID0gciAtIGxlbmd0aDtcbiAgICAgIHZhciBjb2VmZmljaWVudCA9ICgoc3ByaW5nLmNvZWZmaWNpZW50ID4gMCkgPyBzcHJpbmcuY29lZmZpY2llbnQgOiBvcHRpb25zLnNwcmluZ0NvZWZmaWNpZW50KSAqIGQgLyByO1xuXG4gICAgICAke3BhdHRlcm4oJ2JvZHkxLmZvcmNlLnt2YXJ9ICs9IGNvZWZmaWNpZW50ICogZHt2YXJ9Jywge2luZGVudDogNn0pfTtcbiAgICAgIGJvZHkxLnNwcmluZ0NvdW50ICs9IDE7XG4gICAgICBib2R5MS5zcHJpbmdMZW5ndGggKz0gcjtcblxuICAgICAgJHtwYXR0ZXJuKCdib2R5Mi5mb3JjZS57dmFyfSAtPSBjb2VmZmljaWVudCAqIGR7dmFyfScsIHtpbmRlbnQ6IDZ9KX07XG4gICAgICBib2R5Mi5zcHJpbmdDb3VudCArPSAxO1xuICAgICAgYm9keTIuc3ByaW5nTGVuZ3RoICs9IHI7XG4gICAgfVxuICB9O1xuYDtcbiAgcmV0dXJuIGNvZGU7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {indent: 2})}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {indent: 4})}\n    ${pattern('var v{var} = body.velocity.{var};', {indent: 4})}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {join: ' + '})});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {indent: 6})}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {indent: 4})}\n\n    ${pattern('body.pos.{var} += d{var};', {indent: 4})}\n\n    ${pattern('t{var} += Math.abs(d{var});', {indent: 4})}\n  }\n\n  return (${pattern('t{var} * t{var}', {join: ' + '})})/length;\n`;\n  return code;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUludGVncmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCLG1CQUFPLENBQUMsa0hBQXdCOztBQUU3RDtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGVBQWUsS0FBSyxPQUFPLEtBQUssSUFBSSxJQUFJLFVBQVU7O0FBRXRELGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sd0JBQXdCLEtBQUssdUJBQXVCLEtBQUssSUFBSSxVQUFVO0FBQzdFLE1BQU0sZUFBZSxLQUFLLGlCQUFpQixLQUFLLElBQUksVUFBVTtBQUM5RCx3QkFBd0IsV0FBVyxLQUFLLElBQUksSUFBSSxJQUFJLFlBQVksRUFBRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLFVBQVU7QUFDaEU7O0FBRUEsTUFBTSxXQUFXLEtBQUssNEJBQTRCLEtBQUssSUFBSSxVQUFVOztBQUVyRSxNQUFNLG1CQUFtQixLQUFLLEtBQUssS0FBSyxJQUFJLFVBQVU7O0FBRXRELE1BQU0sV0FBVyxLQUFLLGNBQWMsSUFBSSxFQUFFLElBQUksVUFBVTtBQUN4RDs7QUFFQSxZQUFZLFdBQVcsS0FBSyxJQUFJLElBQUksSUFBSSxZQUFZLEVBQUU7QUFDdEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXG5ncmFwaC5mb3JjZWxheW91dFxcbGliXFxjb2RlR2VuZXJhdG9yc1xcZ2VuZXJhdGVJbnRlZ3JhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVBhdHRlcm5CdWlsZGVyID0gcmVxdWlyZSgnLi9jcmVhdGVQYXR0ZXJuQnVpbGRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlSW50ZWdyYXRvckZ1bmN0aW9uO1xubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGVJbnRlZ3JhdG9yRnVuY3Rpb25Cb2R5ID0gZ2VuZXJhdGVJbnRlZ3JhdG9yRnVuY3Rpb25Cb2R5O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUludGVncmF0b3JGdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgbGV0IGNvZGUgPSBnZW5lcmF0ZUludGVncmF0b3JGdW5jdGlvbkJvZHkoZGltZW5zaW9uKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignYm9kaWVzJywgJ3RpbWVTdGVwJywgJ2FkYXB0aXZlVGltZVN0ZXBXZWlnaHQnLCBjb2RlKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVJbnRlZ3JhdG9yRnVuY3Rpb25Cb2R5KGRpbWVuc2lvbikge1xuICBsZXQgcGF0dGVybiA9IGNyZWF0ZVBhdHRlcm5CdWlsZGVyKGRpbWVuc2lvbik7XG4gIGxldCBjb2RlID0gYFxuICB2YXIgbGVuZ3RoID0gYm9kaWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgJHtwYXR0ZXJuKCd2YXIgZHt2YXJ9ID0gMCwgdHt2YXJ9ID0gMDsnLCB7aW5kZW50OiAyfSl9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgIGlmIChib2R5LmlzUGlubmVkKSBjb250aW51ZTtcblxuICAgIGlmIChhZGFwdGl2ZVRpbWVTdGVwV2VpZ2h0ICYmIGJvZHkuc3ByaW5nQ291bnQpIHtcbiAgICAgIHRpbWVTdGVwID0gKGFkYXB0aXZlVGltZVN0ZXBXZWlnaHQgKiBib2R5LnNwcmluZ0xlbmd0aC9ib2R5LnNwcmluZ0NvdW50KTtcbiAgICB9XG5cbiAgICB2YXIgY29lZmYgPSB0aW1lU3RlcCAvIGJvZHkubWFzcztcblxuICAgICR7cGF0dGVybignYm9keS52ZWxvY2l0eS57dmFyfSArPSBjb2VmZiAqIGJvZHkuZm9yY2Uue3Zhcn07Jywge2luZGVudDogNH0pfVxuICAgICR7cGF0dGVybigndmFyIHZ7dmFyfSA9IGJvZHkudmVsb2NpdHkue3Zhcn07Jywge2luZGVudDogNH0pfVxuICAgIHZhciB2ID0gTWF0aC5zcXJ0KCR7cGF0dGVybigndnt2YXJ9ICogdnt2YXJ9Jywge2pvaW46ICcgKyAnfSl9KTtcblxuICAgIGlmICh2ID4gMSkge1xuICAgICAgLy8gV2Ugbm9ybWFsaXplIGl0IHNvIHRoYXQgd2UgbW92ZSB3aXRoaW4gdGltZVN0ZXAgcmFuZ2UuIFxuICAgICAgLy8gZm9yIHRoZSBjYXNlIHdoZW4gdiA8PSAxIC0gd2UgbGV0IHZlbG9jaXR5IHRvIGZhZGUgb3V0LlxuICAgICAgJHtwYXR0ZXJuKCdib2R5LnZlbG9jaXR5Lnt2YXJ9ID0gdnt2YXJ9IC8gdjsnLCB7aW5kZW50OiA2fSl9XG4gICAgfVxuXG4gICAgJHtwYXR0ZXJuKCdke3Zhcn0gPSB0aW1lU3RlcCAqIGJvZHkudmVsb2NpdHkue3Zhcn07Jywge2luZGVudDogNH0pfVxuXG4gICAgJHtwYXR0ZXJuKCdib2R5LnBvcy57dmFyfSArPSBke3Zhcn07Jywge2luZGVudDogNH0pfVxuXG4gICAgJHtwYXR0ZXJuKCd0e3Zhcn0gKz0gTWF0aC5hYnMoZHt2YXJ9KTsnLCB7aW5kZW50OiA0fSl9XG4gIH1cblxuICByZXR1cm4gKCR7cGF0dGVybigndHt2YXJ9ICogdHt2YXJ9Jywge2pvaW46ICcgKyAnfSl9KS9sZW5ndGg7XG5gO1xuICByZXR1cm4gY29kZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js\");\nconst getVariableName = __webpack_require__(/*! ./getVariableName */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js\");\n\nmodule.exports = generateQuadTreeFunction;\nmodule.exports.generateQuadTreeFunctionBody = generateQuadTreeFunctionBody;\n\n// These exports are for InlineTransform tool.\n// InlineTransform: getInsertStackCode\nmodule.exports.getInsertStackCode = getInsertStackCode;\n// InlineTransform: getQuadNodeCode\nmodule.exports.getQuadNodeCode = getQuadNodeCode;\n// InlineTransform: isSamePosition\nmodule.exports.isSamePosition = isSamePosition;\n// InlineTransform: getChildBodyCode\nmodule.exports.getChildBodyCode = getChildBodyCode;\n// InlineTransform: setChildBodyCode\nmodule.exports.setChildBodyCode = setChildBodyCode;\n\nfunction generateQuadTreeFunction(dimension) {\n  let code = generateQuadTreeFunctionBody(dimension);\n  return (new Function(code))();\n}\n\nfunction generateQuadTreeFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let quadCount = Math.pow(2, dimension);\n\n  let code = `\n${getInsertStackCode()}\n${getQuadNodeCode(dimension)}\n${isSamePosition(dimension)}\n${getChildBodyCode(dimension)}\n${setChildBodyCode(dimension)}\n\nfunction createQuadTree(options, random) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  var gravity = options.gravity;\n  var updateQueue = [];\n  var insertStack = new InsertStack();\n  var theta = options.theta;\n\n  var nodesCache = [];\n  var currentInCache = 0;\n  var root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node if it is present\n     */\n    getRoot: function() {\n      return root;\n    },\n\n    updateBodyForce: update,\n\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n${assignQuads('      node.')}\n      node.body = null;\n      node.mass = ${pattern('node.mass_{var} = ', {join: ''})}0;\n      ${pattern('node.min_{var} = node.max_{var} = ', {join: ''})}0;\n    } else {\n      node = new QuadNode();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue;\n    var v;\n    ${pattern('var d{var};', {indent: 4})}\n    var r; \n    ${pattern('var f{var} = 0;', {indent: 4})}\n    var queueLength = 1;\n    var shiftIdx = 0;\n    var pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx];\n      var body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        ${pattern('d{var} = body.pos.{var} - sourceBody.pos.{var};', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 10})}\n          r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n        }\n\n        // This is standard gravitation force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        ${pattern('f{var} += v * d{var};', {indent: 8})}\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        ${pattern('d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n        if (r === 0) {\n          // Sorry about code duplication. I don't want to create many functions\n          // right away. Just want to see performance first.\n          ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 10})}\n          r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.max_${getVariableName(0)} - node.min_${getVariableName(0)}) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was made into square during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          ${pattern('f{var} += v * d{var};', {indent: 10})}\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n${runRecursiveOnChildren()}\n        }\n      }\n    }\n\n    ${pattern('sourceBody.force.{var} += f{var};', {indent: 4})}\n  }\n\n  function insertBodies(bodies) {\n    ${pattern('var {var}min = Number.MAX_VALUE;', {indent: 4})}\n    ${pattern('var {var}max = Number.MIN_VALUE;', {indent: 4})}\n    var i = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    while (i--) {\n      var pos = bodies[i].pos;\n      ${pattern('if (pos.{var} < {var}min) {var}min = pos.{var};', {indent: 6})}\n      ${pattern('if (pos.{var} > {var}max) {var}max = pos.{var};', {indent: 6})}\n    }\n\n    // Makes the bounds square.\n    var maxSideLength = -Infinity;\n    ${pattern('if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;', {indent: 4})}\n\n    currentInCache = 0;\n    root = newNode();\n    ${pattern('root.min_{var} = {var}min;', {indent: 4})}\n    ${pattern('root.max_{var} = {var}min + maxSideLength;', {indent: 4})}\n\n    i = bodies.length - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop();\n      var node = stackItem.node;\n      var body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        ${pattern('var {var} = body.pos.{var};', {indent: 8})}\n        node.mass += body.mass;\n        ${pattern('node.mass_{var} += body.mass * {var};', {indent: 8})}\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0; // Assume we are in the 0's quad.\n        ${pattern('var min_{var} = node.min_{var};', {indent: 8})}\n        ${pattern('var max_{var} = (min_{var} + node.max_{var}) / 2;', {indent: 8})}\n\n${assignInsertionQuadIndex(8)}\n\n        var child = getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          ${pattern('child.min_{var} = min_{var};', {indent: 10})}\n          ${pattern('child.max_{var} = max_{var};', {indent: 10})}\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            ${pattern('var d{var} = (node.max_{var} - node.min_{var}) * offset;', {indent: 12})}\n\n            ${pattern('oldBody.pos.{var} = node.min_{var} + d{var};', {indent: 12})}\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n}\nreturn createQuadTree;\n\n`;\n  return code;\n\n\n  function assignInsertionQuadIndex(indentCount) {\n    let insertionCode = [];\n    let indent = Array(indentCount + 1).join(' ');\n    for (let i = 0; i < dimension; ++i) {\n      insertionCode.push(indent + `if (${getVariableName(i)} > max_${getVariableName(i)}) {`);\n      insertionCode.push(indent + `  quadIdx = quadIdx + ${Math.pow(2, i)};`);\n      insertionCode.push(indent + `  min_${getVariableName(i)} = max_${getVariableName(i)};`);\n      insertionCode.push(indent + `  max_${getVariableName(i)} = node.max_${getVariableName(i)};`);\n      insertionCode.push(indent + `}`);\n    }\n    return insertionCode.join('\\n');\n    // if (x > max_x) { // somewhere in the eastern part.\n    //   quadIdx = quadIdx + 1;\n    //   left = right;\n    //   right = node.right;\n    // }\n  }\n\n  function runRecursiveOnChildren() {\n    let indent = Array(11).join(' ');\n    let recursiveCode = [];\n    for (let i = 0; i < quadCount; ++i) {\n      recursiveCode.push(indent + `if (node.quad${i}) {`);\n      recursiveCode.push(indent + `  queue[pushIdx] = node.quad${i};`);\n      recursiveCode.push(indent + `  queueLength += 1;`);\n      recursiveCode.push(indent + `  pushIdx += 1;`);\n      recursiveCode.push(indent + `}`);\n    }\n    return recursiveCode.join('\\n');\n    // if (node.quad0) {\n    //   queue[pushIdx] = node.quad0;\n    //   queueLength += 1;\n    //   pushIdx += 1;\n    // }\n  }\n\n  function assignQuads(indent) {\n    // this.quad0 = null;\n    // this.quad1 = null;\n    // this.quad2 = null;\n    // this.quad3 = null;\n    let quads = [];\n    for (let i = 0; i < quadCount; ++i) {\n      quads.push(`${indent}quad${i} = null;`);\n    }\n    return quads.join('\\n');\n  }\n}\n\nfunction isSamePosition(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  return `\n  function isSamePosition(point1, point2) {\n    ${pattern('var d{var} = Math.abs(point1.{var} - point2.{var});', {indent: 2})}\n  \n    return ${pattern('d{var} < 1e-8', {join: ' && '})};\n  }  \n`;\n}\n\nfunction setChildBodyCode(dimension) {\n  var quadCount = Math.pow(2, dimension);\n  return `\nfunction setChild(node, idx, child) {\n  ${setChildBody()}\n}`;\n  function setChildBody() {\n    let childBody = [];\n    for (let i = 0; i < quadCount; ++i) {\n      let prefix = (i === 0) ? '  ' : '  else ';\n      childBody.push(`${prefix}if (idx === ${i}) node.quad${i} = child;`);\n    }\n\n    return childBody.join('\\n');\n    // if (idx === 0) node.quad0 = child;\n    // else if (idx === 1) node.quad1 = child;\n    // else if (idx === 2) node.quad2 = child;\n    // else if (idx === 3) node.quad3 = child;\n  }\n}\n\nfunction getChildBodyCode(dimension) {\n  return `function getChild(node, idx) {\n${getChildBody()}\n  return null;\n}`;\n\n  function getChildBody() {\n    let childBody = [];\n    let quadCount = Math.pow(2, dimension);\n    for (let i = 0; i < quadCount; ++i) {\n      childBody.push(`  if (idx === ${i}) return node.quad${i};`);\n    }\n\n    return childBody.join('\\n');\n    // if (idx === 0) return node.quad0;\n    // if (idx === 1) return node.quad1;\n    // if (idx === 2) return node.quad2;\n    // if (idx === 3) return node.quad3;\n  }\n}\n\nfunction getQuadNodeCode(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let quadCount = Math.pow(2, dimension);\n  var quadNodeCode = `\nfunction QuadNode() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain bodies:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n${assignQuads('  this.')}\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  ${pattern('this.mass_{var} = 0;', {indent: 2})}\n\n  // bounding box coordinates\n  ${pattern('this.min_{var} = 0;', {indent: 2})}\n  ${pattern('this.max_{var} = 0;', {indent: 2})}\n}\n`;\n  return quadNodeCode;\n\n  function assignQuads(indent) {\n    // this.quad0 = null;\n    // this.quad1 = null;\n    // this.quad2 = null;\n    // this.quad3 = null;\n    let quads = [];\n    for (let i = 0; i < quadCount; ++i) {\n      quads.push(`${indent}quad${i} = null;`);\n    }\n    return quads.join('\\n');\n  }\n}\n\nfunction getInsertStackCode() {\n  return `\n/**\n * Our implementation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressure: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZVF1YWRUcmVlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QixtQkFBTyxDQUFDLGtIQUF3QjtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBbUI7O0FBRW5EO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0YsRUFBRTtBQUNGLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esb0JBQW9CLG9CQUFvQixLQUFLLE1BQU0sU0FBUyxFQUFFO0FBQzlELFFBQVEsbUJBQW1CLEtBQUssWUFBWSxLQUFLLE1BQU0sU0FBUyxFQUFFO0FBQ2xFLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZUFBZSxLQUFLLElBQUksVUFBVTtBQUN4QztBQUNBLE1BQU0sZUFBZSxLQUFLLElBQUksSUFBSSxVQUFVO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsS0FBSyxZQUFZLEtBQUssa0JBQWtCLEtBQUssSUFBSSxVQUFVO0FBQ2hGLHdCQUF3QixXQUFXLEtBQUssSUFBSSxJQUFJLElBQUksWUFBWSxFQUFFOztBQUVsRTtBQUNBO0FBQ0EsWUFBWSxXQUFXLEtBQUssbUNBQW1DLElBQUksV0FBVztBQUM5RSwwQkFBMEIsV0FBVyxLQUFLLElBQUksSUFBSSxJQUFJLFlBQVksRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsS0FBSyxTQUFTLEtBQUssSUFBSSxVQUFVO0FBQ3RELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsS0FBSyxhQUFhLEtBQUssOEJBQThCLEtBQUssSUFBSSxVQUFVO0FBQzdGLHdCQUF3QixXQUFXLEtBQUssSUFBSSxJQUFJLElBQUksWUFBWSxFQUFFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsS0FBSyxtQ0FBbUMsSUFBSSxXQUFXO0FBQzlFLDBCQUEwQixXQUFXLEtBQUssSUFBSSxJQUFJLElBQUksWUFBWSxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0IsYUFBYSxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsS0FBSyxTQUFTLEtBQUssSUFBSSxXQUFXO0FBQ3pELFVBQVU7QUFDVjs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsTUFBTSwyQkFBMkIsS0FBSyxLQUFLLEtBQUssSUFBSSxVQUFVO0FBQzlEOztBQUVBO0FBQ0EsTUFBTSxjQUFjLElBQUksdUJBQXVCLElBQUksVUFBVTtBQUM3RCxNQUFNLGNBQWMsSUFBSSx1QkFBdUIsSUFBSSxVQUFVO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCLEtBQUssR0FBRyxJQUFJLE1BQU0sSUFBSSxXQUFXLEtBQUssSUFBSSxVQUFVO0FBQzlFLFFBQVEsa0JBQWtCLEtBQUssR0FBRyxJQUFJLE1BQU0sSUFBSSxXQUFXLEtBQUssSUFBSSxVQUFVO0FBQzlFOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGNBQWMsSUFBSSxPQUFPLElBQUksc0NBQXNDLElBQUksT0FBTyxJQUFJLEtBQUssSUFBSSxVQUFVOztBQUUzRztBQUNBO0FBQ0EsTUFBTSxtQkFBbUIsS0FBSyxHQUFHLElBQUksSUFBSSxJQUFJLFVBQVU7QUFDdkQsTUFBTSxtQkFBbUIsS0FBSyxHQUFHLElBQUksb0JBQW9CLElBQUksVUFBVTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsY0FBYyxLQUFLLFlBQVksS0FBSyxJQUFJLFVBQVU7QUFDNUQ7QUFDQSxVQUFVLG9CQUFvQixLQUFLLGdCQUFnQixLQUFLLElBQUksVUFBVTs7QUFFdEU7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixVQUFVLGtCQUFrQixLQUFLLFlBQVksS0FBSyxJQUFJLFVBQVU7QUFDaEUsVUFBVSxrQkFBa0IsS0FBSyxRQUFRLEtBQUssWUFBWSxJQUFJLE1BQU0sSUFBSSxVQUFVOztBQUVsRixFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0IsS0FBSyxPQUFPLEtBQUssSUFBSSxXQUFXO0FBQ2hFLFlBQVksb0JBQW9CLEtBQUssT0FBTyxLQUFLLElBQUksV0FBVztBQUNoRTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZSxLQUFLLGFBQWEsS0FBSyxZQUFZLElBQUksV0FBVyxJQUFJLFdBQVc7O0FBRTlGLGNBQWMsc0JBQXNCLEtBQUssWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJLFdBQVc7QUFDbEY7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMseUNBQXlDLG9CQUFvQixRQUFRLG1CQUFtQixHQUFHO0FBQzNGLDJEQUEyRCxnQkFBZ0I7QUFDM0UsMkNBQTJDLG9CQUFvQixRQUFRLG9CQUFvQjtBQUMzRiwyQ0FBMkMsb0JBQW9CLGFBQWEsb0JBQW9CO0FBQ2hHLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsa0RBQWtELEVBQUUsR0FBRztBQUN2RCxpRUFBaUUsR0FBRztBQUNwRSxzREFBc0Q7QUFDdEQsa0RBQWtEO0FBQ2xELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLG9CQUFvQixPQUFPLE1BQU0sR0FBRyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxlQUFlLEtBQUssbUJBQW1CLEtBQUssVUFBVSxJQUFJLEVBQUUsSUFBSSxVQUFVO0FBQ2hGO0FBQ0EsYUFBYSxXQUFXLEtBQUssVUFBVSxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esd0JBQXdCLE9BQU8sY0FBYyxFQUFFLGFBQWEsR0FBRyxRQUFRO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNDQUFzQyxFQUFFLG9CQUFvQixHQUFHO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFvQixLQUFLLElBQUksSUFBSSxVQUFVOztBQUUvQztBQUNBLElBQUksbUJBQW1CLEtBQUssSUFBSSxJQUFJLFVBQVU7QUFDOUMsSUFBSSxtQkFBbUIsS0FBSyxJQUFJLElBQUksVUFBVTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsb0JBQW9CLE9BQU8sTUFBTSxHQUFHLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWljaGFcXERvd25sb2Fkc1xcem91YmtvZmZzaXRlXFxwZXJzb25hbHNpdGVcXG5vZGVfbW9kdWxlc1xcbmdyYXBoLmZvcmNlbGF5b3V0XFxsaWJcXGNvZGVHZW5lcmF0b3JzXFxnZW5lcmF0ZVF1YWRUcmVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVBhdHRlcm5CdWlsZGVyID0gcmVxdWlyZSgnLi9jcmVhdGVQYXR0ZXJuQnVpbGRlcicpO1xuY29uc3QgZ2V0VmFyaWFibGVOYW1lID0gcmVxdWlyZSgnLi9nZXRWYXJpYWJsZU5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVF1YWRUcmVlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVF1YWRUcmVlRnVuY3Rpb25Cb2R5ID0gZ2VuZXJhdGVRdWFkVHJlZUZ1bmN0aW9uQm9keTtcblxuLy8gVGhlc2UgZXhwb3J0cyBhcmUgZm9yIElubGluZVRyYW5zZm9ybSB0b29sLlxuLy8gSW5saW5lVHJhbnNmb3JtOiBnZXRJbnNlcnRTdGFja0NvZGVcbm1vZHVsZS5leHBvcnRzLmdldEluc2VydFN0YWNrQ29kZSA9IGdldEluc2VydFN0YWNrQ29kZTtcbi8vIElubGluZVRyYW5zZm9ybTogZ2V0UXVhZE5vZGVDb2RlXG5tb2R1bGUuZXhwb3J0cy5nZXRRdWFkTm9kZUNvZGUgPSBnZXRRdWFkTm9kZUNvZGU7XG4vLyBJbmxpbmVUcmFuc2Zvcm06IGlzU2FtZVBvc2l0aW9uXG5tb2R1bGUuZXhwb3J0cy5pc1NhbWVQb3NpdGlvbiA9IGlzU2FtZVBvc2l0aW9uO1xuLy8gSW5saW5lVHJhbnNmb3JtOiBnZXRDaGlsZEJvZHlDb2RlXG5tb2R1bGUuZXhwb3J0cy5nZXRDaGlsZEJvZHlDb2RlID0gZ2V0Q2hpbGRCb2R5Q29kZTtcbi8vIElubGluZVRyYW5zZm9ybTogc2V0Q2hpbGRCb2R5Q29kZVxubW9kdWxlLmV4cG9ydHMuc2V0Q2hpbGRCb2R5Q29kZSA9IHNldENoaWxkQm9keUNvZGU7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUXVhZFRyZWVGdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgbGV0IGNvZGUgPSBnZW5lcmF0ZVF1YWRUcmVlRnVuY3Rpb25Cb2R5KGRpbWVuc2lvbik7XG4gIHJldHVybiAobmV3IEZ1bmN0aW9uKGNvZGUpKSgpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVF1YWRUcmVlRnVuY3Rpb25Cb2R5KGRpbWVuc2lvbikge1xuICBsZXQgcGF0dGVybiA9IGNyZWF0ZVBhdHRlcm5CdWlsZGVyKGRpbWVuc2lvbik7XG4gIGxldCBxdWFkQ291bnQgPSBNYXRoLnBvdygyLCBkaW1lbnNpb24pO1xuXG4gIGxldCBjb2RlID0gYFxuJHtnZXRJbnNlcnRTdGFja0NvZGUoKX1cbiR7Z2V0UXVhZE5vZGVDb2RlKGRpbWVuc2lvbil9XG4ke2lzU2FtZVBvc2l0aW9uKGRpbWVuc2lvbil9XG4ke2dldENoaWxkQm9keUNvZGUoZGltZW5zaW9uKX1cbiR7c2V0Q2hpbGRCb2R5Q29kZShkaW1lbnNpb24pfVxuXG5mdW5jdGlvbiBjcmVhdGVRdWFkVHJlZShvcHRpb25zLCByYW5kb20pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3Jhdml0eSA9IHR5cGVvZiBvcHRpb25zLmdyYXZpdHkgPT09ICdudW1iZXInID8gb3B0aW9ucy5ncmF2aXR5IDogLTE7XG4gIG9wdGlvbnMudGhldGEgPSB0eXBlb2Ygb3B0aW9ucy50aGV0YSA9PT0gJ251bWJlcicgPyBvcHRpb25zLnRoZXRhIDogMC44O1xuXG4gIHZhciBncmF2aXR5ID0gb3B0aW9ucy5ncmF2aXR5O1xuICB2YXIgdXBkYXRlUXVldWUgPSBbXTtcbiAgdmFyIGluc2VydFN0YWNrID0gbmV3IEluc2VydFN0YWNrKCk7XG4gIHZhciB0aGV0YSA9IG9wdGlvbnMudGhldGE7XG5cbiAgdmFyIG5vZGVzQ2FjaGUgPSBbXTtcbiAgdmFyIGN1cnJlbnRJbkNhY2hlID0gMDtcbiAgdmFyIHJvb3QgPSBuZXdOb2RlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRCb2RpZXM6IGluc2VydEJvZGllcyxcblxuICAgIC8qKlxuICAgICAqIEdldHMgcm9vdCBub2RlIGlmIGl0IGlzIHByZXNlbnRcbiAgICAgKi9cbiAgICBnZXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH0sXG5cbiAgICB1cGRhdGVCb2R5Rm9yY2U6IHVwZGF0ZSxcblxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uKG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChuZXdPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5ncmF2aXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGdyYXZpdHkgPSBuZXdPcHRpb25zLmdyYXZpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLnRoZXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoZXRhID0gbmV3T3B0aW9ucy50aGV0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBncmF2aXR5OiBncmF2aXR5LFxuICAgICAgICB0aGV0YTogdGhldGFcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG5ld05vZGUoKSB7XG4gICAgLy8gVG8gYXZvaWQgcHJlc3N1cmUgb24gR0Mgd2UgcmV1c2Ugbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBub2Rlc0NhY2hlW2N1cnJlbnRJbkNhY2hlXTtcbiAgICBpZiAobm9kZSkge1xuJHthc3NpZ25RdWFkcygnICAgICAgbm9kZS4nKX1cbiAgICAgIG5vZGUuYm9keSA9IG51bGw7XG4gICAgICBub2RlLm1hc3MgPSAke3BhdHRlcm4oJ25vZGUubWFzc197dmFyfSA9ICcsIHtqb2luOiAnJ30pfTA7XG4gICAgICAke3BhdHRlcm4oJ25vZGUubWluX3t2YXJ9ID0gbm9kZS5tYXhfe3Zhcn0gPSAnLCB7am9pbjogJyd9KX0wO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IFF1YWROb2RlKCk7XG4gICAgICBub2Rlc0NhY2hlW2N1cnJlbnRJbkNhY2hlXSA9IG5vZGU7XG4gICAgfVxuXG4gICAgKytjdXJyZW50SW5DYWNoZTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzb3VyY2VCb2R5KSB7XG4gICAgdmFyIHF1ZXVlID0gdXBkYXRlUXVldWU7XG4gICAgdmFyIHY7XG4gICAgJHtwYXR0ZXJuKCd2YXIgZHt2YXJ9OycsIHtpbmRlbnQ6IDR9KX1cbiAgICB2YXIgcjsgXG4gICAgJHtwYXR0ZXJuKCd2YXIgZnt2YXJ9ID0gMDsnLCB7aW5kZW50OiA0fSl9XG4gICAgdmFyIHF1ZXVlTGVuZ3RoID0gMTtcbiAgICB2YXIgc2hpZnRJZHggPSAwO1xuICAgIHZhciBwdXNoSWR4ID0gMTtcblxuICAgIHF1ZXVlWzBdID0gcm9vdDtcblxuICAgIHdoaWxlIChxdWV1ZUxlbmd0aCkge1xuICAgICAgdmFyIG5vZGUgPSBxdWV1ZVtzaGlmdElkeF07XG4gICAgICB2YXIgYm9keSA9IG5vZGUuYm9keTtcblxuICAgICAgcXVldWVMZW5ndGggLT0gMTtcbiAgICAgIHNoaWZ0SWR4ICs9IDE7XG4gICAgICB2YXIgZGlmZmVyZW50Qm9keSA9IChib2R5ICE9PSBzb3VyY2VCb2R5KTtcbiAgICAgIGlmIChib2R5ICYmIGRpZmZlcmVudEJvZHkpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGxlYWYgbm9kZSAoYW5kIGl0IGlzIG5vdCBzb3VyY2UgYm9keSksXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZm9yY2UgZXhlcnRlZCBieSB0aGUgY3VycmVudCBub2RlIG9uIGJvZHksIGFuZCBhZGQgdGhpc1xuICAgICAgICAvLyBhbW91bnQgdG8gYm9keSdzIG5ldCBmb3JjZS5cbiAgICAgICAgJHtwYXR0ZXJuKCdke3Zhcn0gPSBib2R5LnBvcy57dmFyfSAtIHNvdXJjZUJvZHkucG9zLnt2YXJ9OycsIHtpbmRlbnQ6IDh9KX1cbiAgICAgICAgciA9IE1hdGguc3FydCgke3BhdHRlcm4oJ2R7dmFyfSAqIGR7dmFyfScsIHtqb2luOiAnICsgJ30pfSk7XG5cbiAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAvLyBQb29yIG1hbidzIHByb3RlY3Rpb24gYWdhaW5zdCB6ZXJvIGRpc3RhbmNlLlxuICAgICAgICAgICR7cGF0dGVybignZHt2YXJ9ID0gKHJhbmRvbS5uZXh0RG91YmxlKCkgLSAwLjUpIC8gNTA7Jywge2luZGVudDogMTB9KX1cbiAgICAgICAgICByID0gTWF0aC5zcXJ0KCR7cGF0dGVybignZHt2YXJ9ICogZHt2YXJ9Jywge2pvaW46ICcgKyAnfSl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgc3RhbmRhcmQgZ3Jhdml0YXRpb24gZm9yY2UgY2FsY3VsYXRpb24gYnV0IHdlIGRpdmlkZVxuICAgICAgICAvLyBieSByXjMgdG8gc2F2ZSB0d28gb3BlcmF0aW9ucyB3aGVuIG5vcm1hbGl6aW5nIGZvcmNlIHZlY3Rvci5cbiAgICAgICAgdiA9IGdyYXZpdHkgKiBib2R5Lm1hc3MgKiBzb3VyY2VCb2R5Lm1hc3MgLyAociAqIHIgKiByKTtcbiAgICAgICAgJHtwYXR0ZXJuKCdme3Zhcn0gKz0gdiAqIGR7dmFyfTsnLCB7aW5kZW50OiA4fSl9XG4gICAgICB9IGVsc2UgaWYgKGRpZmZlcmVudEJvZHkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgdGhlIHJhdGlvIHMgLyByLCAgd2hlcmUgcyBpcyB0aGUgd2lkdGggb2YgdGhlIHJlZ2lvblxuICAgICAgICAvLyByZXByZXNlbnRlZCBieSB0aGUgaW50ZXJuYWwgbm9kZSwgYW5kIHIgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZHlcbiAgICAgICAgLy8gYW5kIHRoZSBub2RlJ3MgY2VudGVyLW9mLW1hc3NcbiAgICAgICAgJHtwYXR0ZXJuKCdke3Zhcn0gPSBub2RlLm1hc3Nfe3Zhcn0gLyBub2RlLm1hc3MgLSBzb3VyY2VCb2R5LnBvcy57dmFyfTsnLCB7aW5kZW50OiA4fSl9XG4gICAgICAgIHIgPSBNYXRoLnNxcnQoJHtwYXR0ZXJuKCdke3Zhcn0gKiBke3Zhcn0nLCB7am9pbjogJyArICd9KX0pO1xuXG4gICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgLy8gU29ycnkgYWJvdXQgY29kZSBkdXBsaWNhdGlvbi4gSSBkb24ndCB3YW50IHRvIGNyZWF0ZSBtYW55IGZ1bmN0aW9uc1xuICAgICAgICAgIC8vIHJpZ2h0IGF3YXkuIEp1c3Qgd2FudCB0byBzZWUgcGVyZm9ybWFuY2UgZmlyc3QuXG4gICAgICAgICAgJHtwYXR0ZXJuKCdke3Zhcn0gPSAocmFuZG9tLm5leHREb3VibGUoKSAtIDAuNSkgLyA1MDsnLCB7aW5kZW50OiAxMH0pfVxuICAgICAgICAgIHIgPSBNYXRoLnNxcnQoJHtwYXR0ZXJuKCdke3Zhcn0gKiBke3Zhcn0nLCB7am9pbjogJyArICd9KX0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHMgLyByIDwgzrgsIHRyZWF0IHRoaXMgaW50ZXJuYWwgbm9kZSBhcyBhIHNpbmdsZSBib2R5LCBhbmQgY2FsY3VsYXRlIHRoZVxuICAgICAgICAvLyBmb3JjZSBpdCBleGVydHMgb24gc291cmNlQm9keSwgYW5kIGFkZCB0aGlzIGFtb3VudCB0byBzb3VyY2VCb2R5J3MgbmV0IGZvcmNlLlxuICAgICAgICBpZiAoKG5vZGUubWF4XyR7Z2V0VmFyaWFibGVOYW1lKDApfSAtIG5vZGUubWluXyR7Z2V0VmFyaWFibGVOYW1lKDApfSkgLyByIDwgdGhldGEpIHtcbiAgICAgICAgICAvLyBpbiB0aGUgaWYgc3RhdGVtZW50IGFib3ZlIHdlIGNvbnNpZGVyIG5vZGUncyB3aWR0aCBvbmx5XG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgcmVnaW9uIHdhcyBtYWRlIGludG8gc3F1YXJlIGR1cmluZyB0cmVlIGNyZWF0aW9uLlxuICAgICAgICAgIC8vIFRodXMgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHVzaW5nIHdpZHRoIG9yIGhlaWdodC5cbiAgICAgICAgICB2ID0gZ3Jhdml0eSAqIG5vZGUubWFzcyAqIHNvdXJjZUJvZHkubWFzcyAvIChyICogciAqIHIpO1xuICAgICAgICAgICR7cGF0dGVybignZnt2YXJ9ICs9IHYgKiBke3Zhcn07Jywge2luZGVudDogMTB9KX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHJ1biB0aGUgcHJvY2VkdXJlIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlIGN1cnJlbnQgbm9kZSdzIGNoaWxkcmVuLlxuXG4gICAgICAgICAgLy8gSSBpbnRlbnRpb25hbGx5IHVuZm9sZGVkIHRoaXMgbG9vcCwgdG8gc2F2ZSBzZXZlcmFsIENQVSBjeWNsZXMuXG4ke3J1blJlY3Vyc2l2ZU9uQ2hpbGRyZW4oKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICR7cGF0dGVybignc291cmNlQm9keS5mb3JjZS57dmFyfSArPSBme3Zhcn07Jywge2luZGVudDogNH0pfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Qm9kaWVzKGJvZGllcykge1xuICAgICR7cGF0dGVybigndmFyIHt2YXJ9bWluID0gTnVtYmVyLk1BWF9WQUxVRTsnLCB7aW5kZW50OiA0fSl9XG4gICAgJHtwYXR0ZXJuKCd2YXIge3Zhcn1tYXggPSBOdW1iZXIuTUlOX1ZBTFVFOycsIHtpbmRlbnQ6IDR9KX1cbiAgICB2YXIgaSA9IGJvZGllcy5sZW5ndGg7XG5cbiAgICAvLyBUbyByZWR1Y2UgcXVhZCB0cmVlIGRlcHRoIHdlIGFyZSBsb29raW5nIGZvciBleGFjdCBib3VuZGluZyBib3ggb2YgYWxsIHBhcnRpY2xlcy5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgcG9zID0gYm9kaWVzW2ldLnBvcztcbiAgICAgICR7cGF0dGVybignaWYgKHBvcy57dmFyfSA8IHt2YXJ9bWluKSB7dmFyfW1pbiA9IHBvcy57dmFyfTsnLCB7aW5kZW50OiA2fSl9XG4gICAgICAke3BhdHRlcm4oJ2lmIChwb3Mue3Zhcn0gPiB7dmFyfW1heCkge3Zhcn1tYXggPSBwb3Mue3Zhcn07Jywge2luZGVudDogNn0pfVxuICAgIH1cblxuICAgIC8vIE1ha2VzIHRoZSBib3VuZHMgc3F1YXJlLlxuICAgIHZhciBtYXhTaWRlTGVuZ3RoID0gLUluZmluaXR5O1xuICAgICR7cGF0dGVybignaWYgKHt2YXJ9bWF4IC0ge3Zhcn1taW4gPiBtYXhTaWRlTGVuZ3RoKSBtYXhTaWRlTGVuZ3RoID0ge3Zhcn1tYXggLSB7dmFyfW1pbiA7Jywge2luZGVudDogNH0pfVxuXG4gICAgY3VycmVudEluQ2FjaGUgPSAwO1xuICAgIHJvb3QgPSBuZXdOb2RlKCk7XG4gICAgJHtwYXR0ZXJuKCdyb290Lm1pbl97dmFyfSA9IHt2YXJ9bWluOycsIHtpbmRlbnQ6IDR9KX1cbiAgICAke3BhdHRlcm4oJ3Jvb3QubWF4X3t2YXJ9ID0ge3Zhcn1taW4gKyBtYXhTaWRlTGVuZ3RoOycsIHtpbmRlbnQ6IDR9KX1cblxuICAgIGkgPSBib2RpZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICByb290LmJvZHkgPSBib2RpZXNbaV07XG4gICAgfVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGluc2VydChib2RpZXNbaV0sIHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydChuZXdCb2R5KSB7XG4gICAgaW5zZXJ0U3RhY2sucmVzZXQoKTtcbiAgICBpbnNlcnRTdGFjay5wdXNoKHJvb3QsIG5ld0JvZHkpO1xuXG4gICAgd2hpbGUgKCFpbnNlcnRTdGFjay5pc0VtcHR5KCkpIHtcbiAgICAgIHZhciBzdGFja0l0ZW0gPSBpbnNlcnRTdGFjay5wb3AoKTtcbiAgICAgIHZhciBub2RlID0gc3RhY2tJdGVtLm5vZGU7XG4gICAgICB2YXIgYm9keSA9IHN0YWNrSXRlbS5ib2R5O1xuXG4gICAgICBpZiAoIW5vZGUuYm9keSkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVybmFsIG5vZGUuIFVwZGF0ZSB0aGUgdG90YWwgbWFzcyBvZiB0aGUgbm9kZSBhbmQgY2VudGVyLW9mLW1hc3MuXG4gICAgICAgICR7cGF0dGVybigndmFyIHt2YXJ9ID0gYm9keS5wb3Mue3Zhcn07Jywge2luZGVudDogOH0pfVxuICAgICAgICBub2RlLm1hc3MgKz0gYm9keS5tYXNzO1xuICAgICAgICAke3BhdHRlcm4oJ25vZGUubWFzc197dmFyfSArPSBib2R5Lm1hc3MgKiB7dmFyfTsnLCB7aW5kZW50OiA4fSl9XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IHRoZSBib2R5IGluIHRoZSBhcHByb3ByaWF0ZSBxdWFkcmFudC5cbiAgICAgICAgLy8gQnV0IGZpcnN0IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHF1YWRyYW50LlxuICAgICAgICB2YXIgcXVhZElkeCA9IDA7IC8vIEFzc3VtZSB3ZSBhcmUgaW4gdGhlIDAncyBxdWFkLlxuICAgICAgICAke3BhdHRlcm4oJ3ZhciBtaW5fe3Zhcn0gPSBub2RlLm1pbl97dmFyfTsnLCB7aW5kZW50OiA4fSl9XG4gICAgICAgICR7cGF0dGVybigndmFyIG1heF97dmFyfSA9IChtaW5fe3Zhcn0gKyBub2RlLm1heF97dmFyfSkgLyAyOycsIHtpbmRlbnQ6IDh9KX1cblxuJHthc3NpZ25JbnNlcnRpb25RdWFkSW5kZXgoOCl9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZ2V0Q2hpbGQobm9kZSwgcXVhZElkeCk7XG5cbiAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgIC8vIFRoZSBub2RlIGlzIGludGVybmFsIGJ1dCB0aGlzIHF1YWRyYW50IGlzIG5vdCB0YWtlbi4gQWRkXG4gICAgICAgICAgLy8gc3Vibm9kZSB0byBpdC5cbiAgICAgICAgICBjaGlsZCA9IG5ld05vZGUoKTtcbiAgICAgICAgICAke3BhdHRlcm4oJ2NoaWxkLm1pbl97dmFyfSA9IG1pbl97dmFyfTsnLCB7aW5kZW50OiAxMH0pfVxuICAgICAgICAgICR7cGF0dGVybignY2hpbGQubWF4X3t2YXJ9ID0gbWF4X3t2YXJ9OycsIHtpbmRlbnQ6IDEwfSl9XG4gICAgICAgICAgY2hpbGQuYm9keSA9IGJvZHk7XG5cbiAgICAgICAgICBzZXRDaGlsZChub2RlLCBxdWFkSWR4LCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29udGludWUgc2VhcmNoaW5nIGluIHRoaXMgcXVhZHJhbnQuXG4gICAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChjaGlsZCwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gYWRkIHRvIHRoZSBsZWFmIG5vZGUuXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gY29udmVydCBjdXJyZW50IGxlYWYgaW50byBpbnRlcm5hbCBub2RlXG4gICAgICAgIC8vIGFuZCBjb250aW51ZSBhZGRpbmcgdHdvIG5vZGVzLlxuICAgICAgICB2YXIgb2xkQm9keSA9IG5vZGUuYm9keTtcbiAgICAgICAgbm9kZS5ib2R5ID0gbnVsbDsgLy8gaW50ZXJuYWwgbm9kZXMgZG8gbm90IGNhcnkgYm9kaWVzXG5cbiAgICAgICAgaWYgKGlzU2FtZVBvc2l0aW9uKG9sZEJvZHkucG9zLCBib2R5LnBvcykpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIHN1YmRpdmlzaW9uIGJ5IGJ1bXBpbmcgb25lIG5vZGVcbiAgICAgICAgICAvLyBhbnl3aGVyZSBpbiB0aGlzIHF1YWRyYW50XG4gICAgICAgICAgdmFyIHJldHJpZXNDb3VudCA9IDM7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJhbmRvbS5uZXh0RG91YmxlKCk7XG4gICAgICAgICAgICAke3BhdHRlcm4oJ3ZhciBke3Zhcn0gPSAobm9kZS5tYXhfe3Zhcn0gLSBub2RlLm1pbl97dmFyfSkgKiBvZmZzZXQ7Jywge2luZGVudDogMTJ9KX1cblxuICAgICAgICAgICAgJHtwYXR0ZXJuKCdvbGRCb2R5LnBvcy57dmFyfSA9IG5vZGUubWluX3t2YXJ9ICsgZHt2YXJ9OycsIHtpbmRlbnQ6IDEyfSl9XG4gICAgICAgICAgICByZXRyaWVzQ291bnQgLT0gMTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBidW1wIGl0IG91dCBvZiB0aGUgYm94LiBJZiB3ZSBkbywgbmV4dCBpdGVyYXRpb24gc2hvdWxkIGZpeCBpdFxuICAgICAgICAgIH0gd2hpbGUgKHJldHJpZXNDb3VudCA+IDAgJiYgaXNTYW1lUG9zaXRpb24ob2xkQm9keS5wb3MsIGJvZHkucG9zKSk7XG5cbiAgICAgICAgICBpZiAocmV0cmllc0NvdW50ID09PSAwICYmIGlzU2FtZVBvc2l0aW9uKG9sZEJvZHkucG9zLCBib2R5LnBvcykpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdmVyeSBiYWQsIHdlIHJhbiBvdXQgb2YgcHJlY2lzaW9uLlxuICAgICAgICAgICAgLy8gaWYgd2UgZG8gbm90IHJldHVybiBmcm9tIHRoZSBtZXRob2Qgd2UnbGwgZ2V0IGludG9cbiAgICAgICAgICAgIC8vIGluZmluaXRlIGxvb3AgaGVyZS4gU28gd2Ugc2FjcmlmaWNlIGNvcnJlY3RuZXNzIG9mIGxheW91dCwgYW5kIGtlZXAgdGhlIGFwcCBydW5uaW5nXG4gICAgICAgICAgICAvLyBOZXh0IGxheW91dCBpdGVyYXRpb24gc2hvdWxkIGdldCBsYXJnZXIgYm91bmRpbmcgYm94IGluIHRoZSBmaXJzdCBzdGVwIGFuZCBmaXggdGhpc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvbiBzaG91bGQgc3ViZGl2aWRlIG5vZGUgZnVydGhlci5cbiAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChub2RlLCBvbGRCb2R5KTtcbiAgICAgICAgaW5zZXJ0U3RhY2sucHVzaChub2RlLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnJldHVybiBjcmVhdGVRdWFkVHJlZTtcblxuYDtcbiAgcmV0dXJuIGNvZGU7XG5cblxuICBmdW5jdGlvbiBhc3NpZ25JbnNlcnRpb25RdWFkSW5kZXgoaW5kZW50Q291bnQpIHtcbiAgICBsZXQgaW5zZXJ0aW9uQ29kZSA9IFtdO1xuICAgIGxldCBpbmRlbnQgPSBBcnJheShpbmRlbnRDb3VudCArIDEpLmpvaW4oJyAnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBpbnNlcnRpb25Db2RlLnB1c2goaW5kZW50ICsgYGlmICgke2dldFZhcmlhYmxlTmFtZShpKX0gPiBtYXhfJHtnZXRWYXJpYWJsZU5hbWUoaSl9KSB7YCk7XG4gICAgICBpbnNlcnRpb25Db2RlLnB1c2goaW5kZW50ICsgYCAgcXVhZElkeCA9IHF1YWRJZHggKyAke01hdGgucG93KDIsIGkpfTtgKTtcbiAgICAgIGluc2VydGlvbkNvZGUucHVzaChpbmRlbnQgKyBgICBtaW5fJHtnZXRWYXJpYWJsZU5hbWUoaSl9ID0gbWF4XyR7Z2V0VmFyaWFibGVOYW1lKGkpfTtgKTtcbiAgICAgIGluc2VydGlvbkNvZGUucHVzaChpbmRlbnQgKyBgICBtYXhfJHtnZXRWYXJpYWJsZU5hbWUoaSl9ID0gbm9kZS5tYXhfJHtnZXRWYXJpYWJsZU5hbWUoaSl9O2ApO1xuICAgICAgaW5zZXJ0aW9uQ29kZS5wdXNoKGluZGVudCArIGB9YCk7XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnRpb25Db2RlLmpvaW4oJ1xcbicpO1xuICAgIC8vIGlmICh4ID4gbWF4X3gpIHsgLy8gc29tZXdoZXJlIGluIHRoZSBlYXN0ZXJuIHBhcnQuXG4gICAgLy8gICBxdWFkSWR4ID0gcXVhZElkeCArIDE7XG4gICAgLy8gICBsZWZ0ID0gcmlnaHQ7XG4gICAgLy8gICByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgLy8gfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuUmVjdXJzaXZlT25DaGlsZHJlbigpIHtcbiAgICBsZXQgaW5kZW50ID0gQXJyYXkoMTEpLmpvaW4oJyAnKTtcbiAgICBsZXQgcmVjdXJzaXZlQ29kZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZENvdW50OyArK2kpIHtcbiAgICAgIHJlY3Vyc2l2ZUNvZGUucHVzaChpbmRlbnQgKyBgaWYgKG5vZGUucXVhZCR7aX0pIHtgKTtcbiAgICAgIHJlY3Vyc2l2ZUNvZGUucHVzaChpbmRlbnQgKyBgICBxdWV1ZVtwdXNoSWR4XSA9IG5vZGUucXVhZCR7aX07YCk7XG4gICAgICByZWN1cnNpdmVDb2RlLnB1c2goaW5kZW50ICsgYCAgcXVldWVMZW5ndGggKz0gMTtgKTtcbiAgICAgIHJlY3Vyc2l2ZUNvZGUucHVzaChpbmRlbnQgKyBgICBwdXNoSWR4ICs9IDE7YCk7XG4gICAgICByZWN1cnNpdmVDb2RlLnB1c2goaW5kZW50ICsgYH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Vyc2l2ZUNvZGUuam9pbignXFxuJyk7XG4gICAgLy8gaWYgKG5vZGUucXVhZDApIHtcbiAgICAvLyAgIHF1ZXVlW3B1c2hJZHhdID0gbm9kZS5xdWFkMDtcbiAgICAvLyAgIHF1ZXVlTGVuZ3RoICs9IDE7XG4gICAgLy8gICBwdXNoSWR4ICs9IDE7XG4gICAgLy8gfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduUXVhZHMoaW5kZW50KSB7XG4gICAgLy8gdGhpcy5xdWFkMCA9IG51bGw7XG4gICAgLy8gdGhpcy5xdWFkMSA9IG51bGw7XG4gICAgLy8gdGhpcy5xdWFkMiA9IG51bGw7XG4gICAgLy8gdGhpcy5xdWFkMyA9IG51bGw7XG4gICAgbGV0IHF1YWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFkQ291bnQ7ICsraSkge1xuICAgICAgcXVhZHMucHVzaChgJHtpbmRlbnR9cXVhZCR7aX0gPSBudWxsO2ApO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZHMuam9pbignXFxuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24oZGltZW5zaW9uKSB7XG4gIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybkJ1aWxkZXIoZGltZW5zaW9uKTtcbiAgcmV0dXJuIGBcbiAgZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24ocG9pbnQxLCBwb2ludDIpIHtcbiAgICAke3BhdHRlcm4oJ3ZhciBke3Zhcn0gPSBNYXRoLmFicyhwb2ludDEue3Zhcn0gLSBwb2ludDIue3Zhcn0pOycsIHtpbmRlbnQ6IDJ9KX1cbiAgXG4gICAgcmV0dXJuICR7cGF0dGVybignZHt2YXJ9IDwgMWUtOCcsIHtqb2luOiAnICYmICd9KX07XG4gIH0gIFxuYDtcbn1cblxuZnVuY3Rpb24gc2V0Q2hpbGRCb2R5Q29kZShkaW1lbnNpb24pIHtcbiAgdmFyIHF1YWRDb3VudCA9IE1hdGgucG93KDIsIGRpbWVuc2lvbik7XG4gIHJldHVybiBgXG5mdW5jdGlvbiBzZXRDaGlsZChub2RlLCBpZHgsIGNoaWxkKSB7XG4gICR7c2V0Q2hpbGRCb2R5KCl9XG59YDtcbiAgZnVuY3Rpb24gc2V0Q2hpbGRCb2R5KCkge1xuICAgIGxldCBjaGlsZEJvZHkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRDb3VudDsgKytpKSB7XG4gICAgICBsZXQgcHJlZml4ID0gKGkgPT09IDApID8gJyAgJyA6ICcgIGVsc2UgJztcbiAgICAgIGNoaWxkQm9keS5wdXNoKGAke3ByZWZpeH1pZiAoaWR4ID09PSAke2l9KSBub2RlLnF1YWQke2l9ID0gY2hpbGQ7YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkQm9keS5qb2luKCdcXG4nKTtcbiAgICAvLyBpZiAoaWR4ID09PSAwKSBub2RlLnF1YWQwID0gY2hpbGQ7XG4gICAgLy8gZWxzZSBpZiAoaWR4ID09PSAxKSBub2RlLnF1YWQxID0gY2hpbGQ7XG4gICAgLy8gZWxzZSBpZiAoaWR4ID09PSAyKSBub2RlLnF1YWQyID0gY2hpbGQ7XG4gICAgLy8gZWxzZSBpZiAoaWR4ID09PSAzKSBub2RlLnF1YWQzID0gY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRCb2R5Q29kZShkaW1lbnNpb24pIHtcbiAgcmV0dXJuIGBmdW5jdGlvbiBnZXRDaGlsZChub2RlLCBpZHgpIHtcbiR7Z2V0Q2hpbGRCb2R5KCl9XG4gIHJldHVybiBudWxsO1xufWA7XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRCb2R5KCkge1xuICAgIGxldCBjaGlsZEJvZHkgPSBbXTtcbiAgICBsZXQgcXVhZENvdW50ID0gTWF0aC5wb3coMiwgZGltZW5zaW9uKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRDb3VudDsgKytpKSB7XG4gICAgICBjaGlsZEJvZHkucHVzaChgICBpZiAoaWR4ID09PSAke2l9KSByZXR1cm4gbm9kZS5xdWFkJHtpfTtgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRCb2R5LmpvaW4oJ1xcbicpO1xuICAgIC8vIGlmIChpZHggPT09IDApIHJldHVybiBub2RlLnF1YWQwO1xuICAgIC8vIGlmIChpZHggPT09IDEpIHJldHVybiBub2RlLnF1YWQxO1xuICAgIC8vIGlmIChpZHggPT09IDIpIHJldHVybiBub2RlLnF1YWQyO1xuICAgIC8vIGlmIChpZHggPT09IDMpIHJldHVybiBub2RlLnF1YWQzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFF1YWROb2RlQ29kZShkaW1lbnNpb24pIHtcbiAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuQnVpbGRlcihkaW1lbnNpb24pO1xuICBsZXQgcXVhZENvdW50ID0gTWF0aC5wb3coMiwgZGltZW5zaW9uKTtcbiAgdmFyIHF1YWROb2RlQ29kZSA9IGBcbmZ1bmN0aW9uIFF1YWROb2RlKCkge1xuICAvLyBib2R5IHN0b3JlZCBpbnNpZGUgdGhpcyBub2RlLiBJbiBxdWFkIHRyZWUgb25seSBsZWFmIG5vZGVzIChieSBjb25zdHJ1Y3Rpb24pXG4gIC8vIGNvbnRhaW4gYm9kaWVzOlxuICB0aGlzLmJvZHkgPSBudWxsO1xuXG4gIC8vIENoaWxkIG5vZGVzIGFyZSBzdG9yZWQgaW4gcXVhZHMuIEVhY2ggcXVhZCBpcyBwcmVzZW50ZWQgYnkgbnVtYmVyOlxuICAvLyAwIHwgMVxuICAvLyAtLS0tLVxuICAvLyAyIHwgM1xuJHthc3NpZ25RdWFkcygnICB0aGlzLicpfVxuXG4gIC8vIFRvdGFsIG1hc3Mgb2YgY3VycmVudCBub2RlXG4gIHRoaXMubWFzcyA9IDA7XG5cbiAgLy8gQ2VudGVyIG9mIG1hc3MgY29vcmRpbmF0ZXNcbiAgJHtwYXR0ZXJuKCd0aGlzLm1hc3Nfe3Zhcn0gPSAwOycsIHtpbmRlbnQ6IDJ9KX1cblxuICAvLyBib3VuZGluZyBib3ggY29vcmRpbmF0ZXNcbiAgJHtwYXR0ZXJuKCd0aGlzLm1pbl97dmFyfSA9IDA7Jywge2luZGVudDogMn0pfVxuICAke3BhdHRlcm4oJ3RoaXMubWF4X3t2YXJ9ID0gMDsnLCB7aW5kZW50OiAyfSl9XG59XG5gO1xuICByZXR1cm4gcXVhZE5vZGVDb2RlO1xuXG4gIGZ1bmN0aW9uIGFzc2lnblF1YWRzKGluZGVudCkge1xuICAgIC8vIHRoaXMucXVhZDAgPSBudWxsO1xuICAgIC8vIHRoaXMucXVhZDEgPSBudWxsO1xuICAgIC8vIHRoaXMucXVhZDIgPSBudWxsO1xuICAgIC8vIHRoaXMucXVhZDMgPSBudWxsO1xuICAgIGxldCBxdWFkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZENvdW50OyArK2kpIHtcbiAgICAgIHF1YWRzLnB1c2goYCR7aW5kZW50fXF1YWQke2l9ID0gbnVsbDtgKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRzLmpvaW4oJ1xcbicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEluc2VydFN0YWNrQ29kZSgpIHtcbiAgcmV0dXJuIGBcbi8qKlxuICogT3VyIGltcGxlbWVudGF0aW9uIG9mIFF1YWRUcmVlIGlzIG5vbi1yZWN1cnNpdmUgdG8gYXZvaWQgR0MgaGl0XG4gKiBUaGlzIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudCBzdGFjayBvZiBlbGVtZW50c1xuICogd2hpY2ggd2UgYXJlIHRyeWluZyB0byBpbnNlcnQgaW50byBxdWFkIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIEluc2VydFN0YWNrICgpIHtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5wb3BJZHggPSAwO1xufVxuXG5JbnNlcnRTdGFjay5wcm90b3R5cGUgPSB7XG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcElkeCA9PT0gMDtcbiAgICB9LFxuICAgIHB1c2g6IGZ1bmN0aW9uIChub2RlLCBib2R5KSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5zdGFja1t0aGlzLnBvcElkeF07XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIHRyeWluZyB0byBhdm9pZCBtZW1vcnkgcHJlc3N1cmU6IGNyZWF0ZSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgLy8gb25seSB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMucG9wSWR4XSA9IG5ldyBJbnNlcnRTdGFja0VsZW1lbnQobm9kZSwgYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaXRlbS5ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMucG9wSWR4O1xuICAgIH0sXG4gICAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcElkeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrWy0tdGhpcy5wb3BJZHhdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvcElkeCA9IDA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gSW5zZXJ0U3RhY2tFbGVtZW50KG5vZGUsIGJvZHkpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlOyAvLyBRdWFkVHJlZSBub2RlXG4gICAgdGhpcy5ib2R5ID0gYm9keTsgLy8gcGh5c2ljYWwgYm9keSB3aGljaCBuZWVkcyB0byBiZSBpbnNlcnRlZCB0byBub2RlXG59XG5gO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js ***!
  \*******************************************************************************/
/***/ ((module) => {

eval("module.exports = function getVariableName(index) {\n  if (index === 0) return 'x';\n  if (index === 1) return 'y';\n  if (index === 2) return 'z';\n  return 'c' + (index + 1);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jb2RlR2VuZXJhdG9ycy9nZXRWYXJpYWJsZU5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pY2hhXFxEb3dubG9hZHNcXHpvdWJrb2Zmc2l0ZVxccGVyc29uYWxzaXRlXFxub2RlX21vZHVsZXNcXG5ncmFwaC5mb3JjZWxheW91dFxcbGliXFxjb2RlR2VuZXJhdG9yc1xcZ2V0VmFyaWFibGVOYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0VmFyaWFibGVOYW1lKGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuICd4JztcbiAgaWYgKGluZGV4ID09PSAxKSByZXR1cm4gJ3knO1xuICBpZiAoaW5kZXggPT09IDIpIHJldHVybiAneic7XG4gIHJldHVybiAnYycgKyAoaW5kZXggKyAxKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = createPhysicsSimulator;\n\nvar generateCreateBodyFunction = __webpack_require__(/*! ./codeGenerators/generateCreateBody */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js\");\nvar generateQuadTreeFunction = __webpack_require__(/*! ./codeGenerators/generateQuadTree */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js\");\nvar generateBoundsFunction = __webpack_require__(/*! ./codeGenerators/generateBounds */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js\");\nvar generateCreateDragForceFunction = __webpack_require__(/*! ./codeGenerators/generateCreateDragForce */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js\");\nvar generateCreateSpringForceFunction = __webpack_require__(/*! ./codeGenerators/generateCreateSpringForce */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js\");\nvar generateIntegratorFunction = __webpack_require__(/*! ./codeGenerators/generateIntegrator */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js\");\n\nvar dimensionalCache = {};\n\nfunction createPhysicsSimulator(settings) {\n  var Spring = __webpack_require__(/*! ./spring */ \"(ssr)/./node_modules/ngraph.forcelayout/lib/spring.js\");\n  var merge = __webpack_require__(/*! ngraph.merge */ \"(ssr)/./node_modules/ngraph.merge/index.js\");\n  var eventify = __webpack_require__(/*! ngraph.events */ \"(ssr)/./node_modules/ngraph.events/index.js\");\n  if (settings) {\n    // Check for names from older versions of the layout\n    if (settings.springCoeff !== undefined) throw new Error('springCoeff was renamed to springCoefficient');\n    if (settings.dragCoeff !== undefined) throw new Error('dragCoeff was renamed to dragCoefficient');\n  }\n\n  settings = merge(settings, {\n      /**\n       * Ideal length for links (springs in physical model).\n       */\n      springLength: 10,\n\n      /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n      springCoefficient: 0.8, \n\n      /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n      gravity: -12,\n\n      /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n      theta: 0.8,\n\n      /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n      dragCoefficient: 0.9, // TODO: Need to rename this to something better. E.g. `dragCoefficient`\n\n      /**\n       * Default time step (dt) for forces integration\n       */\n      timeStep : 0.5,\n\n      /**\n       * Adaptive time step uses average spring length to compute actual time step:\n       * See: https://twitter.com/anvaka/status/1293067160755957760\n       */\n      adaptiveTimeStepWeight: 0,\n\n      /**\n       * This parameter defines number of dimensions of the space where simulation\n       * is performed. \n       */\n      dimensions: 2,\n\n      /**\n       * In debug mode more checks are performed, this will help you catch errors\n       * quickly, however for production build it is recommended to turn off this flag\n       * to speed up computation.\n       */\n      debug: false\n  });\n\n  var factory = dimensionalCache[settings.dimensions];\n  if (!factory) {\n    var dimensions = settings.dimensions;\n    factory = {\n      Body: generateCreateBodyFunction(dimensions, settings.debug),\n      createQuadTree: generateQuadTreeFunction(dimensions),\n      createBounds: generateBoundsFunction(dimensions),\n      createDragForce: generateCreateDragForceFunction(dimensions),\n      createSpringForce: generateCreateSpringForceFunction(dimensions),\n      integrate: generateIntegratorFunction(dimensions),\n    };\n    dimensionalCache[dimensions] = factory;\n  }\n\n  var Body = factory.Body;\n  var createQuadTree = factory.createQuadTree;\n  var createBounds = factory.createBounds;\n  var createDragForce = factory.createDragForce;\n  var createSpringForce = factory.createSpringForce;\n  var integrate = factory.integrate;\n  var createBody = pos => new Body(pos);\n\n  var random = (__webpack_require__(/*! ngraph.random */ \"(ssr)/./node_modules/ngraph.random/index.js\").random)(42);\n  var bodies = []; // Bodies in this simulation.\n  var springs = []; // Springs in this simulation.\n\n  var quadTree = createQuadTree(settings, random);\n  var bounds = createBounds(bodies, settings, random);\n  var springForce = createSpringForce(settings, random);\n  var dragForce = createDragForce(settings);\n\n  var totalMovement = 0; // how much movement we made on last step\n  var forces = [];\n  var forceMap = new Map();\n  var iterationNumber = 0;\n \n  addForce('nbody', nbodyForce);\n  addForce('spring', updateSpringForce);\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n  \n    quadTree: quadTree,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Adds a new force to simulation\n     */\n    addForce: addForce,\n    \n    /**\n     * Removes a force from the simulation.\n     */\n    removeForce: removeForce,\n\n    /**\n     * Returns a map of all registered forces.\n     */\n    getForces: getForces,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      for (var i = 0; i < forces.length; ++i) {\n        forces[i](iterationNumber);\n      }\n      var movement = integrate(bodies, settings.timeStep, settings.adaptiveTimeStepWeight);\n      iterationNumber += 1;\n      return movement;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n      var body = createBody(pos);\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) { return; }\n\n      var idx = bodies.indexOf(body);\n      if (idx < 0) { return; }\n\n      bodies.splice(idx, 1);\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);\n      springs.push(spring);\n\n      // TODO: could mark simulator as dirty.\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) { return; }\n      var idx = springs.indexOf(spring);\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: getBoundingBox, \n    getBoundingBox: getBoundingBox, \n\n    invalidateBBox: function () {\n      console.warn('invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call');\n    },\n\n    // TODO: Move the force specific stuff to force\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({gravity: value});\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({theta: value});\n        return this;\n      } else {\n        return settings.theta;\n      }\n    },\n\n    /**\n     * Returns pseudo-random number generator instance.\n     */\n    random: random\n  };\n\n  // allow settings modification via public API:\n  expose(settings, publicApi);\n\n  eventify(publicApi);\n\n  return publicApi;\n\n  function getBoundingBox() {\n    bounds.update();\n    return bounds.box;\n  }\n\n  function addForce(forceName, forceFunction) {\n    if (forceMap.has(forceName)) throw new Error('Force ' + forceName + ' is already added');\n\n    forceMap.set(forceName, forceFunction);\n    forces.push(forceFunction);\n  }\n\n  function removeForce(forceName) {\n    var forceIndex = forces.indexOf(forceMap.get(forceName));\n    if (forceIndex < 0) return;\n    forces.splice(forceIndex, 1);\n    forceMap.delete(forceName);\n  }\n\n  function getForces() {\n    // TODO: Should I trust them or clone the forces?\n    return forceMap;\n  }\n\n  function nbodyForce(/* iterationUmber */) {\n    if (bodies.length === 0) return;\n\n    quadTree.insertBodies(bodies);\n    var i = bodies.length;\n    while (i--) {\n      var body = bodies[i];\n      if (!body.isPinned) {\n        body.reset();\n        quadTree.updateBodyForce(body);\n        dragForce.update(body);\n      }\n    }\n  }\n\n  function updateSpringForce() {\n    var i = springs.length;\n    while (i--) {\n      springForce.update(springs[i]);\n    }\n  }\n\n}\n\nfunction expose(settings, target) {\n  for (var key in settings) {\n    augment(settings, target, key);\n  }\n}\n\nfunction augment(source, target, key) {\n  if (!source.hasOwnProperty(key)) return;\n  if (typeof target[key] === 'function') {\n    // this accessor is already defined. Ignore it\n    return;\n  }\n  var sourceIsNumber = Number.isFinite(source[key]);\n\n  if (sourceIsNumber) {\n    target[key] = function (value) {\n      if (value !== undefined) {\n        if (!Number.isFinite(value)) throw new Error('Value of ' + key + ' should be a valid number.');\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    };\n  } else {\n    target[key] = function (value) {\n      if (value !== undefined) {\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9jcmVhdGVQaHlzaWNzU2ltdWxhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBTyxDQUFDLDZIQUFxQztBQUM5RSwrQkFBK0IsbUJBQU8sQ0FBQyx5SEFBbUM7QUFDMUUsNkJBQTZCLG1CQUFPLENBQUMscUhBQWlDO0FBQ3RFLHNDQUFzQyxtQkFBTyxDQUFDLHVJQUEwQztBQUN4Rix3Q0FBd0MsbUJBQU8sQ0FBQywySUFBNEM7QUFDNUYsaUNBQWlDLG1CQUFPLENBQUMsNkhBQXFDOztBQUU5RTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsZ0VBQWM7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsa0VBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGdHQUErQjtBQUM5QyxtQkFBbUI7QUFDbkIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUyxxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWNoYVxcRG93bmxvYWRzXFx6b3Via29mZnNpdGVcXHBlcnNvbmFsc2l0ZVxcbm9kZV9tb2R1bGVzXFxuZ3JhcGguZm9yY2VsYXlvdXRcXGxpYlxcY3JlYXRlUGh5c2ljc1NpbXVsYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1hbmFnZXMgYSBzaW11bGF0aW9uIG9mIHBoeXNpY2FsIGZvcmNlcyBhY3Rpbmcgb24gYm9kaWVzIGFuZCBzcHJpbmdzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBoeXNpY3NTaW11bGF0b3I7XG5cbnZhciBnZW5lcmF0ZUNyZWF0ZUJvZHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY29kZUdlbmVyYXRvcnMvZ2VuZXJhdGVDcmVhdGVCb2R5Jyk7XG52YXIgZ2VuZXJhdGVRdWFkVHJlZUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZVF1YWRUcmVlJyk7XG52YXIgZ2VuZXJhdGVCb3VuZHNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY29kZUdlbmVyYXRvcnMvZ2VuZXJhdGVCb3VuZHMnKTtcbnZhciBnZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZScpO1xudmFyIGdlbmVyYXRlQ3JlYXRlU3ByaW5nRm9yY2VGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY29kZUdlbmVyYXRvcnMvZ2VuZXJhdGVDcmVhdGVTcHJpbmdGb3JjZScpO1xudmFyIGdlbmVyYXRlSW50ZWdyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jb2RlR2VuZXJhdG9ycy9nZW5lcmF0ZUludGVncmF0b3InKTtcblxudmFyIGRpbWVuc2lvbmFsQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlUGh5c2ljc1NpbXVsYXRvcihzZXR0aW5ncykge1xuICB2YXIgU3ByaW5nID0gcmVxdWlyZSgnLi9zcHJpbmcnKTtcbiAgdmFyIG1lcmdlID0gcmVxdWlyZSgnbmdyYXBoLm1lcmdlJyk7XG4gIHZhciBldmVudGlmeSA9IHJlcXVpcmUoJ25ncmFwaC5ldmVudHMnKTtcbiAgaWYgKHNldHRpbmdzKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG5hbWVzIGZyb20gb2xkZXIgdmVyc2lvbnMgb2YgdGhlIGxheW91dFxuICAgIGlmIChzZXR0aW5ncy5zcHJpbmdDb2VmZiAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ3NwcmluZ0NvZWZmIHdhcyByZW5hbWVkIHRvIHNwcmluZ0NvZWZmaWNpZW50Jyk7XG4gICAgaWYgKHNldHRpbmdzLmRyYWdDb2VmZiAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2RyYWdDb2VmZiB3YXMgcmVuYW1lZCB0byBkcmFnQ29lZmZpY2llbnQnKTtcbiAgfVxuXG4gIHNldHRpbmdzID0gbWVyZ2Uoc2V0dGluZ3MsIHtcbiAgICAgIC8qKlxuICAgICAgICogSWRlYWwgbGVuZ3RoIGZvciBsaW5rcyAoc3ByaW5ncyBpbiBwaHlzaWNhbCBtb2RlbCkuXG4gICAgICAgKi9cbiAgICAgIHNwcmluZ0xlbmd0aDogMTAsXG5cbiAgICAgIC8qKlxuICAgICAgICogSG9vaydzIGxhdyBjb2VmZmljaWVudC4gMSAtIHNvbGlkIHNwcmluZy5cbiAgICAgICAqL1xuICAgICAgc3ByaW5nQ29lZmZpY2llbnQ6IDAuOCwgXG5cbiAgICAgIC8qKlxuICAgICAgICogQ291bG9tYidzIGxhdyBjb2VmZmljaWVudC4gSXQncyB1c2VkIHRvIHJlcGVsIG5vZGVzIHRodXMgc2hvdWxkIGJlIG5lZ2F0aXZlXG4gICAgICAgKiBpZiB5b3UgbWFrZSBpdCBwb3NpdGl2ZSBub2RlcyBzdGFydCBhdHRyYWN0IGVhY2ggb3RoZXIgOikuXG4gICAgICAgKi9cbiAgICAgIGdyYXZpdHk6IC0xMixcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGV0YSBjb2VmZmljaWVudCBmcm9tIEJhcm5lcyBIdXQgc2ltdWxhdGlvbi4gUmFuZ2VkIGJldHdlZW4gKDAsIDEpLlxuICAgICAgICogVGhlIGNsb3NlciBpdCdzIHRvIDEgdGhlIG1vcmUgbm9kZXMgYWxnb3JpdGhtIHdpbGwgaGF2ZSB0byBnbyB0aHJvdWdoLlxuICAgICAgICogU2V0dGluZyBpdCB0byBvbmUgbWFrZXMgQmFybmVzIEh1dCBzaW11bGF0aW9uIG5vIGRpZmZlcmVudCBmcm9tXG4gICAgICAgKiBicnV0ZS1mb3JjZSBmb3JjZXMgY2FsY3VsYXRpb24gKGVhY2ggbm9kZSBpcyBjb25zaWRlcmVkKS5cbiAgICAgICAqL1xuICAgICAgdGhldGE6IDAuOCxcblxuICAgICAgLyoqXG4gICAgICAgKiBEcmFnIGZvcmNlIGNvZWZmaWNpZW50LiBVc2VkIHRvIHNsb3cgZG93biBzeXN0ZW0sIHRodXMgc2hvdWxkIGJlIGxlc3MgdGhhbiAxLlxuICAgICAgICogVGhlIGNsb3NlciBpdCBpcyB0byAwIHRoZSBsZXNzIHRpZ2h0IHN5c3RlbSB3aWxsIGJlLlxuICAgICAgICovXG4gICAgICBkcmFnQ29lZmZpY2llbnQ6IDAuOSwgLy8gVE9ETzogTmVlZCB0byByZW5hbWUgdGhpcyB0byBzb21ldGhpbmcgYmV0dGVyLiBFLmcuIGBkcmFnQ29lZmZpY2llbnRgXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVmYXVsdCB0aW1lIHN0ZXAgKGR0KSBmb3IgZm9yY2VzIGludGVncmF0aW9uXG4gICAgICAgKi9cbiAgICAgIHRpbWVTdGVwIDogMC41LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkYXB0aXZlIHRpbWUgc3RlcCB1c2VzIGF2ZXJhZ2Ugc3ByaW5nIGxlbmd0aCB0byBjb21wdXRlIGFjdHVhbCB0aW1lIHN0ZXA6XG4gICAgICAgKiBTZWU6IGh0dHBzOi8vdHdpdHRlci5jb20vYW52YWthL3N0YXR1cy8xMjkzMDY3MTYwNzU1OTU3NzYwXG4gICAgICAgKi9cbiAgICAgIGFkYXB0aXZlVGltZVN0ZXBXZWlnaHQ6IDAsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBwYXJhbWV0ZXIgZGVmaW5lcyBudW1iZXIgb2YgZGltZW5zaW9ucyBvZiB0aGUgc3BhY2Ugd2hlcmUgc2ltdWxhdGlvblxuICAgICAgICogaXMgcGVyZm9ybWVkLiBcbiAgICAgICAqL1xuICAgICAgZGltZW5zaW9uczogMixcblxuICAgICAgLyoqXG4gICAgICAgKiBJbiBkZWJ1ZyBtb2RlIG1vcmUgY2hlY2tzIGFyZSBwZXJmb3JtZWQsIHRoaXMgd2lsbCBoZWxwIHlvdSBjYXRjaCBlcnJvcnNcbiAgICAgICAqIHF1aWNrbHksIGhvd2V2ZXIgZm9yIHByb2R1Y3Rpb24gYnVpbGQgaXQgaXMgcmVjb21tZW5kZWQgdG8gdHVybiBvZmYgdGhpcyBmbGFnXG4gICAgICAgKiB0byBzcGVlZCB1cCBjb21wdXRhdGlvbi5cbiAgICAgICAqL1xuICAgICAgZGVidWc6IGZhbHNlXG4gIH0pO1xuXG4gIHZhciBmYWN0b3J5ID0gZGltZW5zaW9uYWxDYWNoZVtzZXR0aW5ncy5kaW1lbnNpb25zXTtcbiAgaWYgKCFmYWN0b3J5KSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBzZXR0aW5ncy5kaW1lbnNpb25zO1xuICAgIGZhY3RvcnkgPSB7XG4gICAgICBCb2R5OiBnZW5lcmF0ZUNyZWF0ZUJvZHlGdW5jdGlvbihkaW1lbnNpb25zLCBzZXR0aW5ncy5kZWJ1ZyksXG4gICAgICBjcmVhdGVRdWFkVHJlZTogZ2VuZXJhdGVRdWFkVHJlZUZ1bmN0aW9uKGRpbWVuc2lvbnMpLFxuICAgICAgY3JlYXRlQm91bmRzOiBnZW5lcmF0ZUJvdW5kc0Z1bmN0aW9uKGRpbWVuc2lvbnMpLFxuICAgICAgY3JlYXRlRHJhZ0ZvcmNlOiBnZW5lcmF0ZUNyZWF0ZURyYWdGb3JjZUZ1bmN0aW9uKGRpbWVuc2lvbnMpLFxuICAgICAgY3JlYXRlU3ByaW5nRm9yY2U6IGdlbmVyYXRlQ3JlYXRlU3ByaW5nRm9yY2VGdW5jdGlvbihkaW1lbnNpb25zKSxcbiAgICAgIGludGVncmF0ZTogZ2VuZXJhdGVJbnRlZ3JhdG9yRnVuY3Rpb24oZGltZW5zaW9ucyksXG4gICAgfTtcbiAgICBkaW1lbnNpb25hbENhY2hlW2RpbWVuc2lvbnNdID0gZmFjdG9yeTtcbiAgfVxuXG4gIHZhciBCb2R5ID0gZmFjdG9yeS5Cb2R5O1xuICB2YXIgY3JlYXRlUXVhZFRyZWUgPSBmYWN0b3J5LmNyZWF0ZVF1YWRUcmVlO1xuICB2YXIgY3JlYXRlQm91bmRzID0gZmFjdG9yeS5jcmVhdGVCb3VuZHM7XG4gIHZhciBjcmVhdGVEcmFnRm9yY2UgPSBmYWN0b3J5LmNyZWF0ZURyYWdGb3JjZTtcbiAgdmFyIGNyZWF0ZVNwcmluZ0ZvcmNlID0gZmFjdG9yeS5jcmVhdGVTcHJpbmdGb3JjZTtcbiAgdmFyIGludGVncmF0ZSA9IGZhY3RvcnkuaW50ZWdyYXRlO1xuICB2YXIgY3JlYXRlQm9keSA9IHBvcyA9PiBuZXcgQm9keShwb3MpO1xuXG4gIHZhciByYW5kb20gPSByZXF1aXJlKCduZ3JhcGgucmFuZG9tJykucmFuZG9tKDQyKTtcbiAgdmFyIGJvZGllcyA9IFtdOyAvLyBCb2RpZXMgaW4gdGhpcyBzaW11bGF0aW9uLlxuICB2YXIgc3ByaW5ncyA9IFtdOyAvLyBTcHJpbmdzIGluIHRoaXMgc2ltdWxhdGlvbi5cblxuICB2YXIgcXVhZFRyZWUgPSBjcmVhdGVRdWFkVHJlZShzZXR0aW5ncywgcmFuZG9tKTtcbiAgdmFyIGJvdW5kcyA9IGNyZWF0ZUJvdW5kcyhib2RpZXMsIHNldHRpbmdzLCByYW5kb20pO1xuICB2YXIgc3ByaW5nRm9yY2UgPSBjcmVhdGVTcHJpbmdGb3JjZShzZXR0aW5ncywgcmFuZG9tKTtcbiAgdmFyIGRyYWdGb3JjZSA9IGNyZWF0ZURyYWdGb3JjZShzZXR0aW5ncyk7XG5cbiAgdmFyIHRvdGFsTW92ZW1lbnQgPSAwOyAvLyBob3cgbXVjaCBtb3ZlbWVudCB3ZSBtYWRlIG9uIGxhc3Qgc3RlcFxuICB2YXIgZm9yY2VzID0gW107XG4gIHZhciBmb3JjZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIGl0ZXJhdGlvbk51bWJlciA9IDA7XG4gXG4gIGFkZEZvcmNlKCduYm9keScsIG5ib2R5Rm9yY2UpO1xuICBhZGRGb3JjZSgnc3ByaW5nJywgdXBkYXRlU3ByaW5nRm9yY2UpO1xuXG4gIHZhciBwdWJsaWNBcGkgPSB7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgYm9kaWVzLCByZWdpc3RlcmVkIHdpdGggY3VycmVudCBzaW11bGF0b3JcbiAgICAgKlxuICAgICAqIE5vdGU6IFRvIGFkZCBuZXcgYm9keSwgdXNlIGFkZEJvZHkoKSBtZXRob2QuIFRoaXMgcHJvcGVydHkgaXMgb25seVxuICAgICAqIGV4cG9zZWQgZm9yIHRlc3RpbmcvcGVyZm9ybWFuY2UgcHVycG9zZXMuXG4gICAgICovXG4gICAgYm9kaWVzOiBib2RpZXMsXG4gIFxuICAgIHF1YWRUcmVlOiBxdWFkVHJlZSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHNwcmluZ3MsIHJlZ2lzdGVyZWQgd2l0aCBjdXJyZW50IHNpbXVsYXRvclxuICAgICAqXG4gICAgICogTm90ZTogVG8gYWRkIG5ldyBzcHJpbmcsIHVzZSBhZGRTcHJpbmcoKSBtZXRob2QuIFRoaXMgcHJvcGVydHkgaXMgb25seVxuICAgICAqIGV4cG9zZWQgZm9yIHRlc3RpbmcvcGVyZm9ybWFuY2UgcHVycG9zZXMuXG4gICAgICovXG4gICAgc3ByaW5nczogc3ByaW5ncyxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2V0dGluZ3Mgd2l0aCB3aGljaCBjdXJyZW50IHNpbXVsYXRvciB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBzZXR0aW5nczogc2V0dGluZ3MsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGZvcmNlIHRvIHNpbXVsYXRpb25cbiAgICAgKi9cbiAgICBhZGRGb3JjZTogYWRkRm9yY2UsXG4gICAgXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGZvcmNlIGZyb20gdGhlIHNpbXVsYXRpb24uXG4gICAgICovXG4gICAgcmVtb3ZlRm9yY2U6IHJlbW92ZUZvcmNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgcmVnaXN0ZXJlZCBmb3JjZXMuXG4gICAgICovXG4gICAgZ2V0Rm9yY2VzOiBnZXRGb3JjZXMsXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBvbmUgc3RlcCBvZiBmb3JjZSBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3lzdGVtIGlzIGNvbnNpZGVyZWQgc3RhYmxlOyBGYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yY2VzW2ldKGl0ZXJhdGlvbk51bWJlcik7XG4gICAgICB9XG4gICAgICB2YXIgbW92ZW1lbnQgPSBpbnRlZ3JhdGUoYm9kaWVzLCBzZXR0aW5ncy50aW1lU3RlcCwgc2V0dGluZ3MuYWRhcHRpdmVUaW1lU3RlcFdlaWdodCk7XG4gICAgICBpdGVyYXRpb25OdW1iZXIgKz0gMTtcbiAgICAgIHJldHVybiBtb3ZlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBib2R5IHRvIHRoZSBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bmdyYXBoLnBoeXNpY3MucHJpbWl0aXZlcy5Cb2R5fSBib2R5IHBoeXNpY2FsIGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtuZ3JhcGgucGh5c2ljcy5wcmltaXRpdmVzLkJvZHl9IGFkZGVkIGJvZHlcbiAgICAgKi9cbiAgICBhZGRCb2R5OiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm9keSBpcyByZXF1aXJlZCcpO1xuICAgICAgfVxuICAgICAgYm9kaWVzLnB1c2goYm9keSk7XG5cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGJvZHkgdG8gdGhlIHN5c3RlbSBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvcyBwb3NpdGlvbiBvZiBhIGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtuZ3JhcGgucGh5c2ljcy5wcmltaXRpdmVzLkJvZHl9IGFkZGVkIGJvZHlcbiAgICAgKi9cbiAgICBhZGRCb2R5QXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIGlmICghcG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm9keSBwb3NpdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgICAgfVxuICAgICAgdmFyIGJvZHkgPSBjcmVhdGVCb2R5KHBvcyk7XG4gICAgICBib2RpZXMucHVzaChib2R5KTtcblxuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYm9keSBmcm9tIHRoZSBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bmdyYXBoLnBoeXNpY3MucHJpbWl0aXZlcy5Cb2R5fSBib2R5IHRvIHJlbW92ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYm9keSBmb3VuZCBhbmQgcmVtb3ZlZC4gZmFsc3kgb3RoZXJ3aXNlO1xuICAgICAqL1xuICAgIHJlbW92ZUJvZHk6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICBpZiAoIWJvZHkpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICAgIGlmIChpZHggPCAwKSB7IHJldHVybjsgfVxuXG4gICAgICBib2RpZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICBpZiAoYm9kaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBib3VuZHMucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3ByaW5nIHRvIHRoaXMgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gYSBoYW5kbGUgZm9yIGEgc3ByaW5nLiBJZiB5b3Ugd2FudCB0byBsYXRlciByZW1vdmVcbiAgICAgKiBzcHJpbmcgcGFzcyBpdCB0byByZW1vdmVTcHJpbmcoKSBtZXRob2QuXG4gICAgICovXG4gICAgYWRkU3ByaW5nOiBmdW5jdGlvbiAoYm9keTEsIGJvZHkyLCBzcHJpbmdMZW5ndGgsIHNwcmluZ0NvZWZmaWNpZW50KSB7XG4gICAgICBpZiAoIWJvZHkxIHx8ICFib2R5Mikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgbnVsbCBzcHJpbmcgdG8gZm9yY2Ugc2ltdWxhdG9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ByaW5nTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzcHJpbmdMZW5ndGggPSAtMTsgLy8gYXNzdW1lIGdsb2JhbCBjb25maWd1cmF0aW9uXG4gICAgICB9XG5cbiAgICAgIHZhciBzcHJpbmcgPSBuZXcgU3ByaW5nKGJvZHkxLCBib2R5Miwgc3ByaW5nTGVuZ3RoLCBzcHJpbmdDb2VmZmljaWVudCA+PSAwID8gc3ByaW5nQ29lZmZpY2llbnQgOiAtMSk7XG4gICAgICBzcHJpbmdzLnB1c2goc3ByaW5nKTtcblxuICAgICAgLy8gVE9ETzogY291bGQgbWFyayBzaW11bGF0b3IgYXMgZGlydHkuXG4gICAgICByZXR1cm4gc3ByaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFtb3VudCBvZiBtb3ZlbWVudCBwZXJmb3JtZWQgb24gbGFzdCBzdGVwKCkgY2FsbFxuICAgICAqL1xuICAgIGdldFRvdGFsTW92ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0b3RhbE1vdmVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHNwcmluZyBmcm9tIHRoZSBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcHJpbmcgdG8gcmVtb3ZlLiBTcHJpbmcgaXMgYW4gb2JqZWN0IHJldHVybmVkIGJ5IGFkZFNwcmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgc3ByaW5nIGZvdW5kIGFuZCByZW1vdmVkLiBmYWxzeSBvdGhlcndpc2U7XG4gICAgICovXG4gICAgcmVtb3ZlU3ByaW5nOiBmdW5jdGlvbiAoc3ByaW5nKSB7XG4gICAgICBpZiAoIXNwcmluZykgeyByZXR1cm47IH1cbiAgICAgIHZhciBpZHggPSBzcHJpbmdzLmluZGV4T2Yoc3ByaW5nKTtcbiAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICBzcHJpbmdzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QmVzdE5ld0JvZHlQb3NpdGlvbjogZnVuY3Rpb24gKG5laWdoYm9ycykge1xuICAgICAgcmV0dXJuIGJvdW5kcy5nZXRCZXN0TmV3UG9zaXRpb24obmVpZ2hib3JzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBib3VuZGluZyBib3ggd2hpY2ggY292ZXJzIGFsbCBib2RpZXNcbiAgICAgKi9cbiAgICBnZXRCQm94OiBnZXRCb3VuZGluZ0JveCwgXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJvdW5kaW5nQm94LCBcblxuICAgIGludmFsaWRhdGVCQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ludmFsaWRhdGVCQm94KCkgaXMgZGVwcmVjYXRlZCwgYm91bmRzIGFsd2F5cyByZWNvbXB1dGVkIG9uIGBnZXRCQm94KClgIGNhbGwnKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogTW92ZSB0aGUgZm9yY2Ugc3BlY2lmaWMgc3R1ZmYgdG8gZm9yY2VcbiAgICBncmF2aXR5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzLmdyYXZpdHkgPSB2YWx1ZTtcbiAgICAgICAgcXVhZFRyZWUub3B0aW9ucyh7Z3Jhdml0eTogdmFsdWV9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MuZ3Jhdml0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGhldGE6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0dGluZ3MudGhldGEgPSB2YWx1ZTtcbiAgICAgICAgcXVhZFRyZWUub3B0aW9ucyh7dGhldGE6IHZhbHVlfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnRoZXRhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICByYW5kb206IHJhbmRvbVxuICB9O1xuXG4gIC8vIGFsbG93IHNldHRpbmdzIG1vZGlmaWNhdGlvbiB2aWEgcHVibGljIEFQSTpcbiAgZXhwb3NlKHNldHRpbmdzLCBwdWJsaWNBcGkpO1xuXG4gIGV2ZW50aWZ5KHB1YmxpY0FwaSk7XG5cbiAgcmV0dXJuIHB1YmxpY0FwaTtcblxuICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICBib3VuZHMudXBkYXRlKCk7XG4gICAgcmV0dXJuIGJvdW5kcy5ib3g7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRGb3JjZShmb3JjZU5hbWUsIGZvcmNlRnVuY3Rpb24pIHtcbiAgICBpZiAoZm9yY2VNYXAuaGFzKGZvcmNlTmFtZSkpIHRocm93IG5ldyBFcnJvcignRm9yY2UgJyArIGZvcmNlTmFtZSArICcgaXMgYWxyZWFkeSBhZGRlZCcpO1xuXG4gICAgZm9yY2VNYXAuc2V0KGZvcmNlTmFtZSwgZm9yY2VGdW5jdGlvbik7XG4gICAgZm9yY2VzLnB1c2goZm9yY2VGdW5jdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGb3JjZShmb3JjZU5hbWUpIHtcbiAgICB2YXIgZm9yY2VJbmRleCA9IGZvcmNlcy5pbmRleE9mKGZvcmNlTWFwLmdldChmb3JjZU5hbWUpKTtcbiAgICBpZiAoZm9yY2VJbmRleCA8IDApIHJldHVybjtcbiAgICBmb3JjZXMuc3BsaWNlKGZvcmNlSW5kZXgsIDEpO1xuICAgIGZvcmNlTWFwLmRlbGV0ZShmb3JjZU5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rm9yY2VzKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBJIHRydXN0IHRoZW0gb3IgY2xvbmUgdGhlIGZvcmNlcz9cbiAgICByZXR1cm4gZm9yY2VNYXA7XG4gIH1cblxuICBmdW5jdGlvbiBuYm9keUZvcmNlKC8qIGl0ZXJhdGlvblVtYmVyICovKSB7XG4gICAgaWYgKGJvZGllcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIHF1YWRUcmVlLmluc2VydEJvZGllcyhib2RpZXMpO1xuICAgIHZhciBpID0gYm9kaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgIGlmICghYm9keS5pc1Bpbm5lZCkge1xuICAgICAgICBib2R5LnJlc2V0KCk7XG4gICAgICAgIHF1YWRUcmVlLnVwZGF0ZUJvZHlGb3JjZShib2R5KTtcbiAgICAgICAgZHJhZ0ZvcmNlLnVwZGF0ZShib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTcHJpbmdGb3JjZSgpIHtcbiAgICB2YXIgaSA9IHNwcmluZ3MubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNwcmluZ0ZvcmNlLnVwZGF0ZShzcHJpbmdzW2ldKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBleHBvc2Uoc2V0dGluZ3MsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gc2V0dGluZ3MpIHtcbiAgICBhdWdtZW50KHNldHRpbmdzLCB0YXJnZXQsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXVnbWVudChzb3VyY2UsIHRhcmdldCwga2V5KSB7XG4gIGlmICghc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybjtcbiAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHRoaXMgYWNjZXNzb3IgaXMgYWxyZWFkeSBkZWZpbmVkLiBJZ25vcmUgaXRcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNvdXJjZUlzTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlKHNvdXJjZVtrZXldKTtcblxuICBpZiAoc291cmNlSXNOdW1iZXIpIHtcbiAgICB0YXJnZXRba2V5XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG9mICcgKyBrZXkgKyAnIHNob3VsZCBiZSBhIHZhbGlkIG51bWJlci4nKTtcbiAgICAgICAgc291cmNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ngraph.forcelayout/lib/spring.js":
/*!*******************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/lib/spring.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = Spring;\n\n/**\n * Represents a physical spring. Spring connects two bodies, has rest length\n * stiffness coefficient and optional weight\n */\nfunction Spring(fromBody, toBody, length, springCoefficient) {\n    this.from = fromBody;\n    this.to = toBody;\n    this.length = length;\n    this.coefficient = springCoefficient;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZvcmNlbGF5b3V0L2xpYi9zcHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWljaGFcXERvd25sb2Fkc1xcem91YmtvZmZzaXRlXFxwZXJzb25hbHNpdGVcXG5vZGVfbW9kdWxlc1xcbmdyYXBoLmZvcmNlbGF5b3V0XFxsaWJcXHNwcmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcGh5c2ljYWwgc3ByaW5nLiBTcHJpbmcgY29ubmVjdHMgdHdvIGJvZGllcywgaGFzIHJlc3QgbGVuZ3RoXG4gKiBzdGlmZm5lc3MgY29lZmZpY2llbnQgYW5kIG9wdGlvbmFsIHdlaWdodFxuICovXG5mdW5jdGlvbiBTcHJpbmcoZnJvbUJvZHksIHRvQm9keSwgbGVuZ3RoLCBzcHJpbmdDb2VmZmljaWVudCkge1xuICAgIHRoaXMuZnJvbSA9IGZyb21Cb2R5O1xuICAgIHRoaXMudG8gPSB0b0JvZHk7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5jb2VmZmljaWVudCA9IHNwcmluZ0NvZWZmaWNpZW50O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ngraph.forcelayout/lib/spring.js\n");

/***/ })

};
;