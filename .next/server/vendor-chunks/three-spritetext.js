"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-spritetext";
exports.ids = ["vendor-chunks/three-spritetext"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-spritetext/dist/three-spritetext.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/three-spritetext/dist/three-spritetext.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _default)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e, _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (undefined !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (String )(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nvar three = typeof window !== 'undefined' && window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  CanvasTexture: three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture,\n  Sprite: three__WEBPACK_IMPORTED_MODULE_0__.Sprite,\n  SpriteMaterial: three__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial,\n  SRGBColorSpace: three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace\n};\nvar _default = /*#__PURE__*/function (_three$Sprite) {\n  function _default() {\n    var _this;\n    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var textHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgba(255, 255, 255, 1)';\n    _classCallCheck(this, _default);\n    _this = _callSuper(this, _default, [new three.SpriteMaterial()]);\n    _this._text = \"\".concat(text);\n    _this._textHeight = textHeight;\n    _this._color = color;\n    _this._backgroundColor = false; // no background color\n\n    _this._padding = 0;\n    _this._borderWidth = 0;\n    _this._borderRadius = 0;\n    _this._borderColor = 'white';\n    _this._strokeWidth = 0;\n    _this._strokeColor = 'white';\n    _this._fontFace = 'system-ui';\n    _this._fontSize = 90; // defines text resolution\n    _this._fontWeight = 'normal';\n    _this._canvas = document.createElement('canvas');\n    _this._genCanvas();\n    return _this;\n  }\n  _inherits(_default, _three$Sprite);\n  return _createClass(_default, [{\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      this._text = text;\n      this._genCanvas();\n    }\n  }, {\n    key: \"textHeight\",\n    get: function get() {\n      return this._textHeight;\n    },\n    set: function set(textHeight) {\n      this._textHeight = textHeight;\n      this._genCanvas();\n    }\n  }, {\n    key: \"color\",\n    get: function get() {\n      return this._color;\n    },\n    set: function set(color) {\n      this._color = color;\n      this._genCanvas();\n    }\n  }, {\n    key: \"backgroundColor\",\n    get: function get() {\n      return this._backgroundColor;\n    },\n    set: function set(color) {\n      this._backgroundColor = color;\n      this._genCanvas();\n    }\n  }, {\n    key: \"padding\",\n    get: function get() {\n      return this._padding;\n    },\n    set: function set(padding) {\n      this._padding = padding;\n      this._genCanvas();\n    }\n  }, {\n    key: \"borderWidth\",\n    get: function get() {\n      return this._borderWidth;\n    },\n    set: function set(borderWidth) {\n      this._borderWidth = borderWidth;\n      this._genCanvas();\n    }\n  }, {\n    key: \"borderRadius\",\n    get: function get() {\n      return this._borderRadius;\n    },\n    set: function set(borderRadius) {\n      this._borderRadius = borderRadius;\n      this._genCanvas();\n    }\n  }, {\n    key: \"borderColor\",\n    get: function get() {\n      return this._borderColor;\n    },\n    set: function set(borderColor) {\n      this._borderColor = borderColor;\n      this._genCanvas();\n    }\n  }, {\n    key: \"fontFace\",\n    get: function get() {\n      return this._fontFace;\n    },\n    set: function set(fontFace) {\n      this._fontFace = fontFace;\n      this._genCanvas();\n    }\n  }, {\n    key: \"fontSize\",\n    get: function get() {\n      return this._fontSize;\n    },\n    set: function set(fontSize) {\n      this._fontSize = fontSize;\n      this._genCanvas();\n    }\n  }, {\n    key: \"fontWeight\",\n    get: function get() {\n      return this._fontWeight;\n    },\n    set: function set(fontWeight) {\n      this._fontWeight = fontWeight;\n      this._genCanvas();\n    }\n  }, {\n    key: \"strokeWidth\",\n    get: function get() {\n      return this._strokeWidth;\n    },\n    set: function set(strokeWidth) {\n      this._strokeWidth = strokeWidth;\n      this._genCanvas();\n    }\n  }, {\n    key: \"strokeColor\",\n    get: function get() {\n      return this._strokeColor;\n    },\n    set: function set(strokeColor) {\n      this._strokeColor = strokeColor;\n      this._genCanvas();\n    }\n  }, {\n    key: \"_genCanvas\",\n    value: function _genCanvas() {\n      var _this2 = this;\n      var canvas = this._canvas;\n      var ctx = canvas.getContext('2d');\n      var relFactor = 1 / this.textHeight;\n      var border = Array.isArray(this.borderWidth) ? this.borderWidth : [this.borderWidth, this.borderWidth]; // x,y border\n      var relBorder = border.map(function (b) {\n        return b * _this2.fontSize * relFactor;\n      }); // border in canvas units\n\n      var borderRadius = Array.isArray(this.borderRadius) ? this.borderRadius : [this.borderRadius, this.borderRadius, this.borderRadius, this.borderRadius]; // tl tr br bl corners\n      var relBorderRadius = borderRadius.map(function (b) {\n        return b * _this2.fontSize * relFactor;\n      }); // border radius in canvas units\n\n      var padding = Array.isArray(this.padding) ? this.padding : [this.padding, this.padding]; // x,y padding\n      var relPadding = padding.map(function (p) {\n        return p * _this2.fontSize * relFactor;\n      }); // padding in canvas units\n\n      var lines = this.text.split('\\n');\n      var font = \"\".concat(this.fontWeight, \" \").concat(this.fontSize, \"px \").concat(this.fontFace);\n      ctx.font = font; // measure canvas with appropriate font\n      var innerWidth = Math.max.apply(Math, _toConsumableArray(lines.map(function (line) {\n        return ctx.measureText(line).width;\n      })));\n      var innerHeight = this.fontSize * lines.length;\n      canvas.width = innerWidth + relBorder[0] * 2 + relPadding[0] * 2;\n      canvas.height = innerHeight + relBorder[1] * 2 + relPadding[1] * 2;\n\n      // paint border\n      if (this.borderWidth) {\n        ctx.strokeStyle = this.borderColor;\n        if (relBorder[0]) {\n          // left + right borders\n          var hb = relBorder[0] / 2;\n          ctx.lineWidth = relBorder[0];\n          ctx.beginPath();\n          ctx.moveTo(hb, relBorderRadius[0]);\n          ctx.lineTo(hb, canvas.height - relBorderRadius[3]);\n          ctx.moveTo(canvas.width - hb, relBorderRadius[1]);\n          ctx.lineTo(canvas.width - hb, canvas.height - relBorderRadius[2]);\n          ctx.stroke();\n        }\n        if (relBorder[1]) {\n          // top + bottom borders\n          var _hb = relBorder[1] / 2;\n          ctx.lineWidth = relBorder[1];\n          ctx.beginPath();\n          ctx.moveTo(Math.max(relBorder[0], relBorderRadius[0]), _hb);\n          ctx.lineTo(canvas.width - Math.max(relBorder[0], relBorderRadius[1]), _hb);\n          ctx.moveTo(Math.max(relBorder[0], relBorderRadius[3]), canvas.height - _hb);\n          ctx.lineTo(canvas.width - Math.max(relBorder[0], relBorderRadius[2]), canvas.height - _hb);\n          ctx.stroke();\n        }\n        if (this.borderRadius) {\n          // strike rounded corners\n          var cornerWidth = Math.max.apply(Math, _toConsumableArray(relBorder));\n          var _hb2 = cornerWidth / 2;\n          ctx.lineWidth = cornerWidth;\n          ctx.beginPath();\n          [!!relBorderRadius[0] && [relBorderRadius[0], _hb2, _hb2, relBorderRadius[0]], !!relBorderRadius[1] && [canvas.width - relBorderRadius[1], canvas.width - _hb2, _hb2, relBorderRadius[1]], !!relBorderRadius[2] && [canvas.width - relBorderRadius[2], canvas.width - _hb2, canvas.height - _hb2, canvas.height - relBorderRadius[2]], !!relBorderRadius[3] && [relBorderRadius[3], _hb2, canvas.height - _hb2, canvas.height - relBorderRadius[3]]].filter(function (d) {\n            return d;\n          }).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 4),\n              x0 = _ref2[0],\n              x1 = _ref2[1],\n              y0 = _ref2[2],\n              y1 = _ref2[3];\n            ctx.moveTo(x0, y0);\n            ctx.quadraticCurveTo(x1, y0, x1, y1);\n          });\n          ctx.stroke();\n        }\n      }\n\n      // paint background\n      if (this.backgroundColor) {\n        ctx.fillStyle = this.backgroundColor;\n        if (!this.borderRadius) {\n          ctx.fillRect(relBorder[0], relBorder[1], canvas.width - relBorder[0] * 2, canvas.height - relBorder[1] * 2);\n        } else {\n          // fill with rounded corners\n          ctx.beginPath();\n          ctx.moveTo(relBorder[0], relBorderRadius[0]);\n          [[relBorder[0], relBorderRadius[0], canvas.width - relBorderRadius[1], relBorder[1], relBorder[1], relBorder[1]],\n          // t\n          [canvas.width - relBorder[0], canvas.width - relBorder[0], canvas.width - relBorder[0], relBorder[1], relBorderRadius[1], canvas.height - relBorderRadius[2]],\n          // r\n          [canvas.width - relBorder[0], canvas.width - relBorderRadius[2], relBorderRadius[3], canvas.height - relBorder[1], canvas.height - relBorder[1], canvas.height - relBorder[1]],\n          // b\n          [relBorder[0], relBorder[0], relBorder[0], canvas.height - relBorder[1], canvas.height - relBorderRadius[3], relBorderRadius[0]] // t\n          ].forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 6),\n              x0 = _ref4[0],\n              x1 = _ref4[1],\n              x2 = _ref4[2],\n              y0 = _ref4[3],\n              y1 = _ref4[4],\n              y2 = _ref4[5];\n            ctx.quadraticCurveTo(x0, y0, x1, y1);\n            ctx.lineTo(x2, y2);\n          });\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n      ctx.translate.apply(ctx, _toConsumableArray(relBorder));\n      ctx.translate.apply(ctx, _toConsumableArray(relPadding));\n\n      // paint text\n      ctx.font = font; // Set font again after canvas is resized, as context properties are reset\n      ctx.fillStyle = this.color;\n      ctx.textBaseline = 'bottom';\n      var drawTextStroke = this.strokeWidth > 0;\n      if (drawTextStroke) {\n        ctx.lineWidth = this.strokeWidth * this.fontSize / 10;\n        ctx.strokeStyle = this.strokeColor;\n      }\n      lines.forEach(function (line, index) {\n        var lineX = (innerWidth - ctx.measureText(line).width) / 2;\n        var lineY = (index + 1) * _this2.fontSize;\n        drawTextStroke && ctx.strokeText(line, lineX, lineY);\n        ctx.fillText(line, lineX, lineY);\n      });\n\n      // Inject canvas into sprite\n      if (this.material.map) this.material.map.dispose(); // gc previous texture\n      var texture = this.material.map = new three.CanvasTexture(canvas);\n      texture.colorSpace = three.SRGBColorSpace;\n      var yScale = this.textHeight * lines.length + border[1] * 2 + padding[1] * 2;\n      this.scale.set(yScale * canvas.width / canvas.height, yScale, 0);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.text, this.textHeight, this.color).copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      three.Sprite.prototype.copy.call(this, source);\n      this.color = source.color;\n      this.backgroundColor = source.backgroundColor;\n      this.padding = source.padding;\n      this.borderWidth = source.borderWidth;\n      this.borderColor = source.borderColor;\n      this.fontFace = source.fontFace;\n      this.fontSize = source.fontSize;\n      this.fontWeight = source.fontWeight;\n      this.strokeWidth = source.strokeWidth;\n      this.strokeColor = source.strokeColor;\n      return this;\n    }\n  }]);\n}(three.Sprite);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3ByaXRldGV4dC9kaXN0L3RocmVlLXNwcml0ZXRleHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThFOztBQUU5RTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSxrRUFBa0U7QUFDdEYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQWE7QUFD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QUFDSCxDQUFDOztBQUU4QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWNoYVxcRG93bmxvYWRzXFx6b3Via29mZnNpdGVcXHBlcnNvbmFsc2l0ZVxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zcHJpdGV0ZXh0XFxkaXN0XFx0aHJlZS1zcHJpdGV0ZXh0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW52YXNUZXh0dXJlLCBTcHJpdGUsIFNwcml0ZU1hdGVyaWFsLCBTUkdCQ29sb3JTcGFjZSB9IGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8IGZhbHNlLCBvLmNvbmZpZ3VyYWJsZSA9IHRydWUsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gdHJ1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9IHRydWUsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodW5kZWZpbmVkICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodW5kZWZpbmVkICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgcik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFN0cmluZyApKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgdGhyZWUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVEhSRUUgPyB3aW5kb3cuVEhSRUUgLy8gUHJlZmVyIGNvbnN1bXB0aW9uIGZyb20gZ2xvYmFsIFRIUkVFLCBpZiBleGlzdHNcbjoge1xuICBDYW52YXNUZXh0dXJlOiBDYW52YXNUZXh0dXJlLFxuICBTcHJpdGU6IFNwcml0ZSxcbiAgU3ByaXRlTWF0ZXJpYWw6IFNwcml0ZU1hdGVyaWFsLFxuICBTUkdCQ29sb3JTcGFjZTogU1JHQkNvbG9yU3BhY2Vcbn07XG52YXIgX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF90aHJlZSRTcHJpdGUpIHtcbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciB0ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgdGV4dEhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTA7XG4gICAgdmFyIGNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAxKSc7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgX2RlZmF1bHQsIFtuZXcgdGhyZWUuU3ByaXRlTWF0ZXJpYWwoKV0pO1xuICAgIF90aGlzLl90ZXh0ID0gXCJcIi5jb25jYXQodGV4dCk7XG4gICAgX3RoaXMuX3RleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgIF90aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIF90aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSBmYWxzZTsgLy8gbm8gYmFja2dyb3VuZCBjb2xvclxuXG4gICAgX3RoaXMuX3BhZGRpbmcgPSAwO1xuICAgIF90aGlzLl9ib3JkZXJXaWR0aCA9IDA7XG4gICAgX3RoaXMuX2JvcmRlclJhZGl1cyA9IDA7XG4gICAgX3RoaXMuX2JvcmRlckNvbG9yID0gJ3doaXRlJztcbiAgICBfdGhpcy5fc3Ryb2tlV2lkdGggPSAwO1xuICAgIF90aGlzLl9zdHJva2VDb2xvciA9ICd3aGl0ZSc7XG4gICAgX3RoaXMuX2ZvbnRGYWNlID0gJ3N5c3RlbS11aSc7XG4gICAgX3RoaXMuX2ZvbnRTaXplID0gOTA7IC8vIGRlZmluZXMgdGV4dCByZXNvbHV0aW9uXG4gICAgX3RoaXMuX2ZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICBfdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX3RoaXMuX2dlbkNhbnZhcygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF90aHJlZSRTcHJpdGUpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJ0ZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHRleHQpIHtcbiAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5fZ2VuQ2FudmFzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRIZWlnaHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0SGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dEhlaWdodCkge1xuICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IHRleHRIZWlnaHQ7XG4gICAgICB0aGlzLl9nZW5DYW52YXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbG9yKSB7XG4gICAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5fZ2VuQ2FudmFzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhY2tncm91bmRDb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbG9yKSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuX2dlbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWRkaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBhZGRpbmcpIHtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdGhpcy5fZ2VuQ2FudmFzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJvcmRlcldpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm9yZGVyV2lkdGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChib3JkZXJXaWR0aCkge1xuICAgICAgdGhpcy5fYm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIHRoaXMuX2dlbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJSYWRpdXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJSYWRpdXM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChib3JkZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMuX2JvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztcbiAgICAgIHRoaXMuX2dlbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJDb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYm9yZGVyQ29sb3IpIHtcbiAgICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9nZW5DYW52YXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEZhY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb250RmFjZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnRGYWNlKSB7XG4gICAgICB0aGlzLl9mb250RmFjZSA9IGZvbnRGYWNlO1xuICAgICAgdGhpcy5fZ2VuQ2FudmFzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250U2l6ZSkge1xuICAgICAgdGhpcy5fZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHRoaXMuX2dlbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250V2VpZ2h0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGhpcy5fZ2VuQ2FudmFzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cm9rZVdpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlV2lkdGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHJva2VXaWR0aCkge1xuICAgICAgdGhpcy5fc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHRoaXMuX2dlbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJva2VDb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3Ryb2tlQ29sb3IpIHtcbiAgICAgIHRoaXMuX3N0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgICB0aGlzLl9nZW5DYW52YXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbkNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuQ2FudmFzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIHJlbEZhY3RvciA9IDEgLyB0aGlzLnRleHRIZWlnaHQ7XG4gICAgICB2YXIgYm9yZGVyID0gQXJyYXkuaXNBcnJheSh0aGlzLmJvcmRlcldpZHRoKSA/IHRoaXMuYm9yZGVyV2lkdGggOiBbdGhpcy5ib3JkZXJXaWR0aCwgdGhpcy5ib3JkZXJXaWR0aF07IC8vIHgseSBib3JkZXJcbiAgICAgIHZhciByZWxCb3JkZXIgPSBib3JkZXIubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBiICogX3RoaXMyLmZvbnRTaXplICogcmVsRmFjdG9yO1xuICAgICAgfSk7IC8vIGJvcmRlciBpbiBjYW52YXMgdW5pdHNcblxuICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IEFycmF5LmlzQXJyYXkodGhpcy5ib3JkZXJSYWRpdXMpID8gdGhpcy5ib3JkZXJSYWRpdXMgOiBbdGhpcy5ib3JkZXJSYWRpdXMsIHRoaXMuYm9yZGVyUmFkaXVzLCB0aGlzLmJvcmRlclJhZGl1cywgdGhpcy5ib3JkZXJSYWRpdXNdOyAvLyB0bCB0ciBiciBibCBjb3JuZXJzXG4gICAgICB2YXIgcmVsQm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzLm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYiAqIF90aGlzMi5mb250U2l6ZSAqIHJlbEZhY3RvcjtcbiAgICAgIH0pOyAvLyBib3JkZXIgcmFkaXVzIGluIGNhbnZhcyB1bml0c1xuXG4gICAgICB2YXIgcGFkZGluZyA9IEFycmF5LmlzQXJyYXkodGhpcy5wYWRkaW5nKSA/IHRoaXMucGFkZGluZyA6IFt0aGlzLnBhZGRpbmcsIHRoaXMucGFkZGluZ107IC8vIHgseSBwYWRkaW5nXG4gICAgICB2YXIgcmVsUGFkZGluZyA9IHBhZGRpbmcubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwICogX3RoaXMyLmZvbnRTaXplICogcmVsRmFjdG9yO1xuICAgICAgfSk7IC8vIHBhZGRpbmcgaW4gY2FudmFzIHVuaXRzXG5cbiAgICAgIHZhciBsaW5lcyA9IHRoaXMudGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgZm9udCA9IFwiXCIuY29uY2F0KHRoaXMuZm9udFdlaWdodCwgXCIgXCIpLmNvbmNhdCh0aGlzLmZvbnRTaXplLCBcInB4IFwiKS5jb25jYXQodGhpcy5mb250RmFjZSk7XG4gICAgICBjdHguZm9udCA9IGZvbnQ7IC8vIG1lYXN1cmUgY2FudmFzIHdpdGggYXBwcm9wcmlhdGUgZm9udFxuICAgICAgdmFyIGlubmVyV2lkdGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGg7XG4gICAgICB9KSkpO1xuICAgICAgdmFyIGlubmVySGVpZ2h0ID0gdGhpcy5mb250U2l6ZSAqIGxpbmVzLmxlbmd0aDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGlubmVyV2lkdGggKyByZWxCb3JkZXJbMF0gKiAyICsgcmVsUGFkZGluZ1swXSAqIDI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaW5uZXJIZWlnaHQgKyByZWxCb3JkZXJbMV0gKiAyICsgcmVsUGFkZGluZ1sxXSAqIDI7XG5cbiAgICAgIC8vIHBhaW50IGJvcmRlclxuICAgICAgaWYgKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgaWYgKHJlbEJvcmRlclswXSkge1xuICAgICAgICAgIC8vIGxlZnQgKyByaWdodCBib3JkZXJzXG4gICAgICAgICAgdmFyIGhiID0gcmVsQm9yZGVyWzBdIC8gMjtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gcmVsQm9yZGVyWzBdO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGhiLCByZWxCb3JkZXJSYWRpdXNbMF0pO1xuICAgICAgICAgIGN0eC5saW5lVG8oaGIsIGNhbnZhcy5oZWlnaHQgLSByZWxCb3JkZXJSYWRpdXNbM10pO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oY2FudmFzLndpZHRoIC0gaGIsIHJlbEJvcmRlclJhZGl1c1sxXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhjYW52YXMud2lkdGggLSBoYiwgY2FudmFzLmhlaWdodCAtIHJlbEJvcmRlclJhZGl1c1syXSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxCb3JkZXJbMV0pIHtcbiAgICAgICAgICAvLyB0b3AgKyBib3R0b20gYm9yZGVyc1xuICAgICAgICAgIHZhciBfaGIgPSByZWxCb3JkZXJbMV0gLyAyO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSByZWxCb3JkZXJbMV07XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5tYXgocmVsQm9yZGVyWzBdLCByZWxCb3JkZXJSYWRpdXNbMF0pLCBfaGIpO1xuICAgICAgICAgIGN0eC5saW5lVG8oY2FudmFzLndpZHRoIC0gTWF0aC5tYXgocmVsQm9yZGVyWzBdLCByZWxCb3JkZXJSYWRpdXNbMV0pLCBfaGIpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5tYXgocmVsQm9yZGVyWzBdLCByZWxCb3JkZXJSYWRpdXNbM10pLCBjYW52YXMuaGVpZ2h0IC0gX2hiKTtcbiAgICAgICAgICBjdHgubGluZVRvKGNhbnZhcy53aWR0aCAtIE1hdGgubWF4KHJlbEJvcmRlclswXSwgcmVsQm9yZGVyUmFkaXVzWzJdKSwgY2FudmFzLmhlaWdodCAtIF9oYik7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvcmRlclJhZGl1cykge1xuICAgICAgICAgIC8vIHN0cmlrZSByb3VuZGVkIGNvcm5lcnNcbiAgICAgICAgICB2YXIgY29ybmVyV2lkdGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkocmVsQm9yZGVyKSk7XG4gICAgICAgICAgdmFyIF9oYjIgPSBjb3JuZXJXaWR0aCAvIDI7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNvcm5lcldpZHRoO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBbISFyZWxCb3JkZXJSYWRpdXNbMF0gJiYgW3JlbEJvcmRlclJhZGl1c1swXSwgX2hiMiwgX2hiMiwgcmVsQm9yZGVyUmFkaXVzWzBdXSwgISFyZWxCb3JkZXJSYWRpdXNbMV0gJiYgW2NhbnZhcy53aWR0aCAtIHJlbEJvcmRlclJhZGl1c1sxXSwgY2FudmFzLndpZHRoIC0gX2hiMiwgX2hiMiwgcmVsQm9yZGVyUmFkaXVzWzFdXSwgISFyZWxCb3JkZXJSYWRpdXNbMl0gJiYgW2NhbnZhcy53aWR0aCAtIHJlbEJvcmRlclJhZGl1c1syXSwgY2FudmFzLndpZHRoIC0gX2hiMiwgY2FudmFzLmhlaWdodCAtIF9oYjIsIGNhbnZhcy5oZWlnaHQgLSByZWxCb3JkZXJSYWRpdXNbMl1dLCAhIXJlbEJvcmRlclJhZGl1c1szXSAmJiBbcmVsQm9yZGVyUmFkaXVzWzNdLCBfaGIyLCBjYW52YXMuaGVpZ2h0IC0gX2hiMiwgY2FudmFzLmhlaWdodCAtIHJlbEJvcmRlclJhZGl1c1szXV1dLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgNCksXG4gICAgICAgICAgICAgIHgwID0gX3JlZjJbMF0sXG4gICAgICAgICAgICAgIHgxID0gX3JlZjJbMV0sXG4gICAgICAgICAgICAgIHkwID0gX3JlZjJbMl0sXG4gICAgICAgICAgICAgIHkxID0gX3JlZjJbM107XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4MSwgeTAsIHgxLCB5MSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhaW50IGJhY2tncm91bmRcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmICghdGhpcy5ib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgICBjdHguZmlsbFJlY3QocmVsQm9yZGVyWzBdLCByZWxCb3JkZXJbMV0sIGNhbnZhcy53aWR0aCAtIHJlbEJvcmRlclswXSAqIDIsIGNhbnZhcy5oZWlnaHQgLSByZWxCb3JkZXJbMV0gKiAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaWxsIHdpdGggcm91bmRlZCBjb3JuZXJzXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8ocmVsQm9yZGVyWzBdLCByZWxCb3JkZXJSYWRpdXNbMF0pO1xuICAgICAgICAgIFtbcmVsQm9yZGVyWzBdLCByZWxCb3JkZXJSYWRpdXNbMF0sIGNhbnZhcy53aWR0aCAtIHJlbEJvcmRlclJhZGl1c1sxXSwgcmVsQm9yZGVyWzFdLCByZWxCb3JkZXJbMV0sIHJlbEJvcmRlclsxXV0sXG4gICAgICAgICAgLy8gdFxuICAgICAgICAgIFtjYW52YXMud2lkdGggLSByZWxCb3JkZXJbMF0sIGNhbnZhcy53aWR0aCAtIHJlbEJvcmRlclswXSwgY2FudmFzLndpZHRoIC0gcmVsQm9yZGVyWzBdLCByZWxCb3JkZXJbMV0sIHJlbEJvcmRlclJhZGl1c1sxXSwgY2FudmFzLmhlaWdodCAtIHJlbEJvcmRlclJhZGl1c1syXV0sXG4gICAgICAgICAgLy8gclxuICAgICAgICAgIFtjYW52YXMud2lkdGggLSByZWxCb3JkZXJbMF0sIGNhbnZhcy53aWR0aCAtIHJlbEJvcmRlclJhZGl1c1syXSwgcmVsQm9yZGVyUmFkaXVzWzNdLCBjYW52YXMuaGVpZ2h0IC0gcmVsQm9yZGVyWzFdLCBjYW52YXMuaGVpZ2h0IC0gcmVsQm9yZGVyWzFdLCBjYW52YXMuaGVpZ2h0IC0gcmVsQm9yZGVyWzFdXSxcbiAgICAgICAgICAvLyBiXG4gICAgICAgICAgW3JlbEJvcmRlclswXSwgcmVsQm9yZGVyWzBdLCByZWxCb3JkZXJbMF0sIGNhbnZhcy5oZWlnaHQgLSByZWxCb3JkZXJbMV0sIGNhbnZhcy5oZWlnaHQgLSByZWxCb3JkZXJSYWRpdXNbM10sIHJlbEJvcmRlclJhZGl1c1swXV0gLy8gdFxuICAgICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCA2KSxcbiAgICAgICAgICAgICAgeDAgPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgeDEgPSBfcmVmNFsxXSxcbiAgICAgICAgICAgICAgeDIgPSBfcmVmNFsyXSxcbiAgICAgICAgICAgICAgeTAgPSBfcmVmNFszXSxcbiAgICAgICAgICAgICAgeTEgPSBfcmVmNFs0XSxcbiAgICAgICAgICAgICAgeTIgPSBfcmVmNFs1XTtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnRyYW5zbGF0ZS5hcHBseShjdHgsIF90b0NvbnN1bWFibGVBcnJheShyZWxCb3JkZXIpKTtcbiAgICAgIGN0eC50cmFuc2xhdGUuYXBwbHkoY3R4LCBfdG9Db25zdW1hYmxlQXJyYXkocmVsUGFkZGluZykpO1xuXG4gICAgICAvLyBwYWludCB0ZXh0XG4gICAgICBjdHguZm9udCA9IGZvbnQ7IC8vIFNldCBmb250IGFnYWluIGFmdGVyIGNhbnZhcyBpcyByZXNpemVkLCBhcyBjb250ZXh0IHByb3BlcnRpZXMgYXJlIHJlc2V0XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIHZhciBkcmF3VGV4dFN0cm9rZSA9IHRoaXMuc3Ryb2tlV2lkdGggPiAwO1xuICAgICAgaWYgKGRyYXdUZXh0U3Ryb2tlKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoICogdGhpcy5mb250U2l6ZSAvIDEwO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxpbmVYID0gKGlubmVyV2lkdGggLSBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGgpIC8gMjtcbiAgICAgICAgdmFyIGxpbmVZID0gKGluZGV4ICsgMSkgKiBfdGhpczIuZm9udFNpemU7XG4gICAgICAgIGRyYXdUZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KGxpbmUsIGxpbmVYLCBsaW5lWSk7XG4gICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBsaW5lWCwgbGluZVkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluamVjdCBjYW52YXMgaW50byBzcHJpdGVcbiAgICAgIGlmICh0aGlzLm1hdGVyaWFsLm1hcCkgdGhpcy5tYXRlcmlhbC5tYXAuZGlzcG9zZSgpOyAvLyBnYyBwcmV2aW91cyB0ZXh0dXJlXG4gICAgICB2YXIgdGV4dHVyZSA9IHRoaXMubWF0ZXJpYWwubWFwID0gbmV3IHRocmVlLkNhbnZhc1RleHR1cmUoY2FudmFzKTtcbiAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IHRocmVlLlNSR0JDb2xvclNwYWNlO1xuICAgICAgdmFyIHlTY2FsZSA9IHRoaXMudGV4dEhlaWdodCAqIGxpbmVzLmxlbmd0aCArIGJvcmRlclsxXSAqIDIgKyBwYWRkaW5nWzFdICogMjtcbiAgICAgIHRoaXMuc2NhbGUuc2V0KHlTY2FsZSAqIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQsIHlTY2FsZSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGV4dCwgdGhpcy50ZXh0SGVpZ2h0LCB0aGlzLmNvbG9yKS5jb3B5KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICB0aHJlZS5TcHJpdGUucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgdGhpcy5jb2xvciA9IHNvdXJjZS5jb2xvcjtcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gc291cmNlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIHRoaXMucGFkZGluZyA9IHNvdXJjZS5wYWRkaW5nO1xuICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IHNvdXJjZS5ib3JkZXJXaWR0aDtcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBzb3VyY2UuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmZvbnRGYWNlID0gc291cmNlLmZvbnRGYWNlO1xuICAgICAgdGhpcy5mb250U2l6ZSA9IHNvdXJjZS5mb250U2l6ZTtcbiAgICAgIHRoaXMuZm9udFdlaWdodCA9IHNvdXJjZS5mb250V2VpZ2h0O1xuICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHNvdXJjZS5zdHJva2VXaWR0aDtcbiAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBzb3VyY2Uuc3Ryb2tlQ29sb3I7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcbn0odGhyZWUuU3ByaXRlKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-spritetext/dist/three-spritetext.mjs\n");

/***/ })

};
;